// @generated, do not edit
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct ForeignEnum(i32);
impl ForeignEnum {
  pub const FOREIGN_FOO: ForeignEnum = ForeignEnum(0);
  pub const FOREIGN_BAR: ForeignEnum = ForeignEnum(1);
  pub const FOREIGN_BAZ: ForeignEnum = ForeignEnum(2);
  pub const KNOWN_VARIANTS: [ForeignEnum; 3] = [ForeignEnum::FOREIGN_FOO, ForeignEnum::FOREIGN_BAR, ForeignEnum::FOREIGN_BAZ];
  pub const fn value(self) -> i32 {
    self.0
  }
}
impl ::std::default::Default for ForeignEnum {
  fn default() -> Self {
    ForeignEnum::FOREIGN_FOO
  }
}
impl From<ForeignEnum> for i32 {
  fn from(v: ForeignEnum) -> i32 {
    v.0
  }
}
impl From<i32> for ForeignEnum {
  fn from(v: i32) -> ForeignEnum {
    ForeignEnum(v)
  }
}
impl From<ForeignEnum_Closed> for ForeignEnum {
  fn from(v: ForeignEnum_Closed) -> ForeignEnum {
    ForeignEnum(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for ForeignEnum {
}
impl ::pb_jelly::OpenProtoEnum for ForeignEnum {
  type Closed = ForeignEnum_Closed;
  fn into_known(self) -> ::std::option::Option<ForeignEnum_Closed> {
    match self {
      ForeignEnum::FOREIGN_FOO => ::std::option::Option::Some(ForeignEnum_Closed::FOREIGN_FOO),
      ForeignEnum::FOREIGN_BAR => ::std::option::Option::Some(ForeignEnum_Closed::FOREIGN_BAR),
      ForeignEnum::FOREIGN_BAZ => ::std::option::Option::Some(ForeignEnum_Closed::FOREIGN_BAZ),
      _ => None,
    }
  }
}
impl ::std::fmt::Debug for ForeignEnum {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    match <Self as ::pb_jelly::OpenProtoEnum>::name(*self) {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum ForeignEnum_Closed {
  FOREIGN_FOO = 0,
  FOREIGN_BAR = 1,
  FOREIGN_BAZ = 2,
}
impl ForeignEnum_Closed {
  pub const KNOWN_VARIANTS: [ForeignEnum_Closed; 3] = [ForeignEnum_Closed::FOREIGN_FOO, ForeignEnum_Closed::FOREIGN_BAR, ForeignEnum_Closed::FOREIGN_BAZ];
}
impl ::std::default::Default for ForeignEnum_Closed {
  fn default() -> Self {
    ForeignEnum_Closed::FOREIGN_FOO
  }
}
impl From<ForeignEnum_Closed> for i32 {
  fn from(v: ForeignEnum_Closed) -> i32 {
    match v {
      ForeignEnum_Closed::FOREIGN_FOO => 0,
      ForeignEnum_Closed::FOREIGN_BAR => 1,
      ForeignEnum_Closed::FOREIGN_BAZ => 2,
    }
  }
}
impl ::std::convert::TryFrom<i32> for ForeignEnum_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(ForeignEnum_Closed::FOREIGN_FOO),
      1 => Ok(ForeignEnum_Closed::FOREIGN_BAR),
      2 => Ok(ForeignEnum_Closed::FOREIGN_BAZ),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for ForeignEnum_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for ForeignEnum_Closed {
  fn name(self) -> &'static str {
    match self {
      ForeignEnum_Closed::FOREIGN_FOO => "FOREIGN_FOO",
      ForeignEnum_Closed::FOREIGN_BAR => "FOREIGN_BAR",
      ForeignEnum_Closed::FOREIGN_BAZ => "FOREIGN_BAZ",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct Version1Enum_TestEnum(i32);
impl Version1Enum_TestEnum {
  pub const ENUM0: Version1Enum_TestEnum = Version1Enum_TestEnum(0);
  pub const KNOWN_VARIANTS: [Version1Enum_TestEnum; 1] = [Version1Enum_TestEnum::ENUM0];
  pub const fn value(self) -> i32 {
    self.0
  }
}
impl ::std::default::Default for Version1Enum_TestEnum {
  fn default() -> Self {
    Version1Enum_TestEnum::ENUM0
  }
}
impl From<Version1Enum_TestEnum> for i32 {
  fn from(v: Version1Enum_TestEnum) -> i32 {
    v.0
  }
}
impl From<i32> for Version1Enum_TestEnum {
  fn from(v: i32) -> Version1Enum_TestEnum {
    Version1Enum_TestEnum(v)
  }
}
impl From<Version1Enum_TestEnum_Closed> for Version1Enum_TestEnum {
  fn from(v: Version1Enum_TestEnum_Closed) -> Version1Enum_TestEnum {
    Version1Enum_TestEnum(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for Version1Enum_TestEnum {
}
impl ::pb_jelly::OpenProtoEnum for Version1Enum_TestEnum {
  type Closed = Version1Enum_TestEnum_Closed;
  fn into_known(self) -> ::std::option::Option<Version1Enum_TestEnum_Closed> {
    match self {
      Version1Enum_TestEnum::ENUM0 => ::std::option::Option::Some(Version1Enum_TestEnum_Closed::ENUM0),
      _ => None,
    }
  }
}
impl ::std::fmt::Debug for Version1Enum_TestEnum {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    match <Self as ::pb_jelly::OpenProtoEnum>::name(*self) {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum Version1Enum_TestEnum_Closed {
  ENUM0 = 0,
}
impl Version1Enum_TestEnum_Closed {
  pub const KNOWN_VARIANTS: [Version1Enum_TestEnum_Closed; 1] = [Version1Enum_TestEnum_Closed::ENUM0];
}
impl ::std::default::Default for Version1Enum_TestEnum_Closed {
  fn default() -> Self {
    Version1Enum_TestEnum_Closed::ENUM0
  }
}
impl From<Version1Enum_TestEnum_Closed> for i32 {
  fn from(v: Version1Enum_TestEnum_Closed) -> i32 {
    match v {
      Version1Enum_TestEnum_Closed::ENUM0 => 0,
    }
  }
}
impl ::std::convert::TryFrom<i32> for Version1Enum_TestEnum_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(Version1Enum_TestEnum_Closed::ENUM0),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for Version1Enum_TestEnum_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for Version1Enum_TestEnum_Closed {
  fn name(self) -> &'static str {
    match self {
      Version1Enum_TestEnum_Closed::ENUM0 => "ENUM0",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct Version2Enum_TestEnum(i32);
impl Version2Enum_TestEnum {
  pub const ENUM0: Version2Enum_TestEnum = Version2Enum_TestEnum(0);
  pub const ENUM1: Version2Enum_TestEnum = Version2Enum_TestEnum(1);
  pub const KNOWN_VARIANTS: [Version2Enum_TestEnum; 2] = [Version2Enum_TestEnum::ENUM0, Version2Enum_TestEnum::ENUM1];
  pub const fn value(self) -> i32 {
    self.0
  }
}
impl ::std::default::Default for Version2Enum_TestEnum {
  fn default() -> Self {
    Version2Enum_TestEnum::ENUM0
  }
}
impl From<Version2Enum_TestEnum> for i32 {
  fn from(v: Version2Enum_TestEnum) -> i32 {
    v.0
  }
}
impl From<i32> for Version2Enum_TestEnum {
  fn from(v: i32) -> Version2Enum_TestEnum {
    Version2Enum_TestEnum(v)
  }
}
impl From<Version2Enum_TestEnum_Closed> for Version2Enum_TestEnum {
  fn from(v: Version2Enum_TestEnum_Closed) -> Version2Enum_TestEnum {
    Version2Enum_TestEnum(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for Version2Enum_TestEnum {
}
impl ::pb_jelly::OpenProtoEnum for Version2Enum_TestEnum {
  type Closed = Version2Enum_TestEnum_Closed;
  fn into_known(self) -> ::std::option::Option<Version2Enum_TestEnum_Closed> {
    match self {
      Version2Enum_TestEnum::ENUM0 => ::std::option::Option::Some(Version2Enum_TestEnum_Closed::ENUM0),
      Version2Enum_TestEnum::ENUM1 => ::std::option::Option::Some(Version2Enum_TestEnum_Closed::ENUM1),
      _ => None,
    }
  }
}
impl ::std::fmt::Debug for Version2Enum_TestEnum {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    match <Self as ::pb_jelly::OpenProtoEnum>::name(*self) {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum Version2Enum_TestEnum_Closed {
  ENUM0 = 0,
  ENUM1 = 1,
}
impl Version2Enum_TestEnum_Closed {
  pub const KNOWN_VARIANTS: [Version2Enum_TestEnum_Closed; 2] = [Version2Enum_TestEnum_Closed::ENUM0, Version2Enum_TestEnum_Closed::ENUM1];
}
impl ::std::default::Default for Version2Enum_TestEnum_Closed {
  fn default() -> Self {
    Version2Enum_TestEnum_Closed::ENUM0
  }
}
impl From<Version2Enum_TestEnum_Closed> for i32 {
  fn from(v: Version2Enum_TestEnum_Closed) -> i32 {
    match v {
      Version2Enum_TestEnum_Closed::ENUM0 => 0,
      Version2Enum_TestEnum_Closed::ENUM1 => 1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for Version2Enum_TestEnum_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(Version2Enum_TestEnum_Closed::ENUM0),
      1 => Ok(Version2Enum_TestEnum_Closed::ENUM1),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for Version2Enum_TestEnum_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for Version2Enum_TestEnum_Closed {
  fn name(self) -> &'static str {
    match self {
      Version2Enum_TestEnum_Closed::ENUM0 => "ENUM0",
      Version2Enum_TestEnum_Closed::ENUM1 => "ENUM1",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct TestMessage_NestedEnum(i32);
impl TestMessage_NestedEnum {
  pub const FOO: TestMessage_NestedEnum = TestMessage_NestedEnum(0);
  pub const BAR: TestMessage_NestedEnum = TestMessage_NestedEnum(1);
  pub const BAZ: TestMessage_NestedEnum = TestMessage_NestedEnum(2);
  /// Intentionally negative.
  pub const NEG: TestMessage_NestedEnum = TestMessage_NestedEnum(-1);
  pub const KNOWN_VARIANTS: [TestMessage_NestedEnum; 4] = [TestMessage_NestedEnum::FOO, TestMessage_NestedEnum::BAR, TestMessage_NestedEnum::BAZ, TestMessage_NestedEnum::NEG];
  pub const fn value(self) -> i32 {
    self.0
  }
}
impl ::std::default::Default for TestMessage_NestedEnum {
  fn default() -> Self {
    TestMessage_NestedEnum::FOO
  }
}
impl From<TestMessage_NestedEnum> for i32 {
  fn from(v: TestMessage_NestedEnum) -> i32 {
    v.0
  }
}
impl From<i32> for TestMessage_NestedEnum {
  fn from(v: i32) -> TestMessage_NestedEnum {
    TestMessage_NestedEnum(v)
  }
}
impl From<TestMessage_NestedEnum_Closed> for TestMessage_NestedEnum {
  fn from(v: TestMessage_NestedEnum_Closed) -> TestMessage_NestedEnum {
    TestMessage_NestedEnum(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage_NestedEnum {
}
impl ::pb_jelly::OpenProtoEnum for TestMessage_NestedEnum {
  type Closed = TestMessage_NestedEnum_Closed;
  fn into_known(self) -> ::std::option::Option<TestMessage_NestedEnum_Closed> {
    match self {
      TestMessage_NestedEnum::FOO => ::std::option::Option::Some(TestMessage_NestedEnum_Closed::FOO),
      TestMessage_NestedEnum::BAR => ::std::option::Option::Some(TestMessage_NestedEnum_Closed::BAR),
      TestMessage_NestedEnum::BAZ => ::std::option::Option::Some(TestMessage_NestedEnum_Closed::BAZ),
      TestMessage_NestedEnum::NEG => ::std::option::Option::Some(TestMessage_NestedEnum_Closed::NEG),
      _ => None,
    }
  }
}
impl ::std::fmt::Debug for TestMessage_NestedEnum {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    match <Self as ::pb_jelly::OpenProtoEnum>::name(*self) {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage_NestedEnum_Closed {
  FOO = 0,
  BAR = 1,
  BAZ = 2,
  /// Intentionally negative.
  NEG = -1,
}
impl TestMessage_NestedEnum_Closed {
  pub const KNOWN_VARIANTS: [TestMessage_NestedEnum_Closed; 4] = [TestMessage_NestedEnum_Closed::FOO, TestMessage_NestedEnum_Closed::BAR, TestMessage_NestedEnum_Closed::BAZ, TestMessage_NestedEnum_Closed::NEG];
}
impl ::std::default::Default for TestMessage_NestedEnum_Closed {
  fn default() -> Self {
    TestMessage_NestedEnum_Closed::FOO
  }
}
impl From<TestMessage_NestedEnum_Closed> for i32 {
  fn from(v: TestMessage_NestedEnum_Closed) -> i32 {
    match v {
      TestMessage_NestedEnum_Closed::FOO => 0,
      TestMessage_NestedEnum_Closed::BAR => 1,
      TestMessage_NestedEnum_Closed::BAZ => 2,
      TestMessage_NestedEnum_Closed::NEG => -1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage_NestedEnum_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(TestMessage_NestedEnum_Closed::FOO),
      1 => Ok(TestMessage_NestedEnum_Closed::BAR),
      2 => Ok(TestMessage_NestedEnum_Closed::BAZ),
      -1 => Ok(TestMessage_NestedEnum_Closed::NEG),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage_NestedEnum_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage_NestedEnum_Closed {
  fn name(self) -> &'static str {
    match self {
      TestMessage_NestedEnum_Closed::FOO => "FOO",
      TestMessage_NestedEnum_Closed::BAR => "BAR",
      TestMessage_NestedEnum_Closed::BAZ => "BAZ",
      TestMessage_NestedEnum_Closed::NEG => "NEG",
    }
  }
}

/// Test message names which collide with rust primitive names
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Option {
}
impl Option {
}
impl ::std::default::Default for Option {
  fn default() -> Self {
    Option {
    }
  }
}
lazy_static! {
  pub static ref Option_default: Option = Option::default();
}
impl ::pb_jelly::Message for Option {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Option",
      full_name: "pbtest.Option",
      fields: &[
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    0
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Option {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Vec {
}
impl Vec {
}
impl ::std::default::Default for Vec {
  fn default() -> Self {
    Vec {
    }
  }
}
lazy_static! {
  pub static ref Vec_default: Vec = Vec::default();
}
impl ::pb_jelly::Message for Vec {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Vec",
      full_name: "pbtest.Vec",
      fields: &[
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    0
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Vec {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Default {
}
impl Default {
}
impl ::std::default::Default for Default {
  fn default() -> Self {
    Default {
    }
  }
}
lazy_static! {
  pub static ref Default_default: Default = Default::default();
}
impl ::pb_jelly::Message for Default {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Default",
      full_name: "pbtest.Default",
      fields: &[
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    0
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Default {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct String {
}
impl String {
}
impl ::std::default::Default for String {
  fn default() -> Self {
    String {
    }
  }
}
lazy_static! {
  pub static ref String_default: String = String::default();
}
impl ::pb_jelly::Message for String {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "String",
      full_name: "pbtest.String",
      fields: &[
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    0
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for String {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version0OneOfNoneNullable {
  pub test_oneof: Version0OneOfNoneNullable_TestOneof,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version0OneOfNoneNullable_TestOneof {
  StringOneOf(::std::string::String),
}
impl Version0OneOfNoneNullable {
}
impl ::std::default::Default for Version0OneOfNoneNullable {
  fn default() -> Self {
    Version0OneOfNoneNullable {
      test_oneof: Version0OneOfNoneNullable_TestOneof::StringOneOf(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref Version0OneOfNoneNullable_default: Version0OneOfNoneNullable = Version0OneOfNoneNullable::default();
}
impl ::pb_jelly::Message for Version0OneOfNoneNullable {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version0OneOfNoneNullable",
      full_name: "pbtest.Version0OneOfNoneNullable",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "string_one_of",
          full_name: "pbtest.Version0OneOfNoneNullable.string_one_of",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "test_oneof",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Version0OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Version0OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_test_oneof: ::std::option::Option<Version0OneOfNoneNullable_TestOneof> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version0OneOfNoneNullable", 1)?;
          oneof_test_oneof = Some(Version0OneOfNoneNullable_TestOneof::StringOneOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_test_oneof {
      Some(v) => self.test_oneof = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'test_oneof' while parsing message pbtest.Version0OneOfNoneNullable")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version0OneOfNoneNullable {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "test_oneof" => {
        if let Version0OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
          return Some("string_one_of");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "string_one_of" => {
        if let Version0OneOfNoneNullable_TestOneof::StringOneOf(ref mut val) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version1OneOfNoneNullable {
  pub test_oneof: Version1OneOfNoneNullable_TestOneof,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version1OneOfNoneNullable_TestOneof {
  StringOneOf(::std::string::String),
  StringTwoOf(::std::string::String),
}
impl Version1OneOfNoneNullable {
}
impl ::std::default::Default for Version1OneOfNoneNullable {
  fn default() -> Self {
    Version1OneOfNoneNullable {
      test_oneof: Version1OneOfNoneNullable_TestOneof::StringOneOf(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref Version1OneOfNoneNullable_default: Version1OneOfNoneNullable = Version1OneOfNoneNullable::default();
}
impl ::pb_jelly::Message for Version1OneOfNoneNullable {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version1OneOfNoneNullable",
      full_name: "pbtest.Version1OneOfNoneNullable",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "string_one_of",
          full_name: "pbtest.Version1OneOfNoneNullable.string_one_of",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "string_two_of",
          full_name: "pbtest.Version1OneOfNoneNullable.string_two_of",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "test_oneof",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Version1OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    let mut string_two_of_size = 0;
    if let Version1OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_two_of_size += ::pb_jelly::wire_format::serialized_length(2);
      string_two_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_two_of_size += l;
    }
    size += string_two_of_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Version1OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Version1OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_test_oneof: ::std::option::Option<Version1OneOfNoneNullable_TestOneof> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version1OneOfNoneNullable", 1)?;
          oneof_test_oneof = Some(Version1OneOfNoneNullable_TestOneof::StringOneOf(val));
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version1OneOfNoneNullable", 2)?;
          oneof_test_oneof = Some(Version1OneOfNoneNullable_TestOneof::StringTwoOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_test_oneof {
      Some(v) => self.test_oneof = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'test_oneof' while parsing message pbtest.Version1OneOfNoneNullable")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version1OneOfNoneNullable {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "test_oneof" => {
        if let Version1OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
          return Some("string_one_of");
        }
        if let Version1OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
          return Some("string_two_of");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "string_one_of" => {
        match self.test_oneof {
          Version1OneOfNoneNullable_TestOneof::StringOneOf(_) => (),
          _ => {
            self.test_oneof = Version1OneOfNoneNullable_TestOneof::StringOneOf(::std::default::Default::default());
          },
        }
        if let Version1OneOfNoneNullable_TestOneof::StringOneOf(ref mut val) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "string_two_of" => {
        match self.test_oneof {
          Version1OneOfNoneNullable_TestOneof::StringTwoOf(_) => (),
          _ => {
            self.test_oneof = Version1OneOfNoneNullable_TestOneof::StringTwoOf(::std::default::Default::default());
          },
        }
        if let Version1OneOfNoneNullable_TestOneof::StringTwoOf(ref mut val) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version2OneOfNoneNullable {
  pub test_oneof: Version2OneOfNoneNullable_TestOneof,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version2OneOfNoneNullable_TestOneof {
  StringOneOf(::std::string::String),
  StringTwoOf(::std::string::String),
  IntOneOf(i32),
}
impl Version2OneOfNoneNullable {
}
impl ::std::default::Default for Version2OneOfNoneNullable {
  fn default() -> Self {
    Version2OneOfNoneNullable {
      test_oneof: Version2OneOfNoneNullable_TestOneof::StringOneOf(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref Version2OneOfNoneNullable_default: Version2OneOfNoneNullable = Version2OneOfNoneNullable::default();
}
impl ::pb_jelly::Message for Version2OneOfNoneNullable {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version2OneOfNoneNullable",
      full_name: "pbtest.Version2OneOfNoneNullable",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "string_one_of",
          full_name: "pbtest.Version2OneOfNoneNullable.string_one_of",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "string_two_of",
          full_name: "pbtest.Version2OneOfNoneNullable.string_two_of",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int_one_Of",
          full_name: "pbtest.Version2OneOfNoneNullable.int_one_Of",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "test_oneof",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Version2OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    let mut string_two_of_size = 0;
    if let Version2OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_two_of_size += ::pb_jelly::wire_format::serialized_length(2);
      string_two_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_two_of_size += l;
    }
    size += string_two_of_size;
    let mut int_one_Of_size = 0;
    if let Version2OneOfNoneNullable_TestOneof::IntOneOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      int_one_Of_size += ::pb_jelly::wire_format::serialized_length(3);
      int_one_Of_size += l;
    }
    size += int_one_Of_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Version2OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Version2OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Version2OneOfNoneNullable_TestOneof::IntOneOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_test_oneof: ::std::option::Option<Version2OneOfNoneNullable_TestOneof> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version2OneOfNoneNullable", 1)?;
          oneof_test_oneof = Some(Version2OneOfNoneNullable_TestOneof::StringOneOf(val));
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version2OneOfNoneNullable", 2)?;
          oneof_test_oneof = Some(Version2OneOfNoneNullable_TestOneof::StringTwoOf(val));
        }
        3 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version2OneOfNoneNullable", 3)?;
          oneof_test_oneof = Some(Version2OneOfNoneNullable_TestOneof::IntOneOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_test_oneof {
      Some(v) => self.test_oneof = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'test_oneof' while parsing message pbtest.Version2OneOfNoneNullable")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version2OneOfNoneNullable {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "test_oneof" => {
        if let Version2OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
          return Some("string_one_of");
        }
        if let Version2OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
          return Some("string_two_of");
        }
        if let Version2OneOfNoneNullable_TestOneof::IntOneOf(ref val) = self.test_oneof {
          return Some("int_one_Of");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "string_one_of" => {
        match self.test_oneof {
          Version2OneOfNoneNullable_TestOneof::StringOneOf(_) => (),
          _ => {
            self.test_oneof = Version2OneOfNoneNullable_TestOneof::StringOneOf(::std::default::Default::default());
          },
        }
        if let Version2OneOfNoneNullable_TestOneof::StringOneOf(ref mut val) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "string_two_of" => {
        match self.test_oneof {
          Version2OneOfNoneNullable_TestOneof::StringTwoOf(_) => (),
          _ => {
            self.test_oneof = Version2OneOfNoneNullable_TestOneof::StringTwoOf(::std::default::Default::default());
          },
        }
        if let Version2OneOfNoneNullable_TestOneof::StringTwoOf(ref mut val) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int_one_Of" => {
        match self.test_oneof {
          Version2OneOfNoneNullable_TestOneof::IntOneOf(_) => (),
          _ => {
            self.test_oneof = Version2OneOfNoneNullable_TestOneof::IntOneOf(::std::default::Default::default());
          },
        }
        if let Version2OneOfNoneNullable_TestOneof::IntOneOf(ref mut val) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version1Enum {
  pub enum_field: ::std::option::Option<Version1Enum_TestEnum>,
}
impl Version1Enum {
  pub fn has_enum_field(&self) -> bool {
    self.enum_field.is_some()
  }
  pub fn set_enum_field(&mut self, v: Version1Enum_TestEnum) {
    self.enum_field = Some(v);
  }
  pub fn get_enum_field(&self) -> Version1Enum_TestEnum {
    self.enum_field.unwrap_or_default()
  }
}
impl ::std::default::Default for Version1Enum {
  fn default() -> Self {
    Version1Enum {
      enum_field: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version1Enum_default: Version1Enum = Version1Enum::default();
}
impl ::pb_jelly::Message for Version1Enum {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version1Enum",
      full_name: "pbtest.Version1Enum",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "enum_field",
          full_name: "pbtest.Version1Enum.enum_field",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut enum_field_size = 0;
    if let Some(ref val) = self.enum_field {
      let l = ::pb_jelly::Message::compute_size(val);
      enum_field_size += ::pb_jelly::wire_format::serialized_length(1);
      enum_field_size += l;
    }
    size += enum_field_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.enum_field {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, Version1Enum_TestEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version1Enum", 1)?;
          self.enum_field = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version1Enum {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "enum_field" => {
        ::pb_jelly::reflection::FieldMut::Value(self.enum_field.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version2Enum {
  pub enum_field: ::std::option::Option<Version2Enum_TestEnum>,
}
impl Version2Enum {
  pub fn has_enum_field(&self) -> bool {
    self.enum_field.is_some()
  }
  pub fn set_enum_field(&mut self, v: Version2Enum_TestEnum) {
    self.enum_field = Some(v);
  }
  pub fn get_enum_field(&self) -> Version2Enum_TestEnum {
    self.enum_field.unwrap_or_default()
  }
}
impl ::std::default::Default for Version2Enum {
  fn default() -> Self {
    Version2Enum {
      enum_field: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version2Enum_default: Version2Enum = Version2Enum::default();
}
impl ::pb_jelly::Message for Version2Enum {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version2Enum",
      full_name: "pbtest.Version2Enum",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "enum_field",
          full_name: "pbtest.Version2Enum.enum_field",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut enum_field_size = 0;
    if let Some(ref val) = self.enum_field {
      let l = ::pb_jelly::Message::compute_size(val);
      enum_field_size += ::pb_jelly::wire_format::serialized_length(1);
      enum_field_size += l;
    }
    size += enum_field_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.enum_field {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, Version2Enum_TestEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version2Enum", 1)?;
          self.enum_field = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version2Enum {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "enum_field" => {
        ::pb_jelly::reflection::FieldMut::Value(self.enum_field.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version1OneOf {
  pub test_oneof: ::std::option::Option<Version1OneOf_TestOneof>,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version1OneOf_TestOneof {
  StringOneOf(::std::string::String),
}
impl Version1OneOf {
}
impl ::std::default::Default for Version1OneOf {
  fn default() -> Self {
    Version1OneOf {
      test_oneof: None,
    }
  }
}
lazy_static! {
  pub static ref Version1OneOf_default: Version1OneOf = Version1OneOf::default();
}
impl ::pb_jelly::Message for Version1OneOf {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version1OneOf",
      full_name: "pbtest.Version1OneOf",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "string_one_of",
          full_name: "pbtest.Version1OneOf.string_one_of",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "test_oneof",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Some(Version1OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(Version1OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version1OneOf", 1)?;
          self.test_oneof = Some(Version1OneOf_TestOneof::StringOneOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version1OneOf {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "test_oneof" => {
        if let Some(Version1OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
          return Some("string_one_of");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "string_one_of" => {
        match self.test_oneof {
          Some(Version1OneOf_TestOneof::StringOneOf(_)) => (),
          _ => {
            self.test_oneof = Some(Version1OneOf_TestOneof::StringOneOf(::std::default::Default::default()));
          },
        }
        if let Some(Version1OneOf_TestOneof::StringOneOf(ref mut val)) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version2OneOf {
  pub test_oneof: ::std::option::Option<Version2OneOf_TestOneof>,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version2OneOf_TestOneof {
  StringOneOf(::std::string::String),
  IntOneOf(i32),
}
impl Version2OneOf {
}
impl ::std::default::Default for Version2OneOf {
  fn default() -> Self {
    Version2OneOf {
      test_oneof: None,
    }
  }
}
lazy_static! {
  pub static ref Version2OneOf_default: Version2OneOf = Version2OneOf::default();
}
impl ::pb_jelly::Message for Version2OneOf {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version2OneOf",
      full_name: "pbtest.Version2OneOf",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "string_one_of",
          full_name: "pbtest.Version2OneOf.string_one_of",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int_one_of",
          full_name: "pbtest.Version2OneOf.int_one_of",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "test_oneof",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Some(Version2OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    let mut int_one_of_size = 0;
    if let Some(Version2OneOf_TestOneof::IntOneOf(ref val)) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      int_one_of_size += ::pb_jelly::wire_format::serialized_length(2);
      int_one_of_size += l;
    }
    size += int_one_of_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(Version2OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(Version2OneOf_TestOneof::IntOneOf(ref val)) = self.test_oneof {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version2OneOf", 1)?;
          self.test_oneof = Some(Version2OneOf_TestOneof::StringOneOf(val));
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version2OneOf", 2)?;
          self.test_oneof = Some(Version2OneOf_TestOneof::IntOneOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version2OneOf {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "test_oneof" => {
        if let Some(Version2OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
          return Some("string_one_of");
        }
        if let Some(Version2OneOf_TestOneof::IntOneOf(ref val)) = self.test_oneof {
          return Some("int_one_of");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "string_one_of" => {
        match self.test_oneof {
          Some(Version2OneOf_TestOneof::StringOneOf(_)) => (),
          _ => {
            self.test_oneof = Some(Version2OneOf_TestOneof::StringOneOf(::std::default::Default::default()));
          },
        }
        if let Some(Version2OneOf_TestOneof::StringOneOf(ref mut val)) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int_one_of" => {
        match self.test_oneof {
          Some(Version2OneOf_TestOneof::IntOneOf(_)) => (),
          _ => {
            self.test_oneof = Some(Version2OneOf_TestOneof::IntOneOf(::std::default::Default::default()));
          },
        }
        if let Some(Version2OneOf_TestOneof::IntOneOf(ref mut val)) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version1 {
  pub required_string: ::std::option::Option<::std::string::String>,
}
impl Version1 {
  pub fn has_required_string(&self) -> bool {
    self.required_string.is_some()
  }
  pub fn set_required_string(&mut self, v: ::std::string::String) {
    self.required_string = Some(v);
  }
  pub fn take_required_string(&mut self) -> ::std::string::String {
    self.required_string.take().unwrap_or_default()
  }
  pub fn get_required_string(&self) -> &str {
    self.required_string.as_deref().unwrap_or("")
  }
}
impl ::std::default::Default for Version1 {
  fn default() -> Self {
    Version1 {
      required_string: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version1_default: Version1 = Version1::default();
}
impl ::pb_jelly::Message for Version1 {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version1",
      full_name: "pbtest.Version1",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "required_string",
          full_name: "pbtest.Version1.required_string",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut required_string_size = 0;
    if let Some(ref val) = self.required_string {
      let l = ::pb_jelly::Message::compute_size(val);
      required_string_size += ::pb_jelly::wire_format::serialized_length(1);
      required_string_size += ::pb_jelly::varint::serialized_length(l as u64);
      required_string_size += l;
    }
    size += required_string_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.required_string {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version1", 1)?;
          self.required_string = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version1 {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "required_string" => {
        ::pb_jelly::reflection::FieldMut::Value(self.required_string.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct Version2 {
  pub required_string: ::std::option::Option<::std::string::String>,
  pub optional_int32: ::std::option::Option<i32>,
  pub optional_int64: ::std::option::Option<i64>,
  pub optional_uint32: ::std::option::Option<u32>,
  pub optional_uint64: ::std::option::Option<u64>,
  pub optional_fixed64: ::std::option::Option<::pb_jelly::Fixed64>,
  pub optional_fixed32: ::std::option::Option<::pb_jelly::Fixed32>,
  pub optional_sfixed64: ::std::option::Option<::pb_jelly::Sfixed64>,
  pub optional_sfixed32: ::std::option::Option<::pb_jelly::Sfixed32>,
  pub optional_double: ::std::option::Option<f64>,
  pub optional_bool: ::std::option::Option<bool>,
  pub optional_string: ::std::option::Option<::std::string::String>,
  pub optional_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
  pub optional_float: ::std::option::Option<f32>,
}
impl Version2 {
  pub fn has_required_string(&self) -> bool {
    self.required_string.is_some()
  }
  pub fn set_required_string(&mut self, v: ::std::string::String) {
    self.required_string = Some(v);
  }
  pub fn take_required_string(&mut self) -> ::std::string::String {
    self.required_string.take().unwrap_or_default()
  }
  pub fn get_required_string(&self) -> &str {
    self.required_string.as_deref().unwrap_or("")
  }
  pub fn has_optional_int32(&self) -> bool {
    self.optional_int32.is_some()
  }
  pub fn set_optional_int32(&mut self, v: i32) {
    self.optional_int32 = Some(v);
  }
  pub fn get_optional_int32(&self) -> i32 {
    self.optional_int32.unwrap_or(0)
  }
  pub fn has_optional_int64(&self) -> bool {
    self.optional_int64.is_some()
  }
  pub fn set_optional_int64(&mut self, v: i64) {
    self.optional_int64 = Some(v);
  }
  pub fn get_optional_int64(&self) -> i64 {
    self.optional_int64.unwrap_or(0)
  }
  pub fn has_optional_uint32(&self) -> bool {
    self.optional_uint32.is_some()
  }
  pub fn set_optional_uint32(&mut self, v: u32) {
    self.optional_uint32 = Some(v);
  }
  pub fn get_optional_uint32(&self) -> u32 {
    self.optional_uint32.unwrap_or(0)
  }
  pub fn has_optional_uint64(&self) -> bool {
    self.optional_uint64.is_some()
  }
  pub fn set_optional_uint64(&mut self, v: u64) {
    self.optional_uint64 = Some(v);
  }
  pub fn get_optional_uint64(&self) -> u64 {
    self.optional_uint64.unwrap_or(0)
  }
  pub fn has_optional_fixed64(&self) -> bool {
    self.optional_fixed64.is_some()
  }
  pub fn set_optional_fixed64(&mut self, v: u64) {
    self.optional_fixed64 = Some(::pb_jelly::Fixed64(v));
  }
  pub fn get_optional_fixed64(&self) -> u64 {
    self.optional_fixed64.map(|v| v.0).unwrap_or(0)
  }
  pub fn has_optional_fixed32(&self) -> bool {
    self.optional_fixed32.is_some()
  }
  pub fn set_optional_fixed32(&mut self, v: u32) {
    self.optional_fixed32 = Some(::pb_jelly::Fixed32(v));
  }
  pub fn get_optional_fixed32(&self) -> u32 {
    self.optional_fixed32.map(|v| v.0).unwrap_or(0)
  }
  pub fn has_optional_sfixed64(&self) -> bool {
    self.optional_sfixed64.is_some()
  }
  pub fn set_optional_sfixed64(&mut self, v: i64) {
    self.optional_sfixed64 = Some(::pb_jelly::Sfixed64(v));
  }
  pub fn get_optional_sfixed64(&self) -> i64 {
    self.optional_sfixed64.map(|v| v.0).unwrap_or(0)
  }
  pub fn has_optional_sfixed32(&self) -> bool {
    self.optional_sfixed32.is_some()
  }
  pub fn set_optional_sfixed32(&mut self, v: i32) {
    self.optional_sfixed32 = Some(::pb_jelly::Sfixed32(v));
  }
  pub fn get_optional_sfixed32(&self) -> i32 {
    self.optional_sfixed32.map(|v| v.0).unwrap_or(0)
  }
  pub fn has_optional_double(&self) -> bool {
    self.optional_double.is_some()
  }
  pub fn set_optional_double(&mut self, v: f64) {
    self.optional_double = Some(v);
  }
  pub fn get_optional_double(&self) -> f64 {
    self.optional_double.unwrap_or(0.)
  }
  pub fn has_optional_bool(&self) -> bool {
    self.optional_bool.is_some()
  }
  pub fn set_optional_bool(&mut self, v: bool) {
    self.optional_bool = Some(v);
  }
  pub fn get_optional_bool(&self) -> bool {
    self.optional_bool.unwrap_or(false)
  }
  pub fn has_optional_string(&self) -> bool {
    self.optional_string.is_some()
  }
  pub fn set_optional_string(&mut self, v: ::std::string::String) {
    self.optional_string = Some(v);
  }
  pub fn take_optional_string(&mut self) -> ::std::string::String {
    self.optional_string.take().unwrap_or_default()
  }
  pub fn get_optional_string(&self) -> &str {
    self.optional_string.as_deref().unwrap_or("")
  }
  pub fn has_optional_bytes(&self) -> bool {
    self.optional_bytes.is_some()
  }
  pub fn set_optional_bytes(&mut self, v: ::std::vec::Vec<u8>) {
    self.optional_bytes = Some(v);
  }
  pub fn take_optional_bytes(&mut self) -> ::std::vec::Vec<u8> {
    self.optional_bytes.take().unwrap_or_default()
  }
  pub fn get_optional_bytes(&self) -> &[u8] {
    self.optional_bytes.as_deref().unwrap_or(&[])
  }
  pub fn has_optional_float(&self) -> bool {
    self.optional_float.is_some()
  }
  pub fn set_optional_float(&mut self, v: f32) {
    self.optional_float = Some(v);
  }
  pub fn get_optional_float(&self) -> f32 {
    self.optional_float.unwrap_or(0.)
  }
}
impl ::std::default::Default for Version2 {
  fn default() -> Self {
    Version2 {
      required_string: ::std::default::Default::default(),
      optional_int32: ::std::default::Default::default(),
      optional_int64: ::std::default::Default::default(),
      optional_uint32: ::std::default::Default::default(),
      optional_uint64: ::std::default::Default::default(),
      optional_fixed64: ::std::default::Default::default(),
      optional_fixed32: ::std::default::Default::default(),
      optional_sfixed64: ::std::default::Default::default(),
      optional_sfixed32: ::std::default::Default::default(),
      optional_double: ::std::default::Default::default(),
      optional_bool: ::std::default::Default::default(),
      optional_string: ::std::default::Default::default(),
      optional_bytes: ::std::default::Default::default(),
      optional_float: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version2_default: Version2 = Version2::default();
}
impl ::pb_jelly::Message for Version2 {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version2",
      full_name: "pbtest.Version2",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "required_string",
          full_name: "pbtest.Version2.required_string",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_int32",
          full_name: "pbtest.Version2.optional_int32",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_int64",
          full_name: "pbtest.Version2.optional_int64",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_uint32",
          full_name: "pbtest.Version2.optional_uint32",
          index: 3,
          number: 4,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_uint64",
          full_name: "pbtest.Version2.optional_uint64",
          index: 4,
          number: 5,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_fixed64",
          full_name: "pbtest.Version2.optional_fixed64",
          index: 5,
          number: 6,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_fixed32",
          full_name: "pbtest.Version2.optional_fixed32",
          index: 6,
          number: 7,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_sfixed64",
          full_name: "pbtest.Version2.optional_sfixed64",
          index: 7,
          number: 8,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_sfixed32",
          full_name: "pbtest.Version2.optional_sfixed32",
          index: 8,
          number: 9,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_double",
          full_name: "pbtest.Version2.optional_double",
          index: 9,
          number: 10,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_bool",
          full_name: "pbtest.Version2.optional_bool",
          index: 10,
          number: 11,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_string",
          full_name: "pbtest.Version2.optional_string",
          index: 11,
          number: 12,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_bytes",
          full_name: "pbtest.Version2.optional_bytes",
          index: 12,
          number: 13,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_float",
          full_name: "pbtest.Version2.optional_float",
          index: 13,
          number: 14,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut required_string_size = 0;
    if let Some(ref val) = self.required_string {
      let l = ::pb_jelly::Message::compute_size(val);
      required_string_size += ::pb_jelly::wire_format::serialized_length(1);
      required_string_size += ::pb_jelly::varint::serialized_length(l as u64);
      required_string_size += l;
    }
    size += required_string_size;
    let mut optional_int32_size = 0;
    if let Some(ref val) = self.optional_int32 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_int32_size += ::pb_jelly::wire_format::serialized_length(2);
      optional_int32_size += l;
    }
    size += optional_int32_size;
    let mut optional_int64_size = 0;
    if let Some(ref val) = self.optional_int64 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_int64_size += ::pb_jelly::wire_format::serialized_length(3);
      optional_int64_size += l;
    }
    size += optional_int64_size;
    let mut optional_uint32_size = 0;
    if let Some(ref val) = self.optional_uint32 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_uint32_size += ::pb_jelly::wire_format::serialized_length(4);
      optional_uint32_size += l;
    }
    size += optional_uint32_size;
    let mut optional_uint64_size = 0;
    if let Some(ref val) = self.optional_uint64 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_uint64_size += ::pb_jelly::wire_format::serialized_length(5);
      optional_uint64_size += l;
    }
    size += optional_uint64_size;
    let mut optional_fixed64_size = 0;
    if let Some(ref val) = self.optional_fixed64 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_fixed64_size += ::pb_jelly::wire_format::serialized_length(6);
      optional_fixed64_size += l;
    }
    size += optional_fixed64_size;
    let mut optional_fixed32_size = 0;
    if let Some(ref val) = self.optional_fixed32 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_fixed32_size += ::pb_jelly::wire_format::serialized_length(7);
      optional_fixed32_size += l;
    }
    size += optional_fixed32_size;
    let mut optional_sfixed64_size = 0;
    if let Some(ref val) = self.optional_sfixed64 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_sfixed64_size += ::pb_jelly::wire_format::serialized_length(8);
      optional_sfixed64_size += l;
    }
    size += optional_sfixed64_size;
    let mut optional_sfixed32_size = 0;
    if let Some(ref val) = self.optional_sfixed32 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_sfixed32_size += ::pb_jelly::wire_format::serialized_length(9);
      optional_sfixed32_size += l;
    }
    size += optional_sfixed32_size;
    let mut optional_double_size = 0;
    if let Some(ref val) = self.optional_double {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_double_size += ::pb_jelly::wire_format::serialized_length(10);
      optional_double_size += l;
    }
    size += optional_double_size;
    let mut optional_bool_size = 0;
    if let Some(ref val) = self.optional_bool {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_bool_size += ::pb_jelly::wire_format::serialized_length(11);
      optional_bool_size += l;
    }
    size += optional_bool_size;
    let mut optional_string_size = 0;
    if let Some(ref val) = self.optional_string {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_string_size += ::pb_jelly::wire_format::serialized_length(12);
      optional_string_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_string_size += l;
    }
    size += optional_string_size;
    let mut optional_bytes_size = 0;
    if let Some(ref val) = self.optional_bytes {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_bytes_size += ::pb_jelly::wire_format::serialized_length(13);
      optional_bytes_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_bytes_size += l;
    }
    size += optional_bytes_size;
    let mut optional_float_size = 0;
    if let Some(ref val) = self.optional_float {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_float_size += ::pb_jelly::wire_format::serialized_length(14);
      optional_float_size += l;
    }
    size += optional_float_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.required_string {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_int32 {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_int64 {
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_uint32 {
      ::pb_jelly::wire_format::write(4, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_uint64 {
      ::pb_jelly::wire_format::write(5, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_fixed64 {
      ::pb_jelly::wire_format::write(6, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_fixed32 {
      ::pb_jelly::wire_format::write(7, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_sfixed64 {
      ::pb_jelly::wire_format::write(8, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_sfixed32 {
      ::pb_jelly::wire_format::write(9, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_double {
      ::pb_jelly::wire_format::write(10, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_bool {
      ::pb_jelly::wire_format::write(11, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_string {
      ::pb_jelly::wire_format::write(12, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_bytes {
      ::pb_jelly::wire_format::write(13, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_float {
      ::pb_jelly::wire_format::write(14, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version2", 1)?;
          self.required_string = Some(val);
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version2", 2)?;
          self.optional_int32 = Some(val);
        }
        3 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version2", 3)?;
          self.optional_int64 = Some(val);
        }
        4 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version2", 4)?;
          self.optional_uint32 = Some(val);
        }
        5 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version2", 5)?;
          self.optional_uint64 = Some(val);
        }
        6 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Fixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "Version2", 6)?;
          self.optional_fixed64 = Some(val);
        }
        7 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Fixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "Version2", 7)?;
          self.optional_fixed32 = Some(val);
        }
        8 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Sfixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "Version2", 8)?;
          self.optional_sfixed64 = Some(val);
        }
        9 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Sfixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "Version2", 9)?;
          self.optional_sfixed32 = Some(val);
        }
        10 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "Version2", 10)?;
          self.optional_double = Some(val);
        }
        11 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, bool>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version2", 11)?;
          self.optional_bool = Some(val);
        }
        12 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version2", 12)?;
          self.optional_string = Some(val);
        }
        13 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::vec::Vec<u8>>(buf, typ, "Version2", 13)?;
          self.optional_bytes = Some(val);
        }
        14 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "Version2", 14)?;
          self.optional_float = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version2 {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "required_string" => {
        ::pb_jelly::reflection::FieldMut::Value(self.required_string.get_or_insert_with(::std::default::Default::default))
      }
      "optional_int32" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_int32.get_or_insert_with(::std::default::Default::default))
      }
      "optional_int64" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_int64.get_or_insert_with(::std::default::Default::default))
      }
      "optional_uint32" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_uint32.get_or_insert_with(::std::default::Default::default))
      }
      "optional_uint64" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_uint64.get_or_insert_with(::std::default::Default::default))
      }
      "optional_fixed64" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_fixed64.get_or_insert_with(::std::default::Default::default))
      }
      "optional_fixed32" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_fixed32.get_or_insert_with(::std::default::Default::default))
      }
      "optional_sfixed64" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_sfixed64.get_or_insert_with(::std::default::Default::default))
      }
      "optional_sfixed32" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_sfixed32.get_or_insert_with(::std::default::Default::default))
      }
      "optional_double" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_double.get_or_insert_with(::std::default::Default::default))
      }
      "optional_bool" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_bool.get_or_insert_with(::std::default::Default::default))
      }
      "optional_string" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_string.get_or_insert_with(::std::default::Default::default))
      }
      "optional_bytes" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_bytes.get_or_insert_with(::std::default::Default::default))
      }
      "optional_float" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_float.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ForeignMessage {
  pub c: ::std::option::Option<i32>,
}
impl ForeignMessage {
  pub fn has_c(&self) -> bool {
    self.c.is_some()
  }
  pub fn set_c(&mut self, v: i32) {
    self.c = Some(v);
  }
  pub fn get_c(&self) -> i32 {
    self.c.unwrap_or(0)
  }
}
impl ::std::default::Default for ForeignMessage {
  fn default() -> Self {
    ForeignMessage {
      c: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref ForeignMessage_default: ForeignMessage = ForeignMessage::default();
}
impl ::pb_jelly::Message for ForeignMessage {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "ForeignMessage",
      full_name: "pbtest.ForeignMessage",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "c",
          full_name: "pbtest.ForeignMessage.c",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut c_size = 0;
    if let Some(ref val) = self.c {
      let l = ::pb_jelly::Message::compute_size(val);
      c_size += ::pb_jelly::wire_format::serialized_length(1);
      c_size += l;
    }
    size += c_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.c {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "ForeignMessage", 1)?;
          self.c = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for ForeignMessage {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "c" => {
        ::pb_jelly::reflection::FieldMut::Value(self.c.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct TestMessage {
  pub optional_int32: ::std::option::Option<i32>,
  pub optional_int64: ::std::option::Option<i64>,
  pub optional_uint32: ::std::option::Option<u32>,
  pub optional_uint64: ::std::option::Option<u64>,
  pub optional_fixed64: ::std::option::Option<::pb_jelly::Fixed64>,
  pub optional_fixed32: ::std::option::Option<::pb_jelly::Fixed32>,
  pub optional_sfixed64: ::std::option::Option<::pb_jelly::Sfixed64>,
  pub optional_sfixed32: ::std::option::Option<::pb_jelly::Sfixed32>,
  pub optional_double: ::std::option::Option<f64>,
  pub optional_bool: ::std::option::Option<bool>,
  pub optional_string: ::std::option::Option<::std::string::String>,
  pub optional_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
  pub optional_float: ::std::option::Option<f32>,
  pub optional_foreign_message: ::std::option::Option<ForeignMessage>,
  pub optional_nested_enum: ::std::option::Option<TestMessage_NestedEnum>,
  pub optional_foreign_enum: ::std::option::Option<ForeignEnum>,
  pub repeated_int32: ::std::vec::Vec<i32>,
  pub repeated_int64: ::std::vec::Vec<i64>,
  pub repeated_uint32: ::std::vec::Vec<u32>,
  pub repeated_uint64: ::std::vec::Vec<u64>,
  pub repeated_fixed64: ::std::vec::Vec<::pb_jelly::Fixed64>,
  pub repeated_fixed32: ::std::vec::Vec<::pb_jelly::Fixed32>,
  pub repeated_sfixed64: ::std::vec::Vec<::pb_jelly::Sfixed64>,
  pub repeated_sfixed32: ::std::vec::Vec<::pb_jelly::Sfixed32>,
  pub repeated_double: ::std::vec::Vec<f64>,
  pub repeated_bool: ::std::vec::Vec<bool>,
  pub repeated_string: ::std::vec::Vec<::std::string::String>,
  pub repeated_bytes: ::std::vec::Vec<::std::vec::Vec<u8>>,
  pub repeated_float: ::std::vec::Vec<f32>,
  pub repeated_foreign_message: ::std::vec::Vec<ForeignMessage>,
  pub repeated_nested_enum: ::std::vec::Vec<TestMessage_NestedEnum>,
  pub repeated_foreign_enum: ::std::vec::Vec<ForeignEnum>,
  pub optional_foreign_message_boxed: ::std::option::Option<::std::boxed::Box<ForeignMessage>>,
  pub optional_foreign_message_nonnullable: ForeignMessage,
  /// Use some rust reserved keywords
  pub r#type: ::std::option::Option<bool>,
  pub oneof_int: ::std::option::Option<TestMessage_OneofInt>,
  pub oneof_foreign: ::std::option::Option<TestMessage_OneofForeign>,
  pub oneof_zero: ::std::option::Option<TestMessage_OneofZero>,
  pub oneof_null: ::std::option::Option<TestMessage_OneofNull>,
  pub oneof_unset: ::std::option::Option<TestMessage_OneofUnset>,
  pub oneof_primitives: ::std::option::Option<TestMessage_OneofPrimitives>,
  pub oneof_empty_field: TestMessage_OneofEmptyField,
  pub r#mod: ::std::option::Option<TestMessage_Mod>,
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage_OneofInt {
  Int1(i32),
  Foreign1(ForeignMessage),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage_OneofForeign {
  Int2(i32),
  Foreign2(ForeignMessage),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage_OneofZero {
  Int3(i32),
  Foreign3(ForeignMessage),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage_OneofNull {
  Int4(i32),
  Foreign4(ForeignMessage),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage_OneofUnset {
  Int5(i32),
  Foreign5(ForeignMessage),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage_OneofPrimitives {
  Int6(i32),
  Bool6(bool),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage_OneofEmptyField {
  A,
  B,
  C(i32),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage_Mod {
  Loop(i32),
  Unsafe(i32),
}
impl TestMessage {
  pub fn has_optional_int32(&self) -> bool {
    self.optional_int32.is_some()
  }
  pub fn set_optional_int32(&mut self, v: i32) {
    self.optional_int32 = Some(v);
  }
  pub fn get_optional_int32(&self) -> i32 {
    self.optional_int32.unwrap_or(0)
  }
  pub fn has_optional_int64(&self) -> bool {
    self.optional_int64.is_some()
  }
  pub fn set_optional_int64(&mut self, v: i64) {
    self.optional_int64 = Some(v);
  }
  pub fn get_optional_int64(&self) -> i64 {
    self.optional_int64.unwrap_or(0)
  }
  pub fn has_optional_uint32(&self) -> bool {
    self.optional_uint32.is_some()
  }
  pub fn set_optional_uint32(&mut self, v: u32) {
    self.optional_uint32 = Some(v);
  }
  pub fn get_optional_uint32(&self) -> u32 {
    self.optional_uint32.unwrap_or(0)
  }
  pub fn has_optional_uint64(&self) -> bool {
    self.optional_uint64.is_some()
  }
  pub fn set_optional_uint64(&mut self, v: u64) {
    self.optional_uint64 = Some(v);
  }
  pub fn get_optional_uint64(&self) -> u64 {
    self.optional_uint64.unwrap_or(0)
  }
  pub fn has_optional_fixed64(&self) -> bool {
    self.optional_fixed64.is_some()
  }
  pub fn set_optional_fixed64(&mut self, v: u64) {
    self.optional_fixed64 = Some(::pb_jelly::Fixed64(v));
  }
  pub fn get_optional_fixed64(&self) -> u64 {
    self.optional_fixed64.map(|v| v.0).unwrap_or(0)
  }
  pub fn has_optional_fixed32(&self) -> bool {
    self.optional_fixed32.is_some()
  }
  pub fn set_optional_fixed32(&mut self, v: u32) {
    self.optional_fixed32 = Some(::pb_jelly::Fixed32(v));
  }
  pub fn get_optional_fixed32(&self) -> u32 {
    self.optional_fixed32.map(|v| v.0).unwrap_or(0)
  }
  pub fn has_optional_sfixed64(&self) -> bool {
    self.optional_sfixed64.is_some()
  }
  pub fn set_optional_sfixed64(&mut self, v: i64) {
    self.optional_sfixed64 = Some(::pb_jelly::Sfixed64(v));
  }
  pub fn get_optional_sfixed64(&self) -> i64 {
    self.optional_sfixed64.map(|v| v.0).unwrap_or(0)
  }
  pub fn has_optional_sfixed32(&self) -> bool {
    self.optional_sfixed32.is_some()
  }
  pub fn set_optional_sfixed32(&mut self, v: i32) {
    self.optional_sfixed32 = Some(::pb_jelly::Sfixed32(v));
  }
  pub fn get_optional_sfixed32(&self) -> i32 {
    self.optional_sfixed32.map(|v| v.0).unwrap_or(0)
  }
  pub fn has_optional_double(&self) -> bool {
    self.optional_double.is_some()
  }
  pub fn set_optional_double(&mut self, v: f64) {
    self.optional_double = Some(v);
  }
  pub fn get_optional_double(&self) -> f64 {
    self.optional_double.unwrap_or(0.)
  }
  pub fn has_optional_bool(&self) -> bool {
    self.optional_bool.is_some()
  }
  pub fn set_optional_bool(&mut self, v: bool) {
    self.optional_bool = Some(v);
  }
  pub fn get_optional_bool(&self) -> bool {
    self.optional_bool.unwrap_or(false)
  }
  pub fn has_optional_string(&self) -> bool {
    self.optional_string.is_some()
  }
  pub fn set_optional_string(&mut self, v: ::std::string::String) {
    self.optional_string = Some(v);
  }
  pub fn take_optional_string(&mut self) -> ::std::string::String {
    self.optional_string.take().unwrap_or_default()
  }
  pub fn get_optional_string(&self) -> &str {
    self.optional_string.as_deref().unwrap_or("")
  }
  pub fn has_optional_bytes(&self) -> bool {
    self.optional_bytes.is_some()
  }
  pub fn set_optional_bytes(&mut self, v: ::std::vec::Vec<u8>) {
    self.optional_bytes = Some(v);
  }
  pub fn take_optional_bytes(&mut self) -> ::std::vec::Vec<u8> {
    self.optional_bytes.take().unwrap_or_default()
  }
  pub fn get_optional_bytes(&self) -> &[u8] {
    self.optional_bytes.as_deref().unwrap_or(&[])
  }
  pub fn has_optional_float(&self) -> bool {
    self.optional_float.is_some()
  }
  pub fn set_optional_float(&mut self, v: f32) {
    self.optional_float = Some(v);
  }
  pub fn get_optional_float(&self) -> f32 {
    self.optional_float.unwrap_or(0.)
  }
  pub fn has_optional_foreign_message(&self) -> bool {
    self.optional_foreign_message.is_some()
  }
  pub fn set_optional_foreign_message(&mut self, v: ForeignMessage) {
    self.optional_foreign_message = Some(v);
  }
  pub fn take_optional_foreign_message(&mut self) -> ForeignMessage {
    self.optional_foreign_message.take().unwrap_or_default()
  }
  pub fn get_optional_foreign_message(&self) -> &ForeignMessage {
    self.optional_foreign_message.as_ref().unwrap_or(&ForeignMessage_default)
  }
  pub fn has_optional_nested_enum(&self) -> bool {
    self.optional_nested_enum.is_some()
  }
  pub fn set_optional_nested_enum(&mut self, v: TestMessage_NestedEnum) {
    self.optional_nested_enum = Some(v);
  }
  pub fn get_optional_nested_enum(&self) -> TestMessage_NestedEnum {
    self.optional_nested_enum.unwrap_or_default()
  }
  pub fn has_optional_foreign_enum(&self) -> bool {
    self.optional_foreign_enum.is_some()
  }
  pub fn set_optional_foreign_enum(&mut self, v: ForeignEnum) {
    self.optional_foreign_enum = Some(v);
  }
  pub fn get_optional_foreign_enum(&self) -> ForeignEnum {
    self.optional_foreign_enum.unwrap_or_default()
  }
  pub fn set_repeated_int32(&mut self, v: ::std::vec::Vec<i32>) {
    self.repeated_int32 = v;
  }
  pub fn take_repeated_int32(&mut self) -> ::std::vec::Vec<i32> {
    ::std::mem::take(&mut self.repeated_int32)
  }
  pub fn get_repeated_int32(&self) -> &[i32] {
    &self.repeated_int32
  }
  pub fn mut_repeated_int32(&mut self) -> &mut ::std::vec::Vec<i32> {
    &mut self.repeated_int32
  }
  pub fn set_repeated_int64(&mut self, v: ::std::vec::Vec<i64>) {
    self.repeated_int64 = v;
  }
  pub fn take_repeated_int64(&mut self) -> ::std::vec::Vec<i64> {
    ::std::mem::take(&mut self.repeated_int64)
  }
  pub fn get_repeated_int64(&self) -> &[i64] {
    &self.repeated_int64
  }
  pub fn mut_repeated_int64(&mut self) -> &mut ::std::vec::Vec<i64> {
    &mut self.repeated_int64
  }
  pub fn set_repeated_uint32(&mut self, v: ::std::vec::Vec<u32>) {
    self.repeated_uint32 = v;
  }
  pub fn take_repeated_uint32(&mut self) -> ::std::vec::Vec<u32> {
    ::std::mem::take(&mut self.repeated_uint32)
  }
  pub fn get_repeated_uint32(&self) -> &[u32] {
    &self.repeated_uint32
  }
  pub fn mut_repeated_uint32(&mut self) -> &mut ::std::vec::Vec<u32> {
    &mut self.repeated_uint32
  }
  pub fn set_repeated_uint64(&mut self, v: ::std::vec::Vec<u64>) {
    self.repeated_uint64 = v;
  }
  pub fn take_repeated_uint64(&mut self) -> ::std::vec::Vec<u64> {
    ::std::mem::take(&mut self.repeated_uint64)
  }
  pub fn get_repeated_uint64(&self) -> &[u64] {
    &self.repeated_uint64
  }
  pub fn mut_repeated_uint64(&mut self) -> &mut ::std::vec::Vec<u64> {
    &mut self.repeated_uint64
  }
  pub fn set_repeated_fixed64(&mut self, v: ::std::vec::Vec<::pb_jelly::Fixed64>) {
    self.repeated_fixed64 = v;
  }
  pub fn take_repeated_fixed64(&mut self) -> ::std::vec::Vec<::pb_jelly::Fixed64> {
    ::std::mem::take(&mut self.repeated_fixed64)
  }
  pub fn get_repeated_fixed64(&self) -> &[::pb_jelly::Fixed64] {
    &self.repeated_fixed64
  }
  pub fn mut_repeated_fixed64(&mut self) -> &mut ::std::vec::Vec<::pb_jelly::Fixed64> {
    &mut self.repeated_fixed64
  }
  pub fn set_repeated_fixed32(&mut self, v: ::std::vec::Vec<::pb_jelly::Fixed32>) {
    self.repeated_fixed32 = v;
  }
  pub fn take_repeated_fixed32(&mut self) -> ::std::vec::Vec<::pb_jelly::Fixed32> {
    ::std::mem::take(&mut self.repeated_fixed32)
  }
  pub fn get_repeated_fixed32(&self) -> &[::pb_jelly::Fixed32] {
    &self.repeated_fixed32
  }
  pub fn mut_repeated_fixed32(&mut self) -> &mut ::std::vec::Vec<::pb_jelly::Fixed32> {
    &mut self.repeated_fixed32
  }
  pub fn set_repeated_sfixed64(&mut self, v: ::std::vec::Vec<::pb_jelly::Sfixed64>) {
    self.repeated_sfixed64 = v;
  }
  pub fn take_repeated_sfixed64(&mut self) -> ::std::vec::Vec<::pb_jelly::Sfixed64> {
    ::std::mem::take(&mut self.repeated_sfixed64)
  }
  pub fn get_repeated_sfixed64(&self) -> &[::pb_jelly::Sfixed64] {
    &self.repeated_sfixed64
  }
  pub fn mut_repeated_sfixed64(&mut self) -> &mut ::std::vec::Vec<::pb_jelly::Sfixed64> {
    &mut self.repeated_sfixed64
  }
  pub fn set_repeated_sfixed32(&mut self, v: ::std::vec::Vec<::pb_jelly::Sfixed32>) {
    self.repeated_sfixed32 = v;
  }
  pub fn take_repeated_sfixed32(&mut self) -> ::std::vec::Vec<::pb_jelly::Sfixed32> {
    ::std::mem::take(&mut self.repeated_sfixed32)
  }
  pub fn get_repeated_sfixed32(&self) -> &[::pb_jelly::Sfixed32] {
    &self.repeated_sfixed32
  }
  pub fn mut_repeated_sfixed32(&mut self) -> &mut ::std::vec::Vec<::pb_jelly::Sfixed32> {
    &mut self.repeated_sfixed32
  }
  pub fn set_repeated_double(&mut self, v: ::std::vec::Vec<f64>) {
    self.repeated_double = v;
  }
  pub fn take_repeated_double(&mut self) -> ::std::vec::Vec<f64> {
    ::std::mem::take(&mut self.repeated_double)
  }
  pub fn get_repeated_double(&self) -> &[f64] {
    &self.repeated_double
  }
  pub fn mut_repeated_double(&mut self) -> &mut ::std::vec::Vec<f64> {
    &mut self.repeated_double
  }
  pub fn set_repeated_bool(&mut self, v: ::std::vec::Vec<bool>) {
    self.repeated_bool = v;
  }
  pub fn take_repeated_bool(&mut self) -> ::std::vec::Vec<bool> {
    ::std::mem::take(&mut self.repeated_bool)
  }
  pub fn get_repeated_bool(&self) -> &[bool] {
    &self.repeated_bool
  }
  pub fn mut_repeated_bool(&mut self) -> &mut ::std::vec::Vec<bool> {
    &mut self.repeated_bool
  }
  pub fn set_repeated_string(&mut self, v: ::std::vec::Vec<::std::string::String>) {
    self.repeated_string = v;
  }
  pub fn take_repeated_string(&mut self) -> ::std::vec::Vec<::std::string::String> {
    ::std::mem::take(&mut self.repeated_string)
  }
  pub fn get_repeated_string(&self) -> &[::std::string::String] {
    &self.repeated_string
  }
  pub fn mut_repeated_string(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
    &mut self.repeated_string
  }
  pub fn set_repeated_bytes(&mut self, v: ::std::vec::Vec<::std::vec::Vec<u8>>) {
    self.repeated_bytes = v;
  }
  pub fn take_repeated_bytes(&mut self) -> ::std::vec::Vec<::std::vec::Vec<u8>> {
    ::std::mem::take(&mut self.repeated_bytes)
  }
  pub fn get_repeated_bytes(&self) -> &[::std::vec::Vec<u8>] {
    &self.repeated_bytes
  }
  pub fn mut_repeated_bytes(&mut self) -> &mut ::std::vec::Vec<::std::vec::Vec<u8>> {
    &mut self.repeated_bytes
  }
  pub fn set_repeated_float(&mut self, v: ::std::vec::Vec<f32>) {
    self.repeated_float = v;
  }
  pub fn take_repeated_float(&mut self) -> ::std::vec::Vec<f32> {
    ::std::mem::take(&mut self.repeated_float)
  }
  pub fn get_repeated_float(&self) -> &[f32] {
    &self.repeated_float
  }
  pub fn mut_repeated_float(&mut self) -> &mut ::std::vec::Vec<f32> {
    &mut self.repeated_float
  }
  pub fn set_repeated_foreign_message(&mut self, v: ::std::vec::Vec<ForeignMessage>) {
    self.repeated_foreign_message = v;
  }
  pub fn take_repeated_foreign_message(&mut self) -> ::std::vec::Vec<ForeignMessage> {
    ::std::mem::take(&mut self.repeated_foreign_message)
  }
  pub fn get_repeated_foreign_message(&self) -> &[ForeignMessage] {
    &self.repeated_foreign_message
  }
  pub fn mut_repeated_foreign_message(&mut self) -> &mut ::std::vec::Vec<ForeignMessage> {
    &mut self.repeated_foreign_message
  }
  pub fn set_repeated_nested_enum(&mut self, v: ::std::vec::Vec<TestMessage_NestedEnum>) {
    self.repeated_nested_enum = v;
  }
  pub fn take_repeated_nested_enum(&mut self) -> ::std::vec::Vec<TestMessage_NestedEnum> {
    ::std::mem::take(&mut self.repeated_nested_enum)
  }
  pub fn get_repeated_nested_enum(&self) -> &[TestMessage_NestedEnum] {
    &self.repeated_nested_enum
  }
  pub fn mut_repeated_nested_enum(&mut self) -> &mut ::std::vec::Vec<TestMessage_NestedEnum> {
    &mut self.repeated_nested_enum
  }
  pub fn set_repeated_foreign_enum(&mut self, v: ::std::vec::Vec<ForeignEnum>) {
    self.repeated_foreign_enum = v;
  }
  pub fn take_repeated_foreign_enum(&mut self) -> ::std::vec::Vec<ForeignEnum> {
    ::std::mem::take(&mut self.repeated_foreign_enum)
  }
  pub fn get_repeated_foreign_enum(&self) -> &[ForeignEnum] {
    &self.repeated_foreign_enum
  }
  pub fn mut_repeated_foreign_enum(&mut self) -> &mut ::std::vec::Vec<ForeignEnum> {
    &mut self.repeated_foreign_enum
  }
  pub fn has_optional_foreign_message_boxed(&self) -> bool {
    self.optional_foreign_message_boxed.is_some()
  }
  pub fn set_optional_foreign_message_boxed(&mut self, v: ::std::boxed::Box<ForeignMessage>) {
    self.optional_foreign_message_boxed = Some(v);
  }
  pub fn take_optional_foreign_message_boxed(&mut self) -> ::std::boxed::Box<ForeignMessage> {
    self.optional_foreign_message_boxed.take().unwrap_or_default()
  }
  pub fn get_optional_foreign_message_boxed(&self) -> &ForeignMessage {
    self.optional_foreign_message_boxed.as_ref().map(::std::ops::Deref::deref).unwrap_or(&ForeignMessage_default)
  }
  pub fn has_type(&self) -> bool {
    self.r#type.is_some()
  }
  pub fn set_type(&mut self, v: bool) {
    self.r#type = Some(v);
  }
  pub fn get_type(&self) -> bool {
    self.r#type.unwrap_or(false)
  }
}
impl ::std::default::Default for TestMessage {
  fn default() -> Self {
    TestMessage {
      optional_int32: ::std::default::Default::default(),
      optional_int64: ::std::default::Default::default(),
      optional_uint32: ::std::default::Default::default(),
      optional_uint64: ::std::default::Default::default(),
      optional_fixed64: ::std::default::Default::default(),
      optional_fixed32: ::std::default::Default::default(),
      optional_sfixed64: ::std::default::Default::default(),
      optional_sfixed32: ::std::default::Default::default(),
      optional_double: ::std::default::Default::default(),
      optional_bool: ::std::default::Default::default(),
      optional_string: ::std::default::Default::default(),
      optional_bytes: ::std::default::Default::default(),
      optional_float: ::std::default::Default::default(),
      optional_foreign_message: ::std::default::Default::default(),
      optional_nested_enum: ::std::default::Default::default(),
      optional_foreign_enum: ::std::default::Default::default(),
      repeated_int32: ::std::default::Default::default(),
      repeated_int64: ::std::default::Default::default(),
      repeated_uint32: ::std::default::Default::default(),
      repeated_uint64: ::std::default::Default::default(),
      repeated_fixed64: ::std::default::Default::default(),
      repeated_fixed32: ::std::default::Default::default(),
      repeated_sfixed64: ::std::default::Default::default(),
      repeated_sfixed32: ::std::default::Default::default(),
      repeated_double: ::std::default::Default::default(),
      repeated_bool: ::std::default::Default::default(),
      repeated_string: ::std::default::Default::default(),
      repeated_bytes: ::std::default::Default::default(),
      repeated_float: ::std::default::Default::default(),
      repeated_foreign_message: ::std::default::Default::default(),
      repeated_nested_enum: ::std::default::Default::default(),
      repeated_foreign_enum: ::std::default::Default::default(),
      optional_foreign_message_boxed: ::std::default::Default::default(),
      optional_foreign_message_nonnullable: ::std::default::Default::default(),
      r#type: ::std::default::Default::default(),
      oneof_int: None,
      oneof_foreign: None,
      oneof_zero: None,
      oneof_null: None,
      oneof_unset: None,
      oneof_primitives: None,
      oneof_empty_field: TestMessage_OneofEmptyField::A,
      r#mod: None,
    }
  }
}
lazy_static! {
  pub static ref TestMessage_default: TestMessage = TestMessage::default();
}
impl ::pb_jelly::Message for TestMessage {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage",
      full_name: "pbtest.TestMessage",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "optional_int32",
          full_name: "pbtest.TestMessage.optional_int32",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_int64",
          full_name: "pbtest.TestMessage.optional_int64",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_uint32",
          full_name: "pbtest.TestMessage.optional_uint32",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_uint64",
          full_name: "pbtest.TestMessage.optional_uint64",
          index: 3,
          number: 4,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_fixed64",
          full_name: "pbtest.TestMessage.optional_fixed64",
          index: 4,
          number: 8,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_fixed32",
          full_name: "pbtest.TestMessage.optional_fixed32",
          index: 5,
          number: 9,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_sfixed64",
          full_name: "pbtest.TestMessage.optional_sfixed64",
          index: 6,
          number: 10,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_sfixed32",
          full_name: "pbtest.TestMessage.optional_sfixed32",
          index: 7,
          number: 11,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_double",
          full_name: "pbtest.TestMessage.optional_double",
          index: 8,
          number: 12,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_bool",
          full_name: "pbtest.TestMessage.optional_bool",
          index: 9,
          number: 13,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_string",
          full_name: "pbtest.TestMessage.optional_string",
          index: 10,
          number: 14,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_bytes",
          full_name: "pbtest.TestMessage.optional_bytes",
          index: 11,
          number: 15,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_float",
          full_name: "pbtest.TestMessage.optional_float",
          index: 12,
          number: 16,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_foreign_message",
          full_name: "pbtest.TestMessage.optional_foreign_message",
          index: 13,
          number: 19,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_nested_enum",
          full_name: "pbtest.TestMessage.optional_nested_enum",
          index: 14,
          number: 21,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_foreign_enum",
          full_name: "pbtest.TestMessage.optional_foreign_enum",
          index: 15,
          number: 22,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_int32",
          full_name: "pbtest.TestMessage.repeated_int32",
          index: 16,
          number: 31,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_int64",
          full_name: "pbtest.TestMessage.repeated_int64",
          index: 17,
          number: 32,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_uint32",
          full_name: "pbtest.TestMessage.repeated_uint32",
          index: 18,
          number: 33,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_uint64",
          full_name: "pbtest.TestMessage.repeated_uint64",
          index: 19,
          number: 34,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_fixed64",
          full_name: "pbtest.TestMessage.repeated_fixed64",
          index: 20,
          number: 38,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_fixed32",
          full_name: "pbtest.TestMessage.repeated_fixed32",
          index: 21,
          number: 39,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_sfixed64",
          full_name: "pbtest.TestMessage.repeated_sfixed64",
          index: 22,
          number: 40,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_sfixed32",
          full_name: "pbtest.TestMessage.repeated_sfixed32",
          index: 23,
          number: 41,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_double",
          full_name: "pbtest.TestMessage.repeated_double",
          index: 24,
          number: 42,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_bool",
          full_name: "pbtest.TestMessage.repeated_bool",
          index: 25,
          number: 43,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_string",
          full_name: "pbtest.TestMessage.repeated_string",
          index: 26,
          number: 44,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_bytes",
          full_name: "pbtest.TestMessage.repeated_bytes",
          index: 27,
          number: 45,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_float",
          full_name: "pbtest.TestMessage.repeated_float",
          index: 28,
          number: 46,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_foreign_message",
          full_name: "pbtest.TestMessage.repeated_foreign_message",
          index: 29,
          number: 49,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_nested_enum",
          full_name: "pbtest.TestMessage.repeated_nested_enum",
          index: 30,
          number: 51,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_foreign_enum",
          full_name: "pbtest.TestMessage.repeated_foreign_enum",
          index: 31,
          number: 52,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_foreign_message_boxed",
          full_name: "pbtest.TestMessage.optional_foreign_message_boxed",
          index: 32,
          number: 53,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_foreign_message_nonnullable",
          full_name: "pbtest.TestMessage.optional_foreign_message_nonnullable",
          index: 33,
          number: 54,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "int1",
          full_name: "pbtest.TestMessage.int1",
          index: 34,
          number: 57,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "foreign1",
          full_name: "pbtest.TestMessage.foreign1",
          index: 35,
          number: 58,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int2",
          full_name: "pbtest.TestMessage.int2",
          index: 36,
          number: 59,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(1),
        },
        ::pb_jelly::FieldDescriptor {
          name: "foreign2",
          full_name: "pbtest.TestMessage.foreign2",
          index: 37,
          number: 60,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(1),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int3",
          full_name: "pbtest.TestMessage.int3",
          index: 38,
          number: 61,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(2),
        },
        ::pb_jelly::FieldDescriptor {
          name: "foreign3",
          full_name: "pbtest.TestMessage.foreign3",
          index: 39,
          number: 62,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(2),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int4",
          full_name: "pbtest.TestMessage.int4",
          index: 40,
          number: 63,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(3),
        },
        ::pb_jelly::FieldDescriptor {
          name: "foreign4",
          full_name: "pbtest.TestMessage.foreign4",
          index: 41,
          number: 64,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(3),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int5",
          full_name: "pbtest.TestMessage.int5",
          index: 42,
          number: 65,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(4),
        },
        ::pb_jelly::FieldDescriptor {
          name: "foreign5",
          full_name: "pbtest.TestMessage.foreign5",
          index: 43,
          number: 66,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(4),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int6",
          full_name: "pbtest.TestMessage.int6",
          index: 44,
          number: 67,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(5),
        },
        ::pb_jelly::FieldDescriptor {
          name: "bool6",
          full_name: "pbtest.TestMessage.bool6",
          index: 45,
          number: 68,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(5),
        },
        ::pb_jelly::FieldDescriptor {
          name: "a",
          full_name: "pbtest.TestMessage.a",
          index: 46,
          number: 70,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(6),
        },
        ::pb_jelly::FieldDescriptor {
          name: "b",
          full_name: "pbtest.TestMessage.b",
          index: 47,
          number: 71,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(6),
        },
        ::pb_jelly::FieldDescriptor {
          name: "c",
          full_name: "pbtest.TestMessage.c",
          index: 48,
          number: 72,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(6),
        },
        ::pb_jelly::FieldDescriptor {
          name: "type",
          full_name: "pbtest.TestMessage.type",
          index: 49,
          number: 73,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "loop",
          full_name: "pbtest.TestMessage.loop",
          index: 50,
          number: 74,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(7),
        },
        ::pb_jelly::FieldDescriptor {
          name: "unsafe",
          full_name: "pbtest.TestMessage.unsafe",
          index: 51,
          number: 75,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(7),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "oneof_int",
        },
        ::pb_jelly::OneofDescriptor {
          name: "oneof_foreign",
        },
        ::pb_jelly::OneofDescriptor {
          name: "oneof_zero",
        },
        ::pb_jelly::OneofDescriptor {
          name: "oneof_null",
        },
        ::pb_jelly::OneofDescriptor {
          name: "oneof_unset",
        },
        ::pb_jelly::OneofDescriptor {
          name: "oneof_primitives",
        },
        ::pb_jelly::OneofDescriptor {
          name: "oneof_empty_field",
        },
        ::pb_jelly::OneofDescriptor {
          name: "mod",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut optional_int32_size = 0;
    if let Some(ref val) = self.optional_int32 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_int32_size += ::pb_jelly::wire_format::serialized_length(1);
      optional_int32_size += l;
    }
    size += optional_int32_size;
    let mut optional_int64_size = 0;
    if let Some(ref val) = self.optional_int64 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_int64_size += ::pb_jelly::wire_format::serialized_length(2);
      optional_int64_size += l;
    }
    size += optional_int64_size;
    let mut optional_uint32_size = 0;
    if let Some(ref val) = self.optional_uint32 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_uint32_size += ::pb_jelly::wire_format::serialized_length(3);
      optional_uint32_size += l;
    }
    size += optional_uint32_size;
    let mut optional_uint64_size = 0;
    if let Some(ref val) = self.optional_uint64 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_uint64_size += ::pb_jelly::wire_format::serialized_length(4);
      optional_uint64_size += l;
    }
    size += optional_uint64_size;
    let mut optional_fixed64_size = 0;
    if let Some(ref val) = self.optional_fixed64 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_fixed64_size += ::pb_jelly::wire_format::serialized_length(8);
      optional_fixed64_size += l;
    }
    size += optional_fixed64_size;
    let mut optional_fixed32_size = 0;
    if let Some(ref val) = self.optional_fixed32 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_fixed32_size += ::pb_jelly::wire_format::serialized_length(9);
      optional_fixed32_size += l;
    }
    size += optional_fixed32_size;
    let mut optional_sfixed64_size = 0;
    if let Some(ref val) = self.optional_sfixed64 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_sfixed64_size += ::pb_jelly::wire_format::serialized_length(10);
      optional_sfixed64_size += l;
    }
    size += optional_sfixed64_size;
    let mut optional_sfixed32_size = 0;
    if let Some(ref val) = self.optional_sfixed32 {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_sfixed32_size += ::pb_jelly::wire_format::serialized_length(11);
      optional_sfixed32_size += l;
    }
    size += optional_sfixed32_size;
    let mut optional_double_size = 0;
    if let Some(ref val) = self.optional_double {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_double_size += ::pb_jelly::wire_format::serialized_length(12);
      optional_double_size += l;
    }
    size += optional_double_size;
    let mut optional_bool_size = 0;
    if let Some(ref val) = self.optional_bool {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_bool_size += ::pb_jelly::wire_format::serialized_length(13);
      optional_bool_size += l;
    }
    size += optional_bool_size;
    let mut optional_string_size = 0;
    if let Some(ref val) = self.optional_string {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_string_size += ::pb_jelly::wire_format::serialized_length(14);
      optional_string_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_string_size += l;
    }
    size += optional_string_size;
    let mut optional_bytes_size = 0;
    if let Some(ref val) = self.optional_bytes {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_bytes_size += ::pb_jelly::wire_format::serialized_length(15);
      optional_bytes_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_bytes_size += l;
    }
    size += optional_bytes_size;
    let mut optional_float_size = 0;
    if let Some(ref val) = self.optional_float {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_float_size += ::pb_jelly::wire_format::serialized_length(16);
      optional_float_size += l;
    }
    size += optional_float_size;
    let mut optional_foreign_message_size = 0;
    if let Some(ref val) = self.optional_foreign_message {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_foreign_message_size += ::pb_jelly::wire_format::serialized_length(19);
      optional_foreign_message_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_foreign_message_size += l;
    }
    size += optional_foreign_message_size;
    let mut optional_nested_enum_size = 0;
    if let Some(ref val) = self.optional_nested_enum {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_nested_enum_size += ::pb_jelly::wire_format::serialized_length(21);
      optional_nested_enum_size += l;
    }
    size += optional_nested_enum_size;
    let mut optional_foreign_enum_size = 0;
    if let Some(ref val) = self.optional_foreign_enum {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_foreign_enum_size += ::pb_jelly::wire_format::serialized_length(22);
      optional_foreign_enum_size += l;
    }
    size += optional_foreign_enum_size;
    let mut repeated_int32_size = 0;
    for val in &self.repeated_int32 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_int32_size += ::pb_jelly::wire_format::serialized_length(31);
      repeated_int32_size += l;
    }
    size += repeated_int32_size;
    let mut repeated_int64_size = 0;
    for val in &self.repeated_int64 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_int64_size += ::pb_jelly::wire_format::serialized_length(32);
      repeated_int64_size += l;
    }
    size += repeated_int64_size;
    let mut repeated_uint32_size = 0;
    for val in &self.repeated_uint32 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_uint32_size += ::pb_jelly::wire_format::serialized_length(33);
      repeated_uint32_size += l;
    }
    size += repeated_uint32_size;
    let mut repeated_uint64_size = 0;
    for val in &self.repeated_uint64 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_uint64_size += ::pb_jelly::wire_format::serialized_length(34);
      repeated_uint64_size += l;
    }
    size += repeated_uint64_size;
    let mut repeated_fixed64_size = 0;
    for val in &self.repeated_fixed64 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_fixed64_size += ::pb_jelly::wire_format::serialized_length(38);
      repeated_fixed64_size += l;
    }
    size += repeated_fixed64_size;
    let mut repeated_fixed32_size = 0;
    for val in &self.repeated_fixed32 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_fixed32_size += ::pb_jelly::wire_format::serialized_length(39);
      repeated_fixed32_size += l;
    }
    size += repeated_fixed32_size;
    let mut repeated_sfixed64_size = 0;
    for val in &self.repeated_sfixed64 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_sfixed64_size += ::pb_jelly::wire_format::serialized_length(40);
      repeated_sfixed64_size += l;
    }
    size += repeated_sfixed64_size;
    let mut repeated_sfixed32_size = 0;
    for val in &self.repeated_sfixed32 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_sfixed32_size += ::pb_jelly::wire_format::serialized_length(41);
      repeated_sfixed32_size += l;
    }
    size += repeated_sfixed32_size;
    let mut repeated_double_size = 0;
    for val in &self.repeated_double {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_double_size += ::pb_jelly::wire_format::serialized_length(42);
      repeated_double_size += l;
    }
    size += repeated_double_size;
    let mut repeated_bool_size = 0;
    for val in &self.repeated_bool {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_bool_size += ::pb_jelly::wire_format::serialized_length(43);
      repeated_bool_size += l;
    }
    size += repeated_bool_size;
    let mut repeated_string_size = 0;
    for val in &self.repeated_string {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_string_size += ::pb_jelly::wire_format::serialized_length(44);
      repeated_string_size += ::pb_jelly::varint::serialized_length(l as u64);
      repeated_string_size += l;
    }
    size += repeated_string_size;
    let mut repeated_bytes_size = 0;
    for val in &self.repeated_bytes {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_bytes_size += ::pb_jelly::wire_format::serialized_length(45);
      repeated_bytes_size += ::pb_jelly::varint::serialized_length(l as u64);
      repeated_bytes_size += l;
    }
    size += repeated_bytes_size;
    let mut repeated_float_size = 0;
    for val in &self.repeated_float {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_float_size += ::pb_jelly::wire_format::serialized_length(46);
      repeated_float_size += l;
    }
    size += repeated_float_size;
    let mut repeated_foreign_message_size = 0;
    for val in &self.repeated_foreign_message {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_foreign_message_size += ::pb_jelly::wire_format::serialized_length(49);
      repeated_foreign_message_size += ::pb_jelly::varint::serialized_length(l as u64);
      repeated_foreign_message_size += l;
    }
    size += repeated_foreign_message_size;
    let mut repeated_nested_enum_size = 0;
    for val in &self.repeated_nested_enum {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_nested_enum_size += ::pb_jelly::wire_format::serialized_length(51);
      repeated_nested_enum_size += l;
    }
    size += repeated_nested_enum_size;
    let mut repeated_foreign_enum_size = 0;
    for val in &self.repeated_foreign_enum {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_foreign_enum_size += ::pb_jelly::wire_format::serialized_length(52);
      repeated_foreign_enum_size += l;
    }
    size += repeated_foreign_enum_size;
    let mut optional_foreign_message_boxed_size = 0;
    if let Some(ref val) = self.optional_foreign_message_boxed {
      let val = &**val;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_foreign_message_boxed_size += ::pb_jelly::wire_format::serialized_length(53);
      optional_foreign_message_boxed_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_foreign_message_boxed_size += l;
    }
    size += optional_foreign_message_boxed_size;
    let mut optional_foreign_message_nonnullable_size = 0;
     {
      let val = &self.optional_foreign_message_nonnullable;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_foreign_message_nonnullable_size += ::pb_jelly::wire_format::serialized_length(54);
      optional_foreign_message_nonnullable_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_foreign_message_nonnullable_size += l;
    }
    size += optional_foreign_message_nonnullable_size;
    let mut int1_size = 0;
    if let Some(TestMessage_OneofInt::Int1(ref val)) = self.oneof_int {
      let l = ::pb_jelly::Message::compute_size(val);
      int1_size += ::pb_jelly::wire_format::serialized_length(57);
      int1_size += l;
    }
    size += int1_size;
    let mut foreign1_size = 0;
    if let Some(TestMessage_OneofInt::Foreign1(ref val)) = self.oneof_int {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign1_size += ::pb_jelly::wire_format::serialized_length(58);
      foreign1_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign1_size += l;
    }
    size += foreign1_size;
    let mut int2_size = 0;
    if let Some(TestMessage_OneofForeign::Int2(ref val)) = self.oneof_foreign {
      let l = ::pb_jelly::Message::compute_size(val);
      int2_size += ::pb_jelly::wire_format::serialized_length(59);
      int2_size += l;
    }
    size += int2_size;
    let mut foreign2_size = 0;
    if let Some(TestMessage_OneofForeign::Foreign2(ref val)) = self.oneof_foreign {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign2_size += ::pb_jelly::wire_format::serialized_length(60);
      foreign2_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign2_size += l;
    }
    size += foreign2_size;
    let mut int3_size = 0;
    if let Some(TestMessage_OneofZero::Int3(ref val)) = self.oneof_zero {
      let l = ::pb_jelly::Message::compute_size(val);
      int3_size += ::pb_jelly::wire_format::serialized_length(61);
      int3_size += l;
    }
    size += int3_size;
    let mut foreign3_size = 0;
    if let Some(TestMessage_OneofZero::Foreign3(ref val)) = self.oneof_zero {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign3_size += ::pb_jelly::wire_format::serialized_length(62);
      foreign3_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign3_size += l;
    }
    size += foreign3_size;
    let mut int4_size = 0;
    if let Some(TestMessage_OneofNull::Int4(ref val)) = self.oneof_null {
      let l = ::pb_jelly::Message::compute_size(val);
      int4_size += ::pb_jelly::wire_format::serialized_length(63);
      int4_size += l;
    }
    size += int4_size;
    let mut foreign4_size = 0;
    if let Some(TestMessage_OneofNull::Foreign4(ref val)) = self.oneof_null {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign4_size += ::pb_jelly::wire_format::serialized_length(64);
      foreign4_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign4_size += l;
    }
    size += foreign4_size;
    let mut int5_size = 0;
    if let Some(TestMessage_OneofUnset::Int5(ref val)) = self.oneof_unset {
      let l = ::pb_jelly::Message::compute_size(val);
      int5_size += ::pb_jelly::wire_format::serialized_length(65);
      int5_size += l;
    }
    size += int5_size;
    let mut foreign5_size = 0;
    if let Some(TestMessage_OneofUnset::Foreign5(ref val)) = self.oneof_unset {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign5_size += ::pb_jelly::wire_format::serialized_length(66);
      foreign5_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign5_size += l;
    }
    size += foreign5_size;
    let mut int6_size = 0;
    if let Some(TestMessage_OneofPrimitives::Int6(ref val)) = self.oneof_primitives {
      let l = ::pb_jelly::Message::compute_size(val);
      int6_size += ::pb_jelly::wire_format::serialized_length(67);
      int6_size += l;
    }
    size += int6_size;
    let mut bool6_size = 0;
    if let Some(TestMessage_OneofPrimitives::Bool6(ref val)) = self.oneof_primitives {
      let l = ::pb_jelly::Message::compute_size(val);
      bool6_size += ::pb_jelly::wire_format::serialized_length(68);
      bool6_size += l;
    }
    size += bool6_size;
    let mut a_size = 0;
    if let TestMessage_OneofEmptyField::A = self.oneof_empty_field {
      let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
      let l = ::pb_jelly::Message::compute_size(val);
      a_size += ::pb_jelly::wire_format::serialized_length(70);
      a_size += ::pb_jelly::varint::serialized_length(l as u64);
      a_size += l;
    }
    size += a_size;
    let mut b_size = 0;
    if let TestMessage_OneofEmptyField::B = self.oneof_empty_field {
      let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
      let l = ::pb_jelly::Message::compute_size(val);
      b_size += ::pb_jelly::wire_format::serialized_length(71);
      b_size += ::pb_jelly::varint::serialized_length(l as u64);
      b_size += l;
    }
    size += b_size;
    let mut c_size = 0;
    if let TestMessage_OneofEmptyField::C(ref val) = self.oneof_empty_field {
      let l = ::pb_jelly::Message::compute_size(val);
      c_size += ::pb_jelly::wire_format::serialized_length(72);
      c_size += l;
    }
    size += c_size;
    let mut type_size = 0;
    if let Some(ref val) = self.r#type {
      let l = ::pb_jelly::Message::compute_size(val);
      type_size += ::pb_jelly::wire_format::serialized_length(73);
      type_size += l;
    }
    size += type_size;
    let mut loop_size = 0;
    if let Some(TestMessage_Mod::Loop(ref val)) = self.r#mod {
      let l = ::pb_jelly::Message::compute_size(val);
      loop_size += ::pb_jelly::wire_format::serialized_length(74);
      loop_size += l;
    }
    size += loop_size;
    let mut unsafe_size = 0;
    if let Some(TestMessage_Mod::Unsafe(ref val)) = self.r#mod {
      let l = ::pb_jelly::Message::compute_size(val);
      unsafe_size += ::pb_jelly::wire_format::serialized_length(75);
      unsafe_size += l;
    }
    size += unsafe_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.optional_int32 {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_int64 {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_uint32 {
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_uint64 {
      ::pb_jelly::wire_format::write(4, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_fixed64 {
      ::pb_jelly::wire_format::write(8, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_fixed32 {
      ::pb_jelly::wire_format::write(9, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_sfixed64 {
      ::pb_jelly::wire_format::write(10, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_sfixed32 {
      ::pb_jelly::wire_format::write(11, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_double {
      ::pb_jelly::wire_format::write(12, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_bool {
      ::pb_jelly::wire_format::write(13, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_string {
      ::pb_jelly::wire_format::write(14, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_bytes {
      ::pb_jelly::wire_format::write(15, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_float {
      ::pb_jelly::wire_format::write(16, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_foreign_message {
      ::pb_jelly::wire_format::write(19, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_nested_enum {
      ::pb_jelly::wire_format::write(21, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_foreign_enum {
      ::pb_jelly::wire_format::write(22, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_int32 {
      ::pb_jelly::wire_format::write(31, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_int64 {
      ::pb_jelly::wire_format::write(32, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_uint32 {
      ::pb_jelly::wire_format::write(33, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_uint64 {
      ::pb_jelly::wire_format::write(34, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_fixed64 {
      ::pb_jelly::wire_format::write(38, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_fixed32 {
      ::pb_jelly::wire_format::write(39, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_sfixed64 {
      ::pb_jelly::wire_format::write(40, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_sfixed32 {
      ::pb_jelly::wire_format::write(41, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_double {
      ::pb_jelly::wire_format::write(42, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_bool {
      ::pb_jelly::wire_format::write(43, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_string {
      ::pb_jelly::wire_format::write(44, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_bytes {
      ::pb_jelly::wire_format::write(45, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_float {
      ::pb_jelly::wire_format::write(46, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_foreign_message {
      ::pb_jelly::wire_format::write(49, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_nested_enum {
      ::pb_jelly::wire_format::write(51, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_foreign_enum {
      ::pb_jelly::wire_format::write(52, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_foreign_message_boxed {
      let val = &**val;
      ::pb_jelly::wire_format::write(53, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
     {
      let val = &self.optional_foreign_message_nonnullable;
      ::pb_jelly::wire_format::write(54, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_OneofInt::Int1(ref val)) = self.oneof_int {
      ::pb_jelly::wire_format::write(57, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_OneofInt::Foreign1(ref val)) = self.oneof_int {
      ::pb_jelly::wire_format::write(58, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_OneofForeign::Int2(ref val)) = self.oneof_foreign {
      ::pb_jelly::wire_format::write(59, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_OneofForeign::Foreign2(ref val)) = self.oneof_foreign {
      ::pb_jelly::wire_format::write(60, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_OneofZero::Int3(ref val)) = self.oneof_zero {
      ::pb_jelly::wire_format::write(61, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_OneofZero::Foreign3(ref val)) = self.oneof_zero {
      ::pb_jelly::wire_format::write(62, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_OneofNull::Int4(ref val)) = self.oneof_null {
      ::pb_jelly::wire_format::write(63, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_OneofNull::Foreign4(ref val)) = self.oneof_null {
      ::pb_jelly::wire_format::write(64, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_OneofUnset::Int5(ref val)) = self.oneof_unset {
      ::pb_jelly::wire_format::write(65, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_OneofUnset::Foreign5(ref val)) = self.oneof_unset {
      ::pb_jelly::wire_format::write(66, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_OneofPrimitives::Int6(ref val)) = self.oneof_primitives {
      ::pb_jelly::wire_format::write(67, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_OneofPrimitives::Bool6(ref val)) = self.oneof_primitives {
      ::pb_jelly::wire_format::write(68, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage_OneofEmptyField::A = self.oneof_empty_field {
      let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
      ::pb_jelly::wire_format::write(70, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage_OneofEmptyField::B = self.oneof_empty_field {
      let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
      ::pb_jelly::wire_format::write(71, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage_OneofEmptyField::C(ref val) = self.oneof_empty_field {
      ::pb_jelly::wire_format::write(72, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.r#type {
      ::pb_jelly::wire_format::write(73, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_Mod::Loop(ref val)) = self.r#mod {
      ::pb_jelly::wire_format::write(74, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage_Mod::Unsafe(ref val)) = self.r#mod {
      ::pb_jelly::wire_format::write(75, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_oneof_empty_field: ::std::option::Option<TestMessage_OneofEmptyField> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 1)?;
          self.optional_int32 = Some(val);
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 2)?;
          self.optional_int64 = Some(val);
        }
        3 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 3)?;
          self.optional_uint32 = Some(val);
        }
        4 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 4)?;
          self.optional_uint64 = Some(val);
        }
        8 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Fixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage", 8)?;
          self.optional_fixed64 = Some(val);
        }
        9 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Fixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage", 9)?;
          self.optional_fixed32 = Some(val);
        }
        10 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Sfixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage", 10)?;
          self.optional_sfixed64 = Some(val);
        }
        11 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Sfixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage", 11)?;
          self.optional_sfixed32 = Some(val);
        }
        12 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage", 12)?;
          self.optional_double = Some(val);
        }
        13 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, bool>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 13)?;
          self.optional_bool = Some(val);
        }
        14 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestMessage", 14)?;
          self.optional_string = Some(val);
        }
        15 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::vec::Vec<u8>>(buf, typ, "TestMessage", 15)?;
          self.optional_bytes = Some(val);
        }
        16 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage", 16)?;
          self.optional_float = Some(val);
        }
        19 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage>(buf, typ, "TestMessage", 19)?;
          self.optional_foreign_message = Some(val);
        }
        21 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, TestMessage_NestedEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 21)?;
          self.optional_nested_enum = Some(val);
        }
        22 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ForeignEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 22)?;
          self.optional_foreign_enum = Some(val);
        }
        31 => {
          ::pb_jelly::helpers::deserialize_packed::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 31, &mut self.repeated_int32)?;
        }
        32 => {
          ::pb_jelly::helpers::deserialize_packed::<B, i64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 32, &mut self.repeated_int64)?;
        }
        33 => {
          ::pb_jelly::helpers::deserialize_packed::<B, u32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 33, &mut self.repeated_uint32)?;
        }
        34 => {
          ::pb_jelly::helpers::deserialize_packed::<B, u64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 34, &mut self.repeated_uint64)?;
        }
        38 => {
          ::pb_jelly::helpers::deserialize_packed::<B, ::pb_jelly::Fixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage", 38, &mut self.repeated_fixed64)?;
        }
        39 => {
          ::pb_jelly::helpers::deserialize_packed::<B, ::pb_jelly::Fixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage", 39, &mut self.repeated_fixed32)?;
        }
        40 => {
          ::pb_jelly::helpers::deserialize_packed::<B, ::pb_jelly::Sfixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage", 40, &mut self.repeated_sfixed64)?;
        }
        41 => {
          ::pb_jelly::helpers::deserialize_packed::<B, ::pb_jelly::Sfixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage", 41, &mut self.repeated_sfixed32)?;
        }
        42 => {
          ::pb_jelly::helpers::deserialize_packed::<B, f64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage", 42, &mut self.repeated_double)?;
        }
        43 => {
          ::pb_jelly::helpers::deserialize_packed::<B, bool>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 43, &mut self.repeated_bool)?;
        }
        44 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestMessage", 44)?;
          self.repeated_string.push(val);
        }
        45 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::vec::Vec<u8>>(buf, typ, "TestMessage", 45)?;
          self.repeated_bytes.push(val);
        }
        46 => {
          ::pb_jelly::helpers::deserialize_packed::<B, f32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage", 46, &mut self.repeated_float)?;
        }
        49 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage>(buf, typ, "TestMessage", 49)?;
          self.repeated_foreign_message.push(val);
        }
        51 => {
          ::pb_jelly::helpers::deserialize_packed::<B, TestMessage_NestedEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 51, &mut self.repeated_nested_enum)?;
        }
        52 => {
          ::pb_jelly::helpers::deserialize_packed::<B, ForeignEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 52, &mut self.repeated_foreign_enum)?;
        }
        53 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage>(buf, typ, "TestMessage", 53)?;
          self.optional_foreign_message_boxed = Some(Box::new(val));
        }
        54 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage>(buf, typ, "TestMessage", 54)?;
          self.optional_foreign_message_nonnullable = val;
        }
        57 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 57)?;
          self.oneof_int = Some(TestMessage_OneofInt::Int1(val));
        }
        58 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage>(buf, typ, "TestMessage", 58)?;
          self.oneof_int = Some(TestMessage_OneofInt::Foreign1(val));
        }
        59 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 59)?;
          self.oneof_foreign = Some(TestMessage_OneofForeign::Int2(val));
        }
        60 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage>(buf, typ, "TestMessage", 60)?;
          self.oneof_foreign = Some(TestMessage_OneofForeign::Foreign2(val));
        }
        61 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 61)?;
          self.oneof_zero = Some(TestMessage_OneofZero::Int3(val));
        }
        62 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage>(buf, typ, "TestMessage", 62)?;
          self.oneof_zero = Some(TestMessage_OneofZero::Foreign3(val));
        }
        63 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 63)?;
          self.oneof_null = Some(TestMessage_OneofNull::Int4(val));
        }
        64 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage>(buf, typ, "TestMessage", 64)?;
          self.oneof_null = Some(TestMessage_OneofNull::Foreign4(val));
        }
        65 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 65)?;
          self.oneof_unset = Some(TestMessage_OneofUnset::Int5(val));
        }
        66 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage>(buf, typ, "TestMessage", 66)?;
          self.oneof_unset = Some(TestMessage_OneofUnset::Foreign5(val));
        }
        67 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 67)?;
          self.oneof_primitives = Some(TestMessage_OneofPrimitives::Int6(val));
        }
        68 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, bool>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 68)?;
          self.oneof_primitives = Some(TestMessage_OneofPrimitives::Bool6(val));
        }
        70 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::proto_google::protobuf::empty::Empty>(buf, typ, "TestMessage", 70)?;
          oneof_oneof_empty_field = Some(TestMessage_OneofEmptyField::A);
        }
        71 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::proto_google::protobuf::empty::Empty>(buf, typ, "TestMessage", 71)?;
          oneof_oneof_empty_field = Some(TestMessage_OneofEmptyField::B);
        }
        72 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 72)?;
          oneof_oneof_empty_field = Some(TestMessage_OneofEmptyField::C(val));
        }
        73 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, bool>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 73)?;
          self.r#type = Some(val);
        }
        74 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 74)?;
          self.r#mod = Some(TestMessage_Mod::Loop(val));
        }
        75 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage", 75)?;
          self.r#mod = Some(TestMessage_Mod::Unsafe(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_oneof_empty_field {
      Some(v) => self.oneof_empty_field = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'oneof_empty_field' while parsing message pbtest.TestMessage")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "oneof_int" => {
        if let Some(TestMessage_OneofInt::Int1(ref val)) = self.oneof_int {
          return Some("int1");
        }
        if let Some(TestMessage_OneofInt::Foreign1(ref val)) = self.oneof_int {
          return Some("foreign1");
        }
        None
      }
      "oneof_foreign" => {
        if let Some(TestMessage_OneofForeign::Int2(ref val)) = self.oneof_foreign {
          return Some("int2");
        }
        if let Some(TestMessage_OneofForeign::Foreign2(ref val)) = self.oneof_foreign {
          return Some("foreign2");
        }
        None
      }
      "oneof_zero" => {
        if let Some(TestMessage_OneofZero::Int3(ref val)) = self.oneof_zero {
          return Some("int3");
        }
        if let Some(TestMessage_OneofZero::Foreign3(ref val)) = self.oneof_zero {
          return Some("foreign3");
        }
        None
      }
      "oneof_null" => {
        if let Some(TestMessage_OneofNull::Int4(ref val)) = self.oneof_null {
          return Some("int4");
        }
        if let Some(TestMessage_OneofNull::Foreign4(ref val)) = self.oneof_null {
          return Some("foreign4");
        }
        None
      }
      "oneof_unset" => {
        if let Some(TestMessage_OneofUnset::Int5(ref val)) = self.oneof_unset {
          return Some("int5");
        }
        if let Some(TestMessage_OneofUnset::Foreign5(ref val)) = self.oneof_unset {
          return Some("foreign5");
        }
        None
      }
      "oneof_primitives" => {
        if let Some(TestMessage_OneofPrimitives::Int6(ref val)) = self.oneof_primitives {
          return Some("int6");
        }
        if let Some(TestMessage_OneofPrimitives::Bool6(ref val)) = self.oneof_primitives {
          return Some("bool6");
        }
        None
      }
      "oneof_empty_field" => {
        if let TestMessage_OneofEmptyField::A = self.oneof_empty_field {
          let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
          return Some("a");
        }
        if let TestMessage_OneofEmptyField::B = self.oneof_empty_field {
          let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
          return Some("b");
        }
        if let TestMessage_OneofEmptyField::C(ref val) = self.oneof_empty_field {
          return Some("c");
        }
        None
      }
      "mod" => {
        if let Some(TestMessage_Mod::Loop(ref val)) = self.r#mod {
          return Some("loop");
        }
        if let Some(TestMessage_Mod::Unsafe(ref val)) = self.r#mod {
          return Some("unsafe");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "optional_int32" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_int32.get_or_insert_with(::std::default::Default::default))
      }
      "optional_int64" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_int64.get_or_insert_with(::std::default::Default::default))
      }
      "optional_uint32" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_uint32.get_or_insert_with(::std::default::Default::default))
      }
      "optional_uint64" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_uint64.get_or_insert_with(::std::default::Default::default))
      }
      "optional_fixed64" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_fixed64.get_or_insert_with(::std::default::Default::default))
      }
      "optional_fixed32" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_fixed32.get_or_insert_with(::std::default::Default::default))
      }
      "optional_sfixed64" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_sfixed64.get_or_insert_with(::std::default::Default::default))
      }
      "optional_sfixed32" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_sfixed32.get_or_insert_with(::std::default::Default::default))
      }
      "optional_double" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_double.get_or_insert_with(::std::default::Default::default))
      }
      "optional_bool" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_bool.get_or_insert_with(::std::default::Default::default))
      }
      "optional_string" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_string.get_or_insert_with(::std::default::Default::default))
      }
      "optional_bytes" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_bytes.get_or_insert_with(::std::default::Default::default))
      }
      "optional_float" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_float.get_or_insert_with(::std::default::Default::default))
      }
      "optional_foreign_message" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_foreign_message.get_or_insert_with(::std::default::Default::default))
      }
      "optional_nested_enum" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_nested_enum.get_or_insert_with(::std::default::Default::default))
      }
      "optional_foreign_enum" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_foreign_enum.get_or_insert_with(::std::default::Default::default))
      }
      "repeated_int32" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_int64" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_uint32" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_uint64" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_fixed64" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_fixed32" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_sfixed64" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_sfixed32" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_double" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_bool" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_string" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_bytes" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_float" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_foreign_message" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_nested_enum" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_foreign_enum" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "optional_foreign_message_boxed" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_foreign_message_boxed.get_or_insert_with(::std::default::Default::default).as_mut())
      }
      "optional_foreign_message_nonnullable" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_foreign_message_nonnullable)
      }
      "int1" => {
        match self.oneof_int {
          Some(TestMessage_OneofInt::Int1(_)) => (),
          _ => {
            self.oneof_int = Some(TestMessage_OneofInt::Int1(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_OneofInt::Int1(ref mut val)) = self.oneof_int {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "foreign1" => {
        match self.oneof_int {
          Some(TestMessage_OneofInt::Foreign1(_)) => (),
          _ => {
            self.oneof_int = Some(TestMessage_OneofInt::Foreign1(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_OneofInt::Foreign1(ref mut val)) = self.oneof_int {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int2" => {
        match self.oneof_foreign {
          Some(TestMessage_OneofForeign::Int2(_)) => (),
          _ => {
            self.oneof_foreign = Some(TestMessage_OneofForeign::Int2(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_OneofForeign::Int2(ref mut val)) = self.oneof_foreign {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "foreign2" => {
        match self.oneof_foreign {
          Some(TestMessage_OneofForeign::Foreign2(_)) => (),
          _ => {
            self.oneof_foreign = Some(TestMessage_OneofForeign::Foreign2(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_OneofForeign::Foreign2(ref mut val)) = self.oneof_foreign {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int3" => {
        match self.oneof_zero {
          Some(TestMessage_OneofZero::Int3(_)) => (),
          _ => {
            self.oneof_zero = Some(TestMessage_OneofZero::Int3(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_OneofZero::Int3(ref mut val)) = self.oneof_zero {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "foreign3" => {
        match self.oneof_zero {
          Some(TestMessage_OneofZero::Foreign3(_)) => (),
          _ => {
            self.oneof_zero = Some(TestMessage_OneofZero::Foreign3(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_OneofZero::Foreign3(ref mut val)) = self.oneof_zero {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int4" => {
        match self.oneof_null {
          Some(TestMessage_OneofNull::Int4(_)) => (),
          _ => {
            self.oneof_null = Some(TestMessage_OneofNull::Int4(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_OneofNull::Int4(ref mut val)) = self.oneof_null {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "foreign4" => {
        match self.oneof_null {
          Some(TestMessage_OneofNull::Foreign4(_)) => (),
          _ => {
            self.oneof_null = Some(TestMessage_OneofNull::Foreign4(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_OneofNull::Foreign4(ref mut val)) = self.oneof_null {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int5" => {
        match self.oneof_unset {
          Some(TestMessage_OneofUnset::Int5(_)) => (),
          _ => {
            self.oneof_unset = Some(TestMessage_OneofUnset::Int5(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_OneofUnset::Int5(ref mut val)) = self.oneof_unset {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "foreign5" => {
        match self.oneof_unset {
          Some(TestMessage_OneofUnset::Foreign5(_)) => (),
          _ => {
            self.oneof_unset = Some(TestMessage_OneofUnset::Foreign5(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_OneofUnset::Foreign5(ref mut val)) = self.oneof_unset {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int6" => {
        match self.oneof_primitives {
          Some(TestMessage_OneofPrimitives::Int6(_)) => (),
          _ => {
            self.oneof_primitives = Some(TestMessage_OneofPrimitives::Int6(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_OneofPrimitives::Int6(ref mut val)) = self.oneof_primitives {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "bool6" => {
        match self.oneof_primitives {
          Some(TestMessage_OneofPrimitives::Bool6(_)) => (),
          _ => {
            self.oneof_primitives = Some(TestMessage_OneofPrimitives::Bool6(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_OneofPrimitives::Bool6(ref mut val)) = self.oneof_primitives {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "a" => {
        match self.oneof_empty_field {
          TestMessage_OneofEmptyField::A => (),
          _ => {
            self.oneof_empty_field = TestMessage_OneofEmptyField::A;
          },
        }
        ::pb_jelly::reflection::FieldMut::Empty
      }
      "b" => {
        match self.oneof_empty_field {
          TestMessage_OneofEmptyField::B => (),
          _ => {
            self.oneof_empty_field = TestMessage_OneofEmptyField::B;
          },
        }
        ::pb_jelly::reflection::FieldMut::Empty
      }
      "c" => {
        match self.oneof_empty_field {
          TestMessage_OneofEmptyField::C(_) => (),
          _ => {
            self.oneof_empty_field = TestMessage_OneofEmptyField::C(::std::default::Default::default());
          },
        }
        if let TestMessage_OneofEmptyField::C(ref mut val) = self.oneof_empty_field {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "type" => {
        ::pb_jelly::reflection::FieldMut::Value(self.r#type.get_or_insert_with(::std::default::Default::default))
      }
      "loop" => {
        match self.r#mod {
          Some(TestMessage_Mod::Loop(_)) => (),
          _ => {
            self.r#mod = Some(TestMessage_Mod::Loop(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_Mod::Loop(ref mut val)) = self.r#mod {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "unsafe" => {
        match self.r#mod {
          Some(TestMessage_Mod::Unsafe(_)) => (),
          _ => {
            self.r#mod = Some(TestMessage_Mod::Unsafe(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage_Mod::Unsafe(ref mut val)) = self.r#mod {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

