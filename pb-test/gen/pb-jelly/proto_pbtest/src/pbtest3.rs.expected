// @generated, do not edit
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct ForeignEnum3(i32);
impl ForeignEnum3 {
  pub const FOREIGN3_FOO: ForeignEnum3 = ForeignEnum3(0);
  pub const FOREIGN3_BAR: ForeignEnum3 = ForeignEnum3(1);
  pub const FOREIGN3_BAZ: ForeignEnum3 = ForeignEnum3(2);
  pub const KNOWN_VARIANTS: [ForeignEnum3; 3] = [ForeignEnum3::FOREIGN3_FOO, ForeignEnum3::FOREIGN3_BAR, ForeignEnum3::FOREIGN3_BAZ];
  pub const fn value(self) -> i32 {
    self.0
  }
  pub fn into_known(self) -> ::std::option::Option<ForeignEnum3_Closed> {
    match self {
      ForeignEnum3::FOREIGN3_FOO => Some(ForeignEnum3_Closed::FOREIGN3_FOO),
      ForeignEnum3::FOREIGN3_BAR => Some(ForeignEnum3_Closed::FOREIGN3_BAR),
      ForeignEnum3::FOREIGN3_BAZ => Some(ForeignEnum3_Closed::FOREIGN3_BAZ),
      _ => None,
    }
  }
}
impl ::std::default::Default for ForeignEnum3 {
  fn default() -> Self {
    ForeignEnum3::FOREIGN3_FOO
  }
}
impl From<ForeignEnum3> for i32 {
  fn from(v: ForeignEnum3) -> i32 {
    v.0
  }
}
impl From<i32> for ForeignEnum3 {
  fn from(v: i32) -> ForeignEnum3 {
    ForeignEnum3(v)
  }
}
impl From<ForeignEnum3_Closed> for ForeignEnum3 {
  fn from(v: ForeignEnum3_Closed) -> ForeignEnum3 {
    ForeignEnum3(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for ForeignEnum3 {
}
impl ::pb_jelly::OpenProtoEnum for ForeignEnum3 {
  fn name(self) -> ::std::option::Option<&'static str> {
    match self {
      ForeignEnum3::FOREIGN3_FOO => Some("FOREIGN3_FOO"),
      ForeignEnum3::FOREIGN3_BAR => Some("FOREIGN3_BAR"),
      ForeignEnum3::FOREIGN3_BAZ => Some("FOREIGN3_BAZ"),
      _ => None,
    }
  }
  fn is_known(self) -> bool {
    match self {
      ForeignEnum3::FOREIGN3_FOO => true,
      ForeignEnum3::FOREIGN3_BAR => true,
      ForeignEnum3::FOREIGN3_BAZ => true,
      _ => false,
    }
  }
}
impl ::std::fmt::Debug for ForeignEnum3 {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    use ::pb_jelly::OpenProtoEnum;
    match self.name() {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum ForeignEnum3_Closed {
  FOREIGN3_FOO = 0,
  FOREIGN3_BAR = 1,
  FOREIGN3_BAZ = 2,
}
impl ForeignEnum3_Closed {
  pub const KNOWN_VARIANTS: [ForeignEnum3_Closed; 3] = [ForeignEnum3_Closed::FOREIGN3_FOO, ForeignEnum3_Closed::FOREIGN3_BAR, ForeignEnum3_Closed::FOREIGN3_BAZ];
}
impl ::std::default::Default for ForeignEnum3_Closed {
  fn default() -> Self {
    ForeignEnum3_Closed::FOREIGN3_FOO
  }
}
impl From<ForeignEnum3_Closed> for i32 {
  fn from(v: ForeignEnum3_Closed) -> i32 {
    match v {
      ForeignEnum3_Closed::FOREIGN3_FOO => 0,
      ForeignEnum3_Closed::FOREIGN3_BAR => 1,
      ForeignEnum3_Closed::FOREIGN3_BAZ => 2,
    }
  }
}
impl ::std::convert::TryFrom<i32> for ForeignEnum3_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(ForeignEnum3_Closed::FOREIGN3_FOO),
      1 => Ok(ForeignEnum3_Closed::FOREIGN3_BAR),
      2 => Ok(ForeignEnum3_Closed::FOREIGN3_BAZ),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for ForeignEnum3_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for ForeignEnum3_Closed {
  fn name(self) -> &'static str {
    match self {
      ForeignEnum3_Closed::FOREIGN3_FOO => "FOREIGN3_FOO",
      ForeignEnum3_Closed::FOREIGN3_BAR => "FOREIGN3_BAR",
      ForeignEnum3_Closed::FOREIGN3_BAZ => "FOREIGN3_BAZ",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct Version31Enum_TestEnum(i32);
impl Version31Enum_TestEnum {
  pub const ENUM0: Version31Enum_TestEnum = Version31Enum_TestEnum(0);
  pub const KNOWN_VARIANTS: [Version31Enum_TestEnum; 1] = [Version31Enum_TestEnum::ENUM0];
  pub const fn value(self) -> i32 {
    self.0
  }
  pub fn into_known(self) -> ::std::option::Option<Version31Enum_TestEnum_Closed> {
    match self {
      Version31Enum_TestEnum::ENUM0 => Some(Version31Enum_TestEnum_Closed::ENUM0),
      _ => None,
    }
  }
}
impl ::std::default::Default for Version31Enum_TestEnum {
  fn default() -> Self {
    Version31Enum_TestEnum::ENUM0
  }
}
impl From<Version31Enum_TestEnum> for i32 {
  fn from(v: Version31Enum_TestEnum) -> i32 {
    v.0
  }
}
impl From<i32> for Version31Enum_TestEnum {
  fn from(v: i32) -> Version31Enum_TestEnum {
    Version31Enum_TestEnum(v)
  }
}
impl From<Version31Enum_TestEnum_Closed> for Version31Enum_TestEnum {
  fn from(v: Version31Enum_TestEnum_Closed) -> Version31Enum_TestEnum {
    Version31Enum_TestEnum(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for Version31Enum_TestEnum {
}
impl ::pb_jelly::OpenProtoEnum for Version31Enum_TestEnum {
  fn name(self) -> ::std::option::Option<&'static str> {
    match self {
      Version31Enum_TestEnum::ENUM0 => Some("ENUM0"),
      _ => None,
    }
  }
  fn is_known(self) -> bool {
    match self {
      Version31Enum_TestEnum::ENUM0 => true,
      _ => false,
    }
  }
}
impl ::std::fmt::Debug for Version31Enum_TestEnum {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    use ::pb_jelly::OpenProtoEnum;
    match self.name() {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum Version31Enum_TestEnum_Closed {
  ENUM0 = 0,
}
impl Version31Enum_TestEnum_Closed {
  pub const KNOWN_VARIANTS: [Version31Enum_TestEnum_Closed; 1] = [Version31Enum_TestEnum_Closed::ENUM0];
}
impl ::std::default::Default for Version31Enum_TestEnum_Closed {
  fn default() -> Self {
    Version31Enum_TestEnum_Closed::ENUM0
  }
}
impl From<Version31Enum_TestEnum_Closed> for i32 {
  fn from(v: Version31Enum_TestEnum_Closed) -> i32 {
    match v {
      Version31Enum_TestEnum_Closed::ENUM0 => 0,
    }
  }
}
impl ::std::convert::TryFrom<i32> for Version31Enum_TestEnum_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(Version31Enum_TestEnum_Closed::ENUM0),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for Version31Enum_TestEnum_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for Version31Enum_TestEnum_Closed {
  fn name(self) -> &'static str {
    match self {
      Version31Enum_TestEnum_Closed::ENUM0 => "ENUM0",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct Version32Enum_TestEnum(i32);
impl Version32Enum_TestEnum {
  pub const ENUM0: Version32Enum_TestEnum = Version32Enum_TestEnum(0);
  pub const ENUM1: Version32Enum_TestEnum = Version32Enum_TestEnum(1);
  pub const KNOWN_VARIANTS: [Version32Enum_TestEnum; 2] = [Version32Enum_TestEnum::ENUM0, Version32Enum_TestEnum::ENUM1];
  pub const fn value(self) -> i32 {
    self.0
  }
  pub fn into_known(self) -> ::std::option::Option<Version32Enum_TestEnum_Closed> {
    match self {
      Version32Enum_TestEnum::ENUM0 => Some(Version32Enum_TestEnum_Closed::ENUM0),
      Version32Enum_TestEnum::ENUM1 => Some(Version32Enum_TestEnum_Closed::ENUM1),
      _ => None,
    }
  }
}
impl ::std::default::Default for Version32Enum_TestEnum {
  fn default() -> Self {
    Version32Enum_TestEnum::ENUM0
  }
}
impl From<Version32Enum_TestEnum> for i32 {
  fn from(v: Version32Enum_TestEnum) -> i32 {
    v.0
  }
}
impl From<i32> for Version32Enum_TestEnum {
  fn from(v: i32) -> Version32Enum_TestEnum {
    Version32Enum_TestEnum(v)
  }
}
impl From<Version32Enum_TestEnum_Closed> for Version32Enum_TestEnum {
  fn from(v: Version32Enum_TestEnum_Closed) -> Version32Enum_TestEnum {
    Version32Enum_TestEnum(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for Version32Enum_TestEnum {
}
impl ::pb_jelly::OpenProtoEnum for Version32Enum_TestEnum {
  fn name(self) -> ::std::option::Option<&'static str> {
    match self {
      Version32Enum_TestEnum::ENUM0 => Some("ENUM0"),
      Version32Enum_TestEnum::ENUM1 => Some("ENUM1"),
      _ => None,
    }
  }
  fn is_known(self) -> bool {
    match self {
      Version32Enum_TestEnum::ENUM0 => true,
      Version32Enum_TestEnum::ENUM1 => true,
      _ => false,
    }
  }
}
impl ::std::fmt::Debug for Version32Enum_TestEnum {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    use ::pb_jelly::OpenProtoEnum;
    match self.name() {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum Version32Enum_TestEnum_Closed {
  ENUM0 = 0,
  ENUM1 = 1,
}
impl Version32Enum_TestEnum_Closed {
  pub const KNOWN_VARIANTS: [Version32Enum_TestEnum_Closed; 2] = [Version32Enum_TestEnum_Closed::ENUM0, Version32Enum_TestEnum_Closed::ENUM1];
}
impl ::std::default::Default for Version32Enum_TestEnum_Closed {
  fn default() -> Self {
    Version32Enum_TestEnum_Closed::ENUM0
  }
}
impl From<Version32Enum_TestEnum_Closed> for i32 {
  fn from(v: Version32Enum_TestEnum_Closed) -> i32 {
    match v {
      Version32Enum_TestEnum_Closed::ENUM0 => 0,
      Version32Enum_TestEnum_Closed::ENUM1 => 1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for Version32Enum_TestEnum_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(Version32Enum_TestEnum_Closed::ENUM0),
      1 => Ok(Version32Enum_TestEnum_Closed::ENUM1),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for Version32Enum_TestEnum_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for Version32Enum_TestEnum_Closed {
  fn name(self) -> &'static str {
    match self {
      Version32Enum_TestEnum_Closed::ENUM0 => "ENUM0",
      Version32Enum_TestEnum_Closed::ENUM1 => "ENUM1",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct TestMessage3_NestedEnum3(i32);
impl TestMessage3_NestedEnum3 {
  pub const FOO: TestMessage3_NestedEnum3 = TestMessage3_NestedEnum3(0);
  pub const BAR: TestMessage3_NestedEnum3 = TestMessage3_NestedEnum3(1);
  pub const BAZ: TestMessage3_NestedEnum3 = TestMessage3_NestedEnum3(2);
  /// Intentionally negative.
  pub const NEG: TestMessage3_NestedEnum3 = TestMessage3_NestedEnum3(-1);
  pub const KNOWN_VARIANTS: [TestMessage3_NestedEnum3; 4] = [TestMessage3_NestedEnum3::FOO, TestMessage3_NestedEnum3::BAR, TestMessage3_NestedEnum3::BAZ, TestMessage3_NestedEnum3::NEG];
  pub const fn value(self) -> i32 {
    self.0
  }
  pub fn into_known(self) -> ::std::option::Option<TestMessage3_NestedEnum3_Closed> {
    match self {
      TestMessage3_NestedEnum3::FOO => Some(TestMessage3_NestedEnum3_Closed::FOO),
      TestMessage3_NestedEnum3::BAR => Some(TestMessage3_NestedEnum3_Closed::BAR),
      TestMessage3_NestedEnum3::BAZ => Some(TestMessage3_NestedEnum3_Closed::BAZ),
      TestMessage3_NestedEnum3::NEG => Some(TestMessage3_NestedEnum3_Closed::NEG),
      _ => None,
    }
  }
}
impl ::std::default::Default for TestMessage3_NestedEnum3 {
  fn default() -> Self {
    TestMessage3_NestedEnum3::FOO
  }
}
impl From<TestMessage3_NestedEnum3> for i32 {
  fn from(v: TestMessage3_NestedEnum3) -> i32 {
    v.0
  }
}
impl From<i32> for TestMessage3_NestedEnum3 {
  fn from(v: i32) -> TestMessage3_NestedEnum3 {
    TestMessage3_NestedEnum3(v)
  }
}
impl From<TestMessage3_NestedEnum3_Closed> for TestMessage3_NestedEnum3 {
  fn from(v: TestMessage3_NestedEnum3_Closed) -> TestMessage3_NestedEnum3 {
    TestMessage3_NestedEnum3(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3_NestedEnum3 {
}
impl ::pb_jelly::OpenProtoEnum for TestMessage3_NestedEnum3 {
  fn name(self) -> ::std::option::Option<&'static str> {
    match self {
      TestMessage3_NestedEnum3::FOO => Some("FOO"),
      TestMessage3_NestedEnum3::BAR => Some("BAR"),
      TestMessage3_NestedEnum3::BAZ => Some("BAZ"),
      TestMessage3_NestedEnum3::NEG => Some("NEG"),
      _ => None,
    }
  }
  fn is_known(self) -> bool {
    match self {
      TestMessage3_NestedEnum3::FOO => true,
      TestMessage3_NestedEnum3::BAR => true,
      TestMessage3_NestedEnum3::BAZ => true,
      TestMessage3_NestedEnum3::NEG => true,
      _ => false,
    }
  }
}
impl ::std::fmt::Debug for TestMessage3_NestedEnum3 {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    use ::pb_jelly::OpenProtoEnum;
    match self.name() {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage3_NestedEnum3_Closed {
  FOO = 0,
  BAR = 1,
  BAZ = 2,
  /// Intentionally negative.
  NEG = -1,
}
impl TestMessage3_NestedEnum3_Closed {
  pub const KNOWN_VARIANTS: [TestMessage3_NestedEnum3_Closed; 4] = [TestMessage3_NestedEnum3_Closed::FOO, TestMessage3_NestedEnum3_Closed::BAR, TestMessage3_NestedEnum3_Closed::BAZ, TestMessage3_NestedEnum3_Closed::NEG];
}
impl ::std::default::Default for TestMessage3_NestedEnum3_Closed {
  fn default() -> Self {
    TestMessage3_NestedEnum3_Closed::FOO
  }
}
impl From<TestMessage3_NestedEnum3_Closed> for i32 {
  fn from(v: TestMessage3_NestedEnum3_Closed) -> i32 {
    match v {
      TestMessage3_NestedEnum3_Closed::FOO => 0,
      TestMessage3_NestedEnum3_Closed::BAR => 1,
      TestMessage3_NestedEnum3_Closed::BAZ => 2,
      TestMessage3_NestedEnum3_Closed::NEG => -1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage3_NestedEnum3_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(TestMessage3_NestedEnum3_Closed::FOO),
      1 => Ok(TestMessage3_NestedEnum3_Closed::BAR),
      2 => Ok(TestMessage3_NestedEnum3_Closed::BAZ),
      -1 => Ok(TestMessage3_NestedEnum3_Closed::NEG),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3_NestedEnum3_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage3_NestedEnum3_Closed {
  fn name(self) -> &'static str {
    match self {
      TestMessage3_NestedEnum3_Closed::FOO => "FOO",
      TestMessage3_NestedEnum3_Closed::BAR => "BAR",
      TestMessage3_NestedEnum3_Closed::BAZ => "BAZ",
      TestMessage3_NestedEnum3_Closed::NEG => "NEG",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct TestMessage3_NestedMessage_Enum(i32);
impl TestMessage3_NestedMessage_Enum {
  pub const ENUM_VARIANT_ONE: TestMessage3_NestedMessage_Enum = TestMessage3_NestedMessage_Enum(0);
  pub const KNOWN_VARIANTS: [TestMessage3_NestedMessage_Enum; 1] = [TestMessage3_NestedMessage_Enum::ENUM_VARIANT_ONE];
  pub const fn value(self) -> i32 {
    self.0
  }
  pub fn into_known(self) -> ::std::option::Option<TestMessage3_NestedMessage_Enum_Closed> {
    match self {
      TestMessage3_NestedMessage_Enum::ENUM_VARIANT_ONE => Some(TestMessage3_NestedMessage_Enum_Closed::ENUM_VARIANT_ONE),
      _ => None,
    }
  }
}
impl ::std::default::Default for TestMessage3_NestedMessage_Enum {
  fn default() -> Self {
    TestMessage3_NestedMessage_Enum::ENUM_VARIANT_ONE
  }
}
impl From<TestMessage3_NestedMessage_Enum> for i32 {
  fn from(v: TestMessage3_NestedMessage_Enum) -> i32 {
    v.0
  }
}
impl From<i32> for TestMessage3_NestedMessage_Enum {
  fn from(v: i32) -> TestMessage3_NestedMessage_Enum {
    TestMessage3_NestedMessage_Enum(v)
  }
}
impl From<TestMessage3_NestedMessage_Enum_Closed> for TestMessage3_NestedMessage_Enum {
  fn from(v: TestMessage3_NestedMessage_Enum_Closed) -> TestMessage3_NestedMessage_Enum {
    TestMessage3_NestedMessage_Enum(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3_NestedMessage_Enum {
}
impl ::pb_jelly::OpenProtoEnum for TestMessage3_NestedMessage_Enum {
  fn name(self) -> ::std::option::Option<&'static str> {
    match self {
      TestMessage3_NestedMessage_Enum::ENUM_VARIANT_ONE => Some("ENUM_VARIANT_ONE"),
      _ => None,
    }
  }
  fn is_known(self) -> bool {
    match self {
      TestMessage3_NestedMessage_Enum::ENUM_VARIANT_ONE => true,
      _ => false,
    }
  }
}
impl ::std::fmt::Debug for TestMessage3_NestedMessage_Enum {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    use ::pb_jelly::OpenProtoEnum;
    match self.name() {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage3_NestedMessage_Enum_Closed {
  ENUM_VARIANT_ONE = 0,
}
impl TestMessage3_NestedMessage_Enum_Closed {
  pub const KNOWN_VARIANTS: [TestMessage3_NestedMessage_Enum_Closed; 1] = [TestMessage3_NestedMessage_Enum_Closed::ENUM_VARIANT_ONE];
}
impl ::std::default::Default for TestMessage3_NestedMessage_Enum_Closed {
  fn default() -> Self {
    TestMessage3_NestedMessage_Enum_Closed::ENUM_VARIANT_ONE
  }
}
impl From<TestMessage3_NestedMessage_Enum_Closed> for i32 {
  fn from(v: TestMessage3_NestedMessage_Enum_Closed) -> i32 {
    match v {
      TestMessage3_NestedMessage_Enum_Closed::ENUM_VARIANT_ONE => 0,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage3_NestedMessage_Enum_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(TestMessage3_NestedMessage_Enum_Closed::ENUM_VARIANT_ONE),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3_NestedMessage_Enum_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage3_NestedMessage_Enum_Closed {
  fn name(self) -> &'static str {
    match self {
      TestMessage3_NestedMessage_Enum_Closed::ENUM_VARIANT_ONE => "ENUM_VARIANT_ONE",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage3_NestedMessage_NonNullableEnum {
  NON_NULLABLE_VARIANT_ONE = 1,
}
impl TestMessage3_NestedMessage_NonNullableEnum {
  pub const KNOWN_VARIANTS: [TestMessage3_NestedMessage_NonNullableEnum; 1] = [TestMessage3_NestedMessage_NonNullableEnum::NON_NULLABLE_VARIANT_ONE];
}
impl ::std::default::Default for TestMessage3_NestedMessage_NonNullableEnum {
  fn default() -> Self {
    TestMessage3_NestedMessage_NonNullableEnum::NON_NULLABLE_VARIANT_ONE
  }
}
impl From<TestMessage3_NestedMessage_NonNullableEnum> for i32 {
  fn from(v: TestMessage3_NestedMessage_NonNullableEnum) -> i32 {
    match v {
      TestMessage3_NestedMessage_NonNullableEnum::NON_NULLABLE_VARIANT_ONE => 1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage3_NestedMessage_NonNullableEnum {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      1 => Ok(TestMessage3_NestedMessage_NonNullableEnum::NON_NULLABLE_VARIANT_ONE),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3_NestedMessage_NonNullableEnum {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage3_NestedMessage_NonNullableEnum {
  fn name(self) -> &'static str {
    match self {
      TestMessage3_NestedMessage_NonNullableEnum::NON_NULLABLE_VARIANT_ONE => "NON_NULLABLE_VARIANT_ONE",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum {
  THE_OTHER_ONE = 1,
}
impl TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum {
  pub const KNOWN_VARIANTS: [TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum; 1] = [TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum::THE_OTHER_ONE];
}
impl ::std::default::Default for TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum {
  fn default() -> Self {
    TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum::THE_OTHER_ONE
  }
}
impl From<TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum> for i32 {
  fn from(v: TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum) -> i32 {
    match v {
      TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum::THE_OTHER_ONE => 1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      1 => Ok(TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum::THE_OTHER_ONE),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum {
  fn name(self) -> &'static str {
    match self {
      TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum::THE_OTHER_ONE => "THE_OTHER_ONE",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum {
  THE_OTHER_ONE = 1,
}
impl TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum {
  pub const KNOWN_VARIANTS: [TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum; 1] = [TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum::THE_OTHER_ONE];
}
impl ::std::default::Default for TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum {
  fn default() -> Self {
    TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum::THE_OTHER_ONE
  }
}
impl From<TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum> for i32 {
  fn from(v: TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum) -> i32 {
    match v {
      TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum::THE_OTHER_ONE => 1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      1 => Ok(TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum::THE_OTHER_ONE),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum {
  fn name(self) -> &'static str {
    match self {
      TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum::THE_OTHER_ONE => "THE_OTHER_ONE",
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ForeignMessage3 {
  pub c: i32,
}
impl ::std::default::Default for ForeignMessage3 {
  fn default() -> Self {
    ForeignMessage3 {
      c: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref ForeignMessage3_default: ForeignMessage3 = ForeignMessage3::default();
}
impl ::pb_jelly::Message for ForeignMessage3 {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut c_size = 0;
    if self.c != <i32 as ::std::default::Default>::default() {
      let val = &self.c;
      let l = ::pb_jelly::Message::compute_size(val);
      c_size += ::pb_jelly::wire_format::serialized_length(1);
      c_size += l;
    }
    size += c_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if self.c != <i32 as ::std::default::Default>::default() {
      let val = &self.c;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if self.c != <i32 as ::std::default::Default>::default() {
      let val = &self.c;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "ForeignMessage3", 1)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.c = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for ForeignMessage3 {
  const NAME: &'static str = "ForeignMessage3";
  const FULL_NAME: &'static str = "pbtest.ForeignMessage3";
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version31OneOfNoneNullable {
  pub test_oneof: Version31OneOfNoneNullable_TestOneof,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version31OneOfNoneNullable_TestOneof {
  StringOneOf(::std::string::String),
  StringTwoOf(::std::string::String),
}
impl ::std::default::Default for Version31OneOfNoneNullable {
  fn default() -> Self {
    Version31OneOfNoneNullable {
      test_oneof: Version31OneOfNoneNullable_TestOneof::StringOneOf(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref Version31OneOfNoneNullable_default: Version31OneOfNoneNullable = Version31OneOfNoneNullable::default();
}
impl ::pb_jelly::Message for Version31OneOfNoneNullable {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Version31OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    let mut string_two_of_size = 0;
    if let Version31OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_two_of_size += ::pb_jelly::wire_format::serialized_length(2);
      string_two_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_two_of_size += l;
    }
    size += string_two_of_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if let Version31OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Version31OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Version31OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Version31OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_test_oneof: ::std::option::Option<Version31OneOfNoneNullable_TestOneof> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "Version31OneOfNoneNullable", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          oneof_test_oneof = Some(Version31OneOfNoneNullable_TestOneof::StringOneOf(val));
        }
        2 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "Version31OneOfNoneNullable", 2)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          oneof_test_oneof = Some(Version31OneOfNoneNullable_TestOneof::StringTwoOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_test_oneof {
      Some(v) => self.test_oneof = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'test_oneof' while parsing message pbtest.Version31OneOfNoneNullable")),
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for Version31OneOfNoneNullable {
  const NAME: &'static str = "Version31OneOfNoneNullable";
  const FULL_NAME: &'static str = "pbtest.Version31OneOfNoneNullable";
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version32OneOfNoneNullable {
  pub test_oneof: Version32OneOfNoneNullable_TestOneof,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version32OneOfNoneNullable_TestOneof {
  StringOneOf(::std::string::String),
  StringTwoOf(::std::string::String),
  IntOneOf(i32),
}
impl ::std::default::Default for Version32OneOfNoneNullable {
  fn default() -> Self {
    Version32OneOfNoneNullable {
      test_oneof: Version32OneOfNoneNullable_TestOneof::StringOneOf(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref Version32OneOfNoneNullable_default: Version32OneOfNoneNullable = Version32OneOfNoneNullable::default();
}
impl ::pb_jelly::Message for Version32OneOfNoneNullable {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Version32OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    let mut string_two_of_size = 0;
    if let Version32OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_two_of_size += ::pb_jelly::wire_format::serialized_length(2);
      string_two_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_two_of_size += l;
    }
    size += string_two_of_size;
    let mut int_one_Of_size = 0;
    if let Version32OneOfNoneNullable_TestOneof::IntOneOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      int_one_Of_size += ::pb_jelly::wire_format::serialized_length(3);
      int_one_Of_size += l;
    }
    size += int_one_Of_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if let Version32OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Version32OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Version32OneOfNoneNullable_TestOneof::IntOneOf(ref val) = self.test_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Version32OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Version32OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Version32OneOfNoneNullable_TestOneof::IntOneOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_test_oneof: ::std::option::Option<Version32OneOfNoneNullable_TestOneof> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "Version32OneOfNoneNullable", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          oneof_test_oneof = Some(Version32OneOfNoneNullable_TestOneof::StringOneOf(val));
        }
        2 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "Version32OneOfNoneNullable", 2)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          oneof_test_oneof = Some(Version32OneOfNoneNullable_TestOneof::StringTwoOf(val));
        }
        3 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "Version32OneOfNoneNullable", 3)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          oneof_test_oneof = Some(Version32OneOfNoneNullable_TestOneof::IntOneOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_test_oneof {
      Some(v) => self.test_oneof = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'test_oneof' while parsing message pbtest.Version32OneOfNoneNullable")),
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for Version32OneOfNoneNullable {
  const NAME: &'static str = "Version32OneOfNoneNullable";
  const FULL_NAME: &'static str = "pbtest.Version32OneOfNoneNullable";
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version31Enum {
  pub enum_field: Version31Enum_TestEnum,
}
impl ::std::default::Default for Version31Enum {
  fn default() -> Self {
    Version31Enum {
      enum_field: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version31Enum_default: Version31Enum = Version31Enum::default();
}
impl ::pb_jelly::Message for Version31Enum {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut enum_field_size = 0;
    if self.enum_field != <Version31Enum_TestEnum as ::std::default::Default>::default() {
      let val = &self.enum_field;
      let l = ::pb_jelly::Message::compute_size(val);
      enum_field_size += ::pb_jelly::wire_format::serialized_length(1);
      enum_field_size += l;
    }
    size += enum_field_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if self.enum_field != <Version31Enum_TestEnum as ::std::default::Default>::default() {
      let val = &self.enum_field;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if self.enum_field != <Version31Enum_TestEnum as ::std::default::Default>::default() {
      let val = &self.enum_field;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "Version31Enum", 1)?;
          let mut val: Version31Enum_TestEnum = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.enum_field = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for Version31Enum {
  const NAME: &'static str = "Version31Enum";
  const FULL_NAME: &'static str = "pbtest.Version31Enum";
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version32Enum {
  pub enum_field: Version32Enum_TestEnum,
}
impl ::std::default::Default for Version32Enum {
  fn default() -> Self {
    Version32Enum {
      enum_field: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version32Enum_default: Version32Enum = Version32Enum::default();
}
impl ::pb_jelly::Message for Version32Enum {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut enum_field_size = 0;
    if self.enum_field != <Version32Enum_TestEnum as ::std::default::Default>::default() {
      let val = &self.enum_field;
      let l = ::pb_jelly::Message::compute_size(val);
      enum_field_size += ::pb_jelly::wire_format::serialized_length(1);
      enum_field_size += l;
    }
    size += enum_field_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if self.enum_field != <Version32Enum_TestEnum as ::std::default::Default>::default() {
      let val = &self.enum_field;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if self.enum_field != <Version32Enum_TestEnum as ::std::default::Default>::default() {
      let val = &self.enum_field;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "Version32Enum", 1)?;
          let mut val: Version32Enum_TestEnum = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.enum_field = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for Version32Enum {
  const NAME: &'static str = "Version32Enum";
  const FULL_NAME: &'static str = "pbtest.Version32Enum";
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version31OneOf {
  pub test_oneof: ::std::option::Option<Version31OneOf_TestOneof>,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version31OneOf_TestOneof {
  StringOneOf(::std::string::String),
}
impl ::std::default::Default for Version31OneOf {
  fn default() -> Self {
    Version31OneOf {
      test_oneof: None,
    }
  }
}
lazy_static! {
  pub static ref Version31OneOf_default: Version31OneOf = Version31OneOf::default();
}
impl ::pb_jelly::Message for Version31OneOf {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Some(Version31OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if let Some(Version31OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(Version31OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "Version31OneOf", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.test_oneof = Some(Version31OneOf_TestOneof::StringOneOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for Version31OneOf {
  const NAME: &'static str = "Version31OneOf";
  const FULL_NAME: &'static str = "pbtest.Version31OneOf";
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version32OneOf {
  pub test_oneof: ::std::option::Option<Version32OneOf_TestOneof>,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version32OneOf_TestOneof {
  StringOneOf(::std::string::String),
  IntOneOf(i32),
}
impl ::std::default::Default for Version32OneOf {
  fn default() -> Self {
    Version32OneOf {
      test_oneof: None,
    }
  }
}
lazy_static! {
  pub static ref Version32OneOf_default: Version32OneOf = Version32OneOf::default();
}
impl ::pb_jelly::Message for Version32OneOf {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Some(Version32OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    let mut int_one_of_size = 0;
    if let Some(Version32OneOf_TestOneof::IntOneOf(ref val)) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      int_one_of_size += ::pb_jelly::wire_format::serialized_length(2);
      int_one_of_size += l;
    }
    size += int_one_of_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if let Some(Version32OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(Version32OneOf_TestOneof::IntOneOf(ref val)) = self.test_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(Version32OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(Version32OneOf_TestOneof::IntOneOf(ref val)) = self.test_oneof {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "Version32OneOf", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.test_oneof = Some(Version32OneOf_TestOneof::StringOneOf(val));
        }
        2 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "Version32OneOf", 2)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.test_oneof = Some(Version32OneOf_TestOneof::IntOneOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for Version32OneOf {
  const NAME: &'static str = "Version32OneOf";
  const FULL_NAME: &'static str = "pbtest.Version32OneOf";
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version31 {
  pub optional_string1: ::std::string::String,
}
impl ::std::default::Default for Version31 {
  fn default() -> Self {
    Version31 {
      optional_string1: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version31_default: Version31 = Version31::default();
}
impl ::pb_jelly::Message for Version31 {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut optional_string1_size = 0;
    if self.optional_string1 != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.optional_string1;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_string1_size += ::pb_jelly::wire_format::serialized_length(1);
      optional_string1_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_string1_size += l;
    }
    size += optional_string1_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if self.optional_string1 != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.optional_string1;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if self.optional_string1 != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.optional_string1;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "Version31", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.optional_string1 = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for Version31 {
  const NAME: &'static str = "Version31";
  const FULL_NAME: &'static str = "pbtest.Version31";
}

#[derive(Clone, Debug, PartialEq)]
pub struct Version32 {
  pub optional_string1: ::std::string::String,
  pub optional_int32: i32,
  pub optional_int64: i64,
  pub optional_uint32: u32,
  pub optional_uint64: u64,
  pub optional_fixed64: ::pb_jelly::Fixed64,
  pub optional_fixed32: ::pb_jelly::Fixed32,
  pub optional_sfixed64: ::pb_jelly::Sfixed64,
  pub optional_sfixed32: ::pb_jelly::Sfixed32,
  pub optional_double: f64,
  pub optional_bool: bool,
  pub optional_string: ::std::string::String,
  pub optional_bytes: ::std::vec::Vec<u8>,
  pub optional_float: f32,
}
impl ::std::default::Default for Version32 {
  fn default() -> Self {
    Version32 {
      optional_string1: ::std::default::Default::default(),
      optional_int32: ::std::default::Default::default(),
      optional_int64: ::std::default::Default::default(),
      optional_uint32: ::std::default::Default::default(),
      optional_uint64: ::std::default::Default::default(),
      optional_fixed64: ::std::default::Default::default(),
      optional_fixed32: ::std::default::Default::default(),
      optional_sfixed64: ::std::default::Default::default(),
      optional_sfixed32: ::std::default::Default::default(),
      optional_double: ::std::default::Default::default(),
      optional_bool: ::std::default::Default::default(),
      optional_string: ::std::default::Default::default(),
      optional_bytes: ::std::default::Default::default(),
      optional_float: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version32_default: Version32 = Version32::default();
}
impl ::pb_jelly::Message for Version32 {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut optional_string1_size = 0;
    if self.optional_string1 != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.optional_string1;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_string1_size += ::pb_jelly::wire_format::serialized_length(1);
      optional_string1_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_string1_size += l;
    }
    size += optional_string1_size;
    let mut optional_int32_size = 0;
    if self.optional_int32 != <i32 as ::std::default::Default>::default() {
      let val = &self.optional_int32;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_int32_size += ::pb_jelly::wire_format::serialized_length(2);
      optional_int32_size += l;
    }
    size += optional_int32_size;
    let mut optional_int64_size = 0;
    if self.optional_int64 != <i64 as ::std::default::Default>::default() {
      let val = &self.optional_int64;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_int64_size += ::pb_jelly::wire_format::serialized_length(3);
      optional_int64_size += l;
    }
    size += optional_int64_size;
    let mut optional_uint32_size = 0;
    if self.optional_uint32 != <u32 as ::std::default::Default>::default() {
      let val = &self.optional_uint32;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_uint32_size += ::pb_jelly::wire_format::serialized_length(4);
      optional_uint32_size += l;
    }
    size += optional_uint32_size;
    let mut optional_uint64_size = 0;
    if self.optional_uint64 != <u64 as ::std::default::Default>::default() {
      let val = &self.optional_uint64;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_uint64_size += ::pb_jelly::wire_format::serialized_length(5);
      optional_uint64_size += l;
    }
    size += optional_uint64_size;
    let mut optional_fixed64_size = 0;
    if self.optional_fixed64 != <::pb_jelly::Fixed64 as ::std::default::Default>::default() {
      let val = &self.optional_fixed64;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_fixed64_size += ::pb_jelly::wire_format::serialized_length(6);
      optional_fixed64_size += l;
    }
    size += optional_fixed64_size;
    let mut optional_fixed32_size = 0;
    if self.optional_fixed32 != <::pb_jelly::Fixed32 as ::std::default::Default>::default() {
      let val = &self.optional_fixed32;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_fixed32_size += ::pb_jelly::wire_format::serialized_length(7);
      optional_fixed32_size += l;
    }
    size += optional_fixed32_size;
    let mut optional_sfixed64_size = 0;
    if self.optional_sfixed64 != <::pb_jelly::Sfixed64 as ::std::default::Default>::default() {
      let val = &self.optional_sfixed64;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_sfixed64_size += ::pb_jelly::wire_format::serialized_length(8);
      optional_sfixed64_size += l;
    }
    size += optional_sfixed64_size;
    let mut optional_sfixed32_size = 0;
    if self.optional_sfixed32 != <::pb_jelly::Sfixed32 as ::std::default::Default>::default() {
      let val = &self.optional_sfixed32;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_sfixed32_size += ::pb_jelly::wire_format::serialized_length(9);
      optional_sfixed32_size += l;
    }
    size += optional_sfixed32_size;
    let mut optional_double_size = 0;
    if self.optional_double != <f64 as ::std::default::Default>::default() {
      let val = &self.optional_double;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_double_size += ::pb_jelly::wire_format::serialized_length(10);
      optional_double_size += l;
    }
    size += optional_double_size;
    let mut optional_bool_size = 0;
    if self.optional_bool != <bool as ::std::default::Default>::default() {
      let val = &self.optional_bool;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_bool_size += ::pb_jelly::wire_format::serialized_length(11);
      optional_bool_size += l;
    }
    size += optional_bool_size;
    let mut optional_string_size = 0;
    if self.optional_string != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.optional_string;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_string_size += ::pb_jelly::wire_format::serialized_length(12);
      optional_string_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_string_size += l;
    }
    size += optional_string_size;
    let mut optional_bytes_size = 0;
    if self.optional_bytes != <::std::vec::Vec<u8> as ::std::default::Default>::default() {
      let val = &self.optional_bytes;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_bytes_size += ::pb_jelly::wire_format::serialized_length(13);
      optional_bytes_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_bytes_size += l;
    }
    size += optional_bytes_size;
    let mut optional_float_size = 0;
    if self.optional_float != <f32 as ::std::default::Default>::default() {
      let val = &self.optional_float;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_float_size += ::pb_jelly::wire_format::serialized_length(14);
      optional_float_size += l;
    }
    size += optional_float_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if self.optional_string1 != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.optional_string1;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_int32 != <i32 as ::std::default::Default>::default() {
      let val = &self.optional_int32;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_int64 != <i64 as ::std::default::Default>::default() {
      let val = &self.optional_int64;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_uint32 != <u32 as ::std::default::Default>::default() {
      let val = &self.optional_uint32;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_uint64 != <u64 as ::std::default::Default>::default() {
      let val = &self.optional_uint64;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_fixed64 != <::pb_jelly::Fixed64 as ::std::default::Default>::default() {
      let val = &self.optional_fixed64;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_fixed32 != <::pb_jelly::Fixed32 as ::std::default::Default>::default() {
      let val = &self.optional_fixed32;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_sfixed64 != <::pb_jelly::Sfixed64 as ::std::default::Default>::default() {
      let val = &self.optional_sfixed64;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_sfixed32 != <::pb_jelly::Sfixed32 as ::std::default::Default>::default() {
      let val = &self.optional_sfixed32;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_double != <f64 as ::std::default::Default>::default() {
      let val = &self.optional_double;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_bool != <bool as ::std::default::Default>::default() {
      let val = &self.optional_bool;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_string != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.optional_string;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_bytes != <::std::vec::Vec<u8> as ::std::default::Default>::default() {
      let val = &self.optional_bytes;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_float != <f32 as ::std::default::Default>::default() {
      let val = &self.optional_float;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if self.optional_string1 != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.optional_string1;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_int32 != <i32 as ::std::default::Default>::default() {
      let val = &self.optional_int32;
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_int64 != <i64 as ::std::default::Default>::default() {
      let val = &self.optional_int64;
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_uint32 != <u32 as ::std::default::Default>::default() {
      let val = &self.optional_uint32;
      ::pb_jelly::wire_format::write(4, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_uint64 != <u64 as ::std::default::Default>::default() {
      let val = &self.optional_uint64;
      ::pb_jelly::wire_format::write(5, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_fixed64 != <::pb_jelly::Fixed64 as ::std::default::Default>::default() {
      let val = &self.optional_fixed64;
      ::pb_jelly::wire_format::write(6, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_fixed32 != <::pb_jelly::Fixed32 as ::std::default::Default>::default() {
      let val = &self.optional_fixed32;
      ::pb_jelly::wire_format::write(7, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_sfixed64 != <::pb_jelly::Sfixed64 as ::std::default::Default>::default() {
      let val = &self.optional_sfixed64;
      ::pb_jelly::wire_format::write(8, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_sfixed32 != <::pb_jelly::Sfixed32 as ::std::default::Default>::default() {
      let val = &self.optional_sfixed32;
      ::pb_jelly::wire_format::write(9, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_double != <f64 as ::std::default::Default>::default() {
      let val = &self.optional_double;
      ::pb_jelly::wire_format::write(10, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_bool != <bool as ::std::default::Default>::default() {
      let val = &self.optional_bool;
      ::pb_jelly::wire_format::write(11, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_string != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.optional_string;
      ::pb_jelly::wire_format::write(12, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_bytes != <::std::vec::Vec<u8> as ::std::default::Default>::default() {
      let val = &self.optional_bytes;
      ::pb_jelly::wire_format::write(13, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_float != <f32 as ::std::default::Default>::default() {
      let val = &self.optional_float;
      ::pb_jelly::wire_format::write(14, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "Version32", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.optional_string1 = val;
        }
        2 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "Version32", 2)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_int32 = val;
        }
        3 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "Version32", 3)?;
          let mut val: i64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_int64 = val;
        }
        4 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "Version32", 4)?;
          let mut val: u32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_uint32 = val;
        }
        5 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "Version32", 5)?;
          let mut val: u64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_uint64 = val;
        }
        6 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "Version32", 6)?;
          let mut val: ::pb_jelly::Fixed64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_fixed64 = val;
        }
        7 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed32, "Version32", 7)?;
          let mut val: ::pb_jelly::Fixed32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_fixed32 = val;
        }
        8 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "Version32", 8)?;
          let mut val: ::pb_jelly::Sfixed64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_sfixed64 = val;
        }
        9 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed32, "Version32", 9)?;
          let mut val: ::pb_jelly::Sfixed32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_sfixed32 = val;
        }
        10 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "Version32", 10)?;
          let mut val: f64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_double = val;
        }
        11 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "Version32", 11)?;
          let mut val: bool = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_bool = val;
        }
        12 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "Version32", 12)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.optional_string = val;
        }
        13 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "Version32", 13)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::vec::Vec<u8> = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.optional_bytes = val;
        }
        14 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed32, "Version32", 14)?;
          let mut val: f32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_float = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for Version32 {
  const NAME: &'static str = "Version32";
  const FULL_NAME: &'static str = "pbtest.Version32";
}

#[derive(Clone, Debug, PartialEq)]
pub struct TestMessage3 {
  pub optional_int32: i32,
  pub optional_int64: i64,
  pub optional_uint32: u32,
  pub optional_uint64: u64,
  pub optional_fixed64: ::pb_jelly::Fixed64,
  pub optional_fixed32: ::pb_jelly::Fixed32,
  pub optional_sfixed64: ::pb_jelly::Sfixed64,
  pub optional_sfixed32: ::pb_jelly::Sfixed32,
  pub optional_double: f64,
  pub optional_bool: bool,
  pub optional_string: ::std::string::String,
  pub optional_bytes: ::std::vec::Vec<u8>,
  pub optional_float: f32,
  pub optional_foreign_message: ::std::option::Option<ForeignMessage3>,
  pub optional_nested_enum: TestMessage3_NestedEnum3,
  pub optional_foreign_enum: ForeignEnum3,
  pub repeated_int32: ::std::vec::Vec<i32>,
  pub repeated_int64: ::std::vec::Vec<i64>,
  pub repeated_uint32: ::std::vec::Vec<u32>,
  pub repeated_uint64: ::std::vec::Vec<u64>,
  pub repeated_fixed64: ::std::vec::Vec<::pb_jelly::Fixed64>,
  pub repeated_fixed32: ::std::vec::Vec<::pb_jelly::Fixed32>,
  pub repeated_sfixed64: ::std::vec::Vec<::pb_jelly::Sfixed64>,
  pub repeated_sfixed32: ::std::vec::Vec<::pb_jelly::Sfixed32>,
  pub repeated_double: ::std::vec::Vec<f64>,
  pub repeated_bool: ::std::vec::Vec<bool>,
  pub repeated_string: ::std::vec::Vec<::std::string::String>,
  pub repeated_bytes: ::std::vec::Vec<::std::vec::Vec<u8>>,
  pub repeated_float: ::std::vec::Vec<f32>,
  pub repeated_foreign_message: ::std::vec::Vec<ForeignMessage3>,
  pub repeated_nested_enum: ::std::vec::Vec<TestMessage3_NestedEnum3>,
  pub repeated_foreign_enum: ::std::vec::Vec<ForeignEnum3>,
  /// Message compatibility with proto2.
  /// proto2 enum are not compatible, but messages are.
  pub proto2_msg: ::std::option::Option<super::pbtest2::ForeignMessage>,
  pub proto2_msg_empty: ::std::option::Option<super::pbtest2::ForeignMessage>,
  pub proto2_msg_missing: ::std::option::Option<super::pbtest2::ForeignMessage>,
  pub optional_foreign_message_boxed: ::std::option::Option<::std::boxed::Box<ForeignMessage3>>,
  pub optional_foreign_message_nonnullable: ForeignMessage3,
  pub nested: TestMessage3_NestedMessage,
  pub nested_nullable: ::std::option::Option<TestMessage3_NestedMessage>,
  pub nested_repeated: ::std::vec::Vec<TestMessage3_NestedMessage>,
  pub fixed_length: [u8; 4],
  pub fixed_length_repeated: ::std::vec::Vec<[u8; 4]>,
  pub zero_or_fixed_length: Option<[u8; 4]>,
  pub zero_or_fixed_length_repeated: ::std::vec::Vec<Option<[u8; 4]>>,
  pub oneof_int: ::std::option::Option<TestMessage3_OneofInt>,
  pub oneof_foreign: ::std::option::Option<TestMessage3_OneofForeign>,
  pub oneof_zero: ::std::option::Option<TestMessage3_OneofZero>,
  pub oneof_null: ::std::option::Option<TestMessage3_OneofNull>,
  pub oneof_unset: ::std::option::Option<TestMessage3_OneofUnset>,
  pub oneof_primitives: ::std::option::Option<TestMessage3_OneofPrimitives>,
  pub oneof_empty_field: TestMessage3_OneofEmptyField,
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofInt {
  Int1(i32),
  Foreign1(ForeignMessage3),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofForeign {
  Int2(i32),
  Foreign2(ForeignMessage3),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofZero {
  Int3(i32),
  Foreign3(ForeignMessage3),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofNull {
  Int4(i32),
  Foreign4(ForeignMessage3),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofUnset {
  Int5(i32),
  Foreign5(ForeignMessage3),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofPrimitives {
  Int6(i32),
  Bool6(bool),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofEmptyField {
  A,
  B,
  C(i32),
}
impl ::std::default::Default for TestMessage3 {
  fn default() -> Self {
    TestMessage3 {
      optional_int32: ::std::default::Default::default(),
      optional_int64: ::std::default::Default::default(),
      optional_uint32: ::std::default::Default::default(),
      optional_uint64: ::std::default::Default::default(),
      optional_fixed64: ::std::default::Default::default(),
      optional_fixed32: ::std::default::Default::default(),
      optional_sfixed64: ::std::default::Default::default(),
      optional_sfixed32: ::std::default::Default::default(),
      optional_double: ::std::default::Default::default(),
      optional_bool: ::std::default::Default::default(),
      optional_string: ::std::default::Default::default(),
      optional_bytes: ::std::default::Default::default(),
      optional_float: ::std::default::Default::default(),
      optional_foreign_message: ::std::default::Default::default(),
      optional_nested_enum: ::std::default::Default::default(),
      optional_foreign_enum: ::std::default::Default::default(),
      repeated_int32: ::std::default::Default::default(),
      repeated_int64: ::std::default::Default::default(),
      repeated_uint32: ::std::default::Default::default(),
      repeated_uint64: ::std::default::Default::default(),
      repeated_fixed64: ::std::default::Default::default(),
      repeated_fixed32: ::std::default::Default::default(),
      repeated_sfixed64: ::std::default::Default::default(),
      repeated_sfixed32: ::std::default::Default::default(),
      repeated_double: ::std::default::Default::default(),
      repeated_bool: ::std::default::Default::default(),
      repeated_string: ::std::default::Default::default(),
      repeated_bytes: ::std::default::Default::default(),
      repeated_float: ::std::default::Default::default(),
      repeated_foreign_message: ::std::default::Default::default(),
      repeated_nested_enum: ::std::default::Default::default(),
      repeated_foreign_enum: ::std::default::Default::default(),
      proto2_msg: ::std::default::Default::default(),
      proto2_msg_empty: ::std::default::Default::default(),
      proto2_msg_missing: ::std::default::Default::default(),
      optional_foreign_message_boxed: ::std::default::Default::default(),
      optional_foreign_message_nonnullable: ::std::default::Default::default(),
      nested: ::std::default::Default::default(),
      nested_nullable: ::std::default::Default::default(),
      nested_repeated: ::std::default::Default::default(),
      fixed_length: ::std::default::Default::default(),
      fixed_length_repeated: ::std::default::Default::default(),
      zero_or_fixed_length: ::std::default::Default::default(),
      zero_or_fixed_length_repeated: ::std::default::Default::default(),
      oneof_int: None,
      oneof_foreign: None,
      oneof_zero: None,
      oneof_null: None,
      oneof_unset: None,
      oneof_primitives: None,
      oneof_empty_field: TestMessage3_OneofEmptyField::A,
    }
  }
}
lazy_static! {
  pub static ref TestMessage3_default: TestMessage3 = TestMessage3::default();
}
impl ::pb_jelly::Message for TestMessage3 {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut optional_int32_size = 0;
    if self.optional_int32 != <i32 as ::std::default::Default>::default() {
      let val = &self.optional_int32;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_int32_size += ::pb_jelly::wire_format::serialized_length(1);
      optional_int32_size += l;
    }
    size += optional_int32_size;
    let mut optional_int64_size = 0;
    if self.optional_int64 != <i64 as ::std::default::Default>::default() {
      let val = &self.optional_int64;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_int64_size += ::pb_jelly::wire_format::serialized_length(2);
      optional_int64_size += l;
    }
    size += optional_int64_size;
    let mut optional_uint32_size = 0;
    if self.optional_uint32 != <u32 as ::std::default::Default>::default() {
      let val = &self.optional_uint32;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_uint32_size += ::pb_jelly::wire_format::serialized_length(3);
      optional_uint32_size += l;
    }
    size += optional_uint32_size;
    let mut optional_uint64_size = 0;
    if self.optional_uint64 != <u64 as ::std::default::Default>::default() {
      let val = &self.optional_uint64;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_uint64_size += ::pb_jelly::wire_format::serialized_length(4);
      optional_uint64_size += l;
    }
    size += optional_uint64_size;
    let mut optional_fixed64_size = 0;
    if self.optional_fixed64 != <::pb_jelly::Fixed64 as ::std::default::Default>::default() {
      let val = &self.optional_fixed64;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_fixed64_size += ::pb_jelly::wire_format::serialized_length(8);
      optional_fixed64_size += l;
    }
    size += optional_fixed64_size;
    let mut optional_fixed32_size = 0;
    if self.optional_fixed32 != <::pb_jelly::Fixed32 as ::std::default::Default>::default() {
      let val = &self.optional_fixed32;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_fixed32_size += ::pb_jelly::wire_format::serialized_length(9);
      optional_fixed32_size += l;
    }
    size += optional_fixed32_size;
    let mut optional_sfixed64_size = 0;
    if self.optional_sfixed64 != <::pb_jelly::Sfixed64 as ::std::default::Default>::default() {
      let val = &self.optional_sfixed64;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_sfixed64_size += ::pb_jelly::wire_format::serialized_length(10);
      optional_sfixed64_size += l;
    }
    size += optional_sfixed64_size;
    let mut optional_sfixed32_size = 0;
    if self.optional_sfixed32 != <::pb_jelly::Sfixed32 as ::std::default::Default>::default() {
      let val = &self.optional_sfixed32;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_sfixed32_size += ::pb_jelly::wire_format::serialized_length(11);
      optional_sfixed32_size += l;
    }
    size += optional_sfixed32_size;
    let mut optional_double_size = 0;
    if self.optional_double != <f64 as ::std::default::Default>::default() {
      let val = &self.optional_double;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_double_size += ::pb_jelly::wire_format::serialized_length(12);
      optional_double_size += l;
    }
    size += optional_double_size;
    let mut optional_bool_size = 0;
    if self.optional_bool != <bool as ::std::default::Default>::default() {
      let val = &self.optional_bool;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_bool_size += ::pb_jelly::wire_format::serialized_length(13);
      optional_bool_size += l;
    }
    size += optional_bool_size;
    let mut optional_string_size = 0;
    if self.optional_string != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.optional_string;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_string_size += ::pb_jelly::wire_format::serialized_length(14);
      optional_string_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_string_size += l;
    }
    size += optional_string_size;
    let mut optional_bytes_size = 0;
    if self.optional_bytes != <::std::vec::Vec<u8> as ::std::default::Default>::default() {
      let val = &self.optional_bytes;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_bytes_size += ::pb_jelly::wire_format::serialized_length(15);
      optional_bytes_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_bytes_size += l;
    }
    size += optional_bytes_size;
    let mut optional_float_size = 0;
    if self.optional_float != <f32 as ::std::default::Default>::default() {
      let val = &self.optional_float;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_float_size += ::pb_jelly::wire_format::serialized_length(16);
      optional_float_size += l;
    }
    size += optional_float_size;
    let mut optional_foreign_message_size = 0;
    for val in &self.optional_foreign_message {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_foreign_message_size += ::pb_jelly::wire_format::serialized_length(19);
      optional_foreign_message_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_foreign_message_size += l;
    }
    size += optional_foreign_message_size;
    let mut optional_nested_enum_size = 0;
    if self.optional_nested_enum != <TestMessage3_NestedEnum3 as ::std::default::Default>::default() {
      let val = &self.optional_nested_enum;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_nested_enum_size += ::pb_jelly::wire_format::serialized_length(21);
      optional_nested_enum_size += l;
    }
    size += optional_nested_enum_size;
    let mut optional_foreign_enum_size = 0;
    if self.optional_foreign_enum != <ForeignEnum3 as ::std::default::Default>::default() {
      let val = &self.optional_foreign_enum;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_foreign_enum_size += ::pb_jelly::wire_format::serialized_length(22);
      optional_foreign_enum_size += l;
    }
    size += optional_foreign_enum_size;
    let mut repeated_int32_size = 0;
    for val in &self.repeated_int32 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_int32_size += l;
    }
    if !self.repeated_int32.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(31);
      size += ::pb_jelly::varint::serialized_length(repeated_int32_size as u64);
    }
    size += repeated_int32_size;
    let mut repeated_int64_size = 0;
    for val in &self.repeated_int64 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_int64_size += l;
    }
    if !self.repeated_int64.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(32);
      size += ::pb_jelly::varint::serialized_length(repeated_int64_size as u64);
    }
    size += repeated_int64_size;
    let mut repeated_uint32_size = 0;
    for val in &self.repeated_uint32 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_uint32_size += l;
    }
    if !self.repeated_uint32.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(33);
      size += ::pb_jelly::varint::serialized_length(repeated_uint32_size as u64);
    }
    size += repeated_uint32_size;
    let mut repeated_uint64_size = 0;
    for val in &self.repeated_uint64 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_uint64_size += l;
    }
    if !self.repeated_uint64.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(34);
      size += ::pb_jelly::varint::serialized_length(repeated_uint64_size as u64);
    }
    size += repeated_uint64_size;
    let mut repeated_fixed64_size = 0;
    for val in &self.repeated_fixed64 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_fixed64_size += l;
    }
    if !self.repeated_fixed64.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(38);
      size += ::pb_jelly::varint::serialized_length(repeated_fixed64_size as u64);
    }
    size += repeated_fixed64_size;
    let mut repeated_fixed32_size = 0;
    for val in &self.repeated_fixed32 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_fixed32_size += l;
    }
    if !self.repeated_fixed32.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(39);
      size += ::pb_jelly::varint::serialized_length(repeated_fixed32_size as u64);
    }
    size += repeated_fixed32_size;
    let mut repeated_sfixed64_size = 0;
    for val in &self.repeated_sfixed64 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_sfixed64_size += l;
    }
    if !self.repeated_sfixed64.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(40);
      size += ::pb_jelly::varint::serialized_length(repeated_sfixed64_size as u64);
    }
    size += repeated_sfixed64_size;
    let mut repeated_sfixed32_size = 0;
    for val in &self.repeated_sfixed32 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_sfixed32_size += l;
    }
    if !self.repeated_sfixed32.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(41);
      size += ::pb_jelly::varint::serialized_length(repeated_sfixed32_size as u64);
    }
    size += repeated_sfixed32_size;
    let mut repeated_double_size = 0;
    for val in &self.repeated_double {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_double_size += l;
    }
    if !self.repeated_double.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(42);
      size += ::pb_jelly::varint::serialized_length(repeated_double_size as u64);
    }
    size += repeated_double_size;
    let mut repeated_bool_size = 0;
    for val in &self.repeated_bool {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_bool_size += l;
    }
    if !self.repeated_bool.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(43);
      size += ::pb_jelly::varint::serialized_length(repeated_bool_size as u64);
    }
    size += repeated_bool_size;
    let mut repeated_string_size = 0;
    for val in &self.repeated_string {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_string_size += ::pb_jelly::wire_format::serialized_length(44);
      repeated_string_size += ::pb_jelly::varint::serialized_length(l as u64);
      repeated_string_size += l;
    }
    size += repeated_string_size;
    let mut repeated_bytes_size = 0;
    for val in &self.repeated_bytes {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_bytes_size += ::pb_jelly::wire_format::serialized_length(45);
      repeated_bytes_size += ::pb_jelly::varint::serialized_length(l as u64);
      repeated_bytes_size += l;
    }
    size += repeated_bytes_size;
    let mut repeated_float_size = 0;
    for val in &self.repeated_float {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_float_size += l;
    }
    if !self.repeated_float.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(46);
      size += ::pb_jelly::varint::serialized_length(repeated_float_size as u64);
    }
    size += repeated_float_size;
    let mut repeated_foreign_message_size = 0;
    for val in &self.repeated_foreign_message {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_foreign_message_size += ::pb_jelly::wire_format::serialized_length(49);
      repeated_foreign_message_size += ::pb_jelly::varint::serialized_length(l as u64);
      repeated_foreign_message_size += l;
    }
    size += repeated_foreign_message_size;
    let mut repeated_nested_enum_size = 0;
    for val in &self.repeated_nested_enum {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_nested_enum_size += l;
    }
    if !self.repeated_nested_enum.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(51);
      size += ::pb_jelly::varint::serialized_length(repeated_nested_enum_size as u64);
    }
    size += repeated_nested_enum_size;
    let mut repeated_foreign_enum_size = 0;
    for val in &self.repeated_foreign_enum {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_foreign_enum_size += l;
    }
    if !self.repeated_foreign_enum.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(52);
      size += ::pb_jelly::varint::serialized_length(repeated_foreign_enum_size as u64);
    }
    size += repeated_foreign_enum_size;
    let mut proto2_msg_size = 0;
    for val in &self.proto2_msg {
      let l = ::pb_jelly::Message::compute_size(val);
      proto2_msg_size += ::pb_jelly::wire_format::serialized_length(53);
      proto2_msg_size += ::pb_jelly::varint::serialized_length(l as u64);
      proto2_msg_size += l;
    }
    size += proto2_msg_size;
    let mut proto2_msg_empty_size = 0;
    for val in &self.proto2_msg_empty {
      let l = ::pb_jelly::Message::compute_size(val);
      proto2_msg_empty_size += ::pb_jelly::wire_format::serialized_length(54);
      proto2_msg_empty_size += ::pb_jelly::varint::serialized_length(l as u64);
      proto2_msg_empty_size += l;
    }
    size += proto2_msg_empty_size;
    let mut proto2_msg_missing_size = 0;
    for val in &self.proto2_msg_missing {
      let l = ::pb_jelly::Message::compute_size(val);
      proto2_msg_missing_size += ::pb_jelly::wire_format::serialized_length(55);
      proto2_msg_missing_size += ::pb_jelly::varint::serialized_length(l as u64);
      proto2_msg_missing_size += l;
    }
    size += proto2_msg_missing_size;
    let mut optional_foreign_message_boxed_size = 0;
    for val in &self.optional_foreign_message_boxed {
      let val = &**val;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_foreign_message_boxed_size += ::pb_jelly::wire_format::serialized_length(56);
      optional_foreign_message_boxed_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_foreign_message_boxed_size += l;
    }
    size += optional_foreign_message_boxed_size;
    let mut optional_foreign_message_nonnullable_size = 0;
     {
      let val = &self.optional_foreign_message_nonnullable;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_foreign_message_nonnullable_size += ::pb_jelly::wire_format::serialized_length(69);
      optional_foreign_message_nonnullable_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_foreign_message_nonnullable_size += l;
    }
    size += optional_foreign_message_nonnullable_size;
    let mut int1_size = 0;
    if let Some(TestMessage3_OneofInt::Int1(ref val)) = self.oneof_int {
      let l = ::pb_jelly::Message::compute_size(val);
      int1_size += ::pb_jelly::wire_format::serialized_length(57);
      int1_size += l;
    }
    size += int1_size;
    let mut foreign1_size = 0;
    if let Some(TestMessage3_OneofInt::Foreign1(ref val)) = self.oneof_int {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign1_size += ::pb_jelly::wire_format::serialized_length(58);
      foreign1_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign1_size += l;
    }
    size += foreign1_size;
    let mut int2_size = 0;
    if let Some(TestMessage3_OneofForeign::Int2(ref val)) = self.oneof_foreign {
      let l = ::pb_jelly::Message::compute_size(val);
      int2_size += ::pb_jelly::wire_format::serialized_length(59);
      int2_size += l;
    }
    size += int2_size;
    let mut foreign2_size = 0;
    if let Some(TestMessage3_OneofForeign::Foreign2(ref val)) = self.oneof_foreign {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign2_size += ::pb_jelly::wire_format::serialized_length(60);
      foreign2_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign2_size += l;
    }
    size += foreign2_size;
    let mut int3_size = 0;
    if let Some(TestMessage3_OneofZero::Int3(ref val)) = self.oneof_zero {
      let l = ::pb_jelly::Message::compute_size(val);
      int3_size += ::pb_jelly::wire_format::serialized_length(61);
      int3_size += l;
    }
    size += int3_size;
    let mut foreign3_size = 0;
    if let Some(TestMessage3_OneofZero::Foreign3(ref val)) = self.oneof_zero {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign3_size += ::pb_jelly::wire_format::serialized_length(62);
      foreign3_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign3_size += l;
    }
    size += foreign3_size;
    let mut int4_size = 0;
    if let Some(TestMessage3_OneofNull::Int4(ref val)) = self.oneof_null {
      let l = ::pb_jelly::Message::compute_size(val);
      int4_size += ::pb_jelly::wire_format::serialized_length(63);
      int4_size += l;
    }
    size += int4_size;
    let mut foreign4_size = 0;
    if let Some(TestMessage3_OneofNull::Foreign4(ref val)) = self.oneof_null {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign4_size += ::pb_jelly::wire_format::serialized_length(64);
      foreign4_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign4_size += l;
    }
    size += foreign4_size;
    let mut int5_size = 0;
    if let Some(TestMessage3_OneofUnset::Int5(ref val)) = self.oneof_unset {
      let l = ::pb_jelly::Message::compute_size(val);
      int5_size += ::pb_jelly::wire_format::serialized_length(65);
      int5_size += l;
    }
    size += int5_size;
    let mut foreign5_size = 0;
    if let Some(TestMessage3_OneofUnset::Foreign5(ref val)) = self.oneof_unset {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign5_size += ::pb_jelly::wire_format::serialized_length(66);
      foreign5_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign5_size += l;
    }
    size += foreign5_size;
    let mut int6_size = 0;
    if let Some(TestMessage3_OneofPrimitives::Int6(ref val)) = self.oneof_primitives {
      let l = ::pb_jelly::Message::compute_size(val);
      int6_size += ::pb_jelly::wire_format::serialized_length(67);
      int6_size += l;
    }
    size += int6_size;
    let mut bool6_size = 0;
    if let Some(TestMessage3_OneofPrimitives::Bool6(ref val)) = self.oneof_primitives {
      let l = ::pb_jelly::Message::compute_size(val);
      bool6_size += ::pb_jelly::wire_format::serialized_length(68);
      bool6_size += l;
    }
    size += bool6_size;
    let mut a_size = 0;
    if let TestMessage3_OneofEmptyField::A = self.oneof_empty_field {
      let val: &::proto_google::empty::Empty = &::std::default::Default::default();
      let l = ::pb_jelly::Message::compute_size(val);
      a_size += ::pb_jelly::wire_format::serialized_length(70);
      a_size += ::pb_jelly::varint::serialized_length(l as u64);
      a_size += l;
    }
    size += a_size;
    let mut b_size = 0;
    if let TestMessage3_OneofEmptyField::B = self.oneof_empty_field {
      let val: &::proto_google::empty::Empty = &::std::default::Default::default();
      let l = ::pb_jelly::Message::compute_size(val);
      b_size += ::pb_jelly::wire_format::serialized_length(71);
      b_size += ::pb_jelly::varint::serialized_length(l as u64);
      b_size += l;
    }
    size += b_size;
    let mut c_size = 0;
    if let TestMessage3_OneofEmptyField::C(ref val) = self.oneof_empty_field {
      let l = ::pb_jelly::Message::compute_size(val);
      c_size += ::pb_jelly::wire_format::serialized_length(72);
      c_size += l;
    }
    size += c_size;
    let mut nested_size = 0;
     {
      let val = &self.nested;
      let l = ::pb_jelly::Message::compute_size(val);
      nested_size += ::pb_jelly::wire_format::serialized_length(73);
      nested_size += ::pb_jelly::varint::serialized_length(l as u64);
      nested_size += l;
    }
    size += nested_size;
    let mut nested_nullable_size = 0;
    for val in &self.nested_nullable {
      let l = ::pb_jelly::Message::compute_size(val);
      nested_nullable_size += ::pb_jelly::wire_format::serialized_length(74);
      nested_nullable_size += ::pb_jelly::varint::serialized_length(l as u64);
      nested_nullable_size += l;
    }
    size += nested_nullable_size;
    let mut nested_repeated_size = 0;
    for val in &self.nested_repeated {
      let l = ::pb_jelly::Message::compute_size(val);
      nested_repeated_size += ::pb_jelly::wire_format::serialized_length(75);
      nested_repeated_size += ::pb_jelly::varint::serialized_length(l as u64);
      nested_repeated_size += l;
    }
    size += nested_repeated_size;
    let mut fixed_length_size = 0;
    if self.fixed_length != <[u8; 4] as ::std::default::Default>::default() {
      let val = &self.fixed_length;
      let l = ::pb_jelly::Message::compute_size(val);
      fixed_length_size += ::pb_jelly::wire_format::serialized_length(76);
      fixed_length_size += ::pb_jelly::varint::serialized_length(l as u64);
      fixed_length_size += l;
    }
    size += fixed_length_size;
    let mut fixed_length_repeated_size = 0;
    for val in &self.fixed_length_repeated {
      let l = ::pb_jelly::Message::compute_size(val);
      fixed_length_repeated_size += ::pb_jelly::wire_format::serialized_length(77);
      fixed_length_repeated_size += ::pb_jelly::varint::serialized_length(l as u64);
      fixed_length_repeated_size += l;
    }
    size += fixed_length_repeated_size;
    let mut zero_or_fixed_length_size = 0;
    if self.zero_or_fixed_length != <Option<[u8; 4]> as ::std::default::Default>::default() {
      let val = &self.zero_or_fixed_length;
      let l = ::pb_jelly::Message::compute_size(val);
      zero_or_fixed_length_size += ::pb_jelly::wire_format::serialized_length(78);
      zero_or_fixed_length_size += ::pb_jelly::varint::serialized_length(l as u64);
      zero_or_fixed_length_size += l;
    }
    size += zero_or_fixed_length_size;
    let mut zero_or_fixed_length_repeated_size = 0;
    for val in &self.zero_or_fixed_length_repeated {
      let l = ::pb_jelly::Message::compute_size(val);
      zero_or_fixed_length_repeated_size += ::pb_jelly::wire_format::serialized_length(79);
      zero_or_fixed_length_repeated_size += ::pb_jelly::varint::serialized_length(l as u64);
      zero_or_fixed_length_repeated_size += l;
    }
    size += zero_or_fixed_length_repeated_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if self.optional_int32 != <i32 as ::std::default::Default>::default() {
      let val = &self.optional_int32;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_int64 != <i64 as ::std::default::Default>::default() {
      let val = &self.optional_int64;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_uint32 != <u32 as ::std::default::Default>::default() {
      let val = &self.optional_uint32;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_uint64 != <u64 as ::std::default::Default>::default() {
      let val = &self.optional_uint64;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_fixed64 != <::pb_jelly::Fixed64 as ::std::default::Default>::default() {
      let val = &self.optional_fixed64;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_fixed32 != <::pb_jelly::Fixed32 as ::std::default::Default>::default() {
      let val = &self.optional_fixed32;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_sfixed64 != <::pb_jelly::Sfixed64 as ::std::default::Default>::default() {
      let val = &self.optional_sfixed64;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_sfixed32 != <::pb_jelly::Sfixed32 as ::std::default::Default>::default() {
      let val = &self.optional_sfixed32;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_double != <f64 as ::std::default::Default>::default() {
      let val = &self.optional_double;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_bool != <bool as ::std::default::Default>::default() {
      let val = &self.optional_bool;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_string != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.optional_string;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_bytes != <::std::vec::Vec<u8> as ::std::default::Default>::default() {
      let val = &self.optional_bytes;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_float != <f32 as ::std::default::Default>::default() {
      let val = &self.optional_float;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.optional_foreign_message {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_nested_enum != <TestMessage3_NestedEnum3 as ::std::default::Default>::default() {
      let val = &self.optional_nested_enum;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.optional_foreign_enum != <ForeignEnum3 as ::std::default::Default>::default() {
      let val = &self.optional_foreign_enum;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_int32 {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_int64 {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_uint32 {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_uint64 {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_fixed64 {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_fixed32 {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_sfixed64 {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_sfixed32 {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_double {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_bool {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_string {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_bytes {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_float {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_foreign_message {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_nested_enum {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.repeated_foreign_enum {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.proto2_msg {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.proto2_msg_empty {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.proto2_msg_missing {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.optional_foreign_message_boxed {
      let val = &**val;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
     {
      let val = &self.optional_foreign_message_nonnullable;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(TestMessage3_OneofInt::Int1(ref val)) = self.oneof_int {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(TestMessage3_OneofInt::Foreign1(ref val)) = self.oneof_int {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(TestMessage3_OneofForeign::Int2(ref val)) = self.oneof_foreign {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(TestMessage3_OneofForeign::Foreign2(ref val)) = self.oneof_foreign {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(TestMessage3_OneofZero::Int3(ref val)) = self.oneof_zero {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(TestMessage3_OneofZero::Foreign3(ref val)) = self.oneof_zero {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(TestMessage3_OneofNull::Int4(ref val)) = self.oneof_null {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(TestMessage3_OneofNull::Foreign4(ref val)) = self.oneof_null {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(TestMessage3_OneofUnset::Int5(ref val)) = self.oneof_unset {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(TestMessage3_OneofUnset::Foreign5(ref val)) = self.oneof_unset {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(TestMessage3_OneofPrimitives::Int6(ref val)) = self.oneof_primitives {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let Some(TestMessage3_OneofPrimitives::Bool6(ref val)) = self.oneof_primitives {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let TestMessage3_OneofEmptyField::A = self.oneof_empty_field {
      let val: &::proto_google::empty::Empty = &::std::default::Default::default();
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let TestMessage3_OneofEmptyField::B = self.oneof_empty_field {
      let val: &::proto_google::empty::Empty = &::std::default::Default::default();
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let TestMessage3_OneofEmptyField::C(ref val) = self.oneof_empty_field {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
     {
      let val = &self.nested;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.nested_nullable {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.nested_repeated {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.fixed_length != <[u8; 4] as ::std::default::Default>::default() {
      let val = &self.fixed_length;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.fixed_length_repeated {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.zero_or_fixed_length != <Option<[u8; 4]> as ::std::default::Default>::default() {
      let val = &self.zero_or_fixed_length;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.zero_or_fixed_length_repeated {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if self.optional_int32 != <i32 as ::std::default::Default>::default() {
      let val = &self.optional_int32;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_int64 != <i64 as ::std::default::Default>::default() {
      let val = &self.optional_int64;
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_uint32 != <u32 as ::std::default::Default>::default() {
      let val = &self.optional_uint32;
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_uint64 != <u64 as ::std::default::Default>::default() {
      let val = &self.optional_uint64;
      ::pb_jelly::wire_format::write(4, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_fixed64 != <::pb_jelly::Fixed64 as ::std::default::Default>::default() {
      let val = &self.optional_fixed64;
      ::pb_jelly::wire_format::write(8, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_fixed32 != <::pb_jelly::Fixed32 as ::std::default::Default>::default() {
      let val = &self.optional_fixed32;
      ::pb_jelly::wire_format::write(9, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_sfixed64 != <::pb_jelly::Sfixed64 as ::std::default::Default>::default() {
      let val = &self.optional_sfixed64;
      ::pb_jelly::wire_format::write(10, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_sfixed32 != <::pb_jelly::Sfixed32 as ::std::default::Default>::default() {
      let val = &self.optional_sfixed32;
      ::pb_jelly::wire_format::write(11, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_double != <f64 as ::std::default::Default>::default() {
      let val = &self.optional_double;
      ::pb_jelly::wire_format::write(12, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_bool != <bool as ::std::default::Default>::default() {
      let val = &self.optional_bool;
      ::pb_jelly::wire_format::write(13, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_string != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.optional_string;
      ::pb_jelly::wire_format::write(14, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_bytes != <::std::vec::Vec<u8> as ::std::default::Default>::default() {
      let val = &self.optional_bytes;
      ::pb_jelly::wire_format::write(15, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_float != <f32 as ::std::default::Default>::default() {
      let val = &self.optional_float;
      ::pb_jelly::wire_format::write(16, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.optional_foreign_message {
      ::pb_jelly::wire_format::write(19, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_nested_enum != <TestMessage3_NestedEnum3 as ::std::default::Default>::default() {
      let val = &self.optional_nested_enum;
      ::pb_jelly::wire_format::write(21, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.optional_foreign_enum != <ForeignEnum3 as ::std::default::Default>::default() {
      let val = &self.optional_foreign_enum;
      ::pb_jelly::wire_format::write(22, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_int32.is_empty() {
      let mut size = 0;
      for val in &self.repeated_int32 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(31, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_int32 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_int64.is_empty() {
      let mut size = 0;
      for val in &self.repeated_int64 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(32, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_int64 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_uint32.is_empty() {
      let mut size = 0;
      for val in &self.repeated_uint32 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(33, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_uint32 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_uint64.is_empty() {
      let mut size = 0;
      for val in &self.repeated_uint64 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(34, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_uint64 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_fixed64.is_empty() {
      let mut size = 0;
      for val in &self.repeated_fixed64 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(38, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_fixed64 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_fixed32.is_empty() {
      let mut size = 0;
      for val in &self.repeated_fixed32 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(39, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_fixed32 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_sfixed64.is_empty() {
      let mut size = 0;
      for val in &self.repeated_sfixed64 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(40, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_sfixed64 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_sfixed32.is_empty() {
      let mut size = 0;
      for val in &self.repeated_sfixed32 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(41, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_sfixed32 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_double.is_empty() {
      let mut size = 0;
      for val in &self.repeated_double {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(42, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_double {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_bool.is_empty() {
      let mut size = 0;
      for val in &self.repeated_bool {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(43, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_bool {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_string {
      ::pb_jelly::wire_format::write(44, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_bytes {
      ::pb_jelly::wire_format::write(45, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_float.is_empty() {
      let mut size = 0;
      for val in &self.repeated_float {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(46, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_float {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_foreign_message {
      ::pb_jelly::wire_format::write(49, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_nested_enum.is_empty() {
      let mut size = 0;
      for val in &self.repeated_nested_enum {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(51, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_nested_enum {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_foreign_enum.is_empty() {
      let mut size = 0;
      for val in &self.repeated_foreign_enum {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(52, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_foreign_enum {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.proto2_msg {
      ::pb_jelly::wire_format::write(53, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.proto2_msg_empty {
      ::pb_jelly::wire_format::write(54, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.proto2_msg_missing {
      ::pb_jelly::wire_format::write(55, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.optional_foreign_message_boxed {
      let val = &**val;
      ::pb_jelly::wire_format::write(56, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofInt::Int1(ref val)) = self.oneof_int {
      ::pb_jelly::wire_format::write(57, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofInt::Foreign1(ref val)) = self.oneof_int {
      ::pb_jelly::wire_format::write(58, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofForeign::Int2(ref val)) = self.oneof_foreign {
      ::pb_jelly::wire_format::write(59, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofForeign::Foreign2(ref val)) = self.oneof_foreign {
      ::pb_jelly::wire_format::write(60, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofZero::Int3(ref val)) = self.oneof_zero {
      ::pb_jelly::wire_format::write(61, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofZero::Foreign3(ref val)) = self.oneof_zero {
      ::pb_jelly::wire_format::write(62, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofNull::Int4(ref val)) = self.oneof_null {
      ::pb_jelly::wire_format::write(63, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofNull::Foreign4(ref val)) = self.oneof_null {
      ::pb_jelly::wire_format::write(64, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofUnset::Int5(ref val)) = self.oneof_unset {
      ::pb_jelly::wire_format::write(65, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofUnset::Foreign5(ref val)) = self.oneof_unset {
      ::pb_jelly::wire_format::write(66, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofPrimitives::Int6(ref val)) = self.oneof_primitives {
      ::pb_jelly::wire_format::write(67, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofPrimitives::Bool6(ref val)) = self.oneof_primitives {
      ::pb_jelly::wire_format::write(68, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
     {
      let val = &self.optional_foreign_message_nonnullable;
      ::pb_jelly::wire_format::write(69, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3_OneofEmptyField::A = self.oneof_empty_field {
      let val: &::proto_google::empty::Empty = &::std::default::Default::default();
      ::pb_jelly::wire_format::write(70, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3_OneofEmptyField::B = self.oneof_empty_field {
      let val: &::proto_google::empty::Empty = &::std::default::Default::default();
      ::pb_jelly::wire_format::write(71, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3_OneofEmptyField::C(ref val) = self.oneof_empty_field {
      ::pb_jelly::wire_format::write(72, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
     {
      let val = &self.nested;
      ::pb_jelly::wire_format::write(73, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.nested_nullable {
      ::pb_jelly::wire_format::write(74, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.nested_repeated {
      ::pb_jelly::wire_format::write(75, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.fixed_length != <[u8; 4] as ::std::default::Default>::default() {
      let val = &self.fixed_length;
      ::pb_jelly::wire_format::write(76, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.fixed_length_repeated {
      ::pb_jelly::wire_format::write(77, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.zero_or_fixed_length != <Option<[u8; 4]> as ::std::default::Default>::default() {
      let val = &self.zero_or_fixed_length;
      ::pb_jelly::wire_format::write(78, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.zero_or_fixed_length_repeated {
      ::pb_jelly::wire_format::write(79, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_oneof_empty_field: ::std::option::Option<TestMessage3_OneofEmptyField> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 1)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_int32 = val;
        }
        2 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 2)?;
          let mut val: i64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_int64 = val;
        }
        3 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 3)?;
          let mut val: u32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_uint32 = val;
        }
        4 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 4)?;
          let mut val: u64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_uint64 = val;
        }
        8 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage3", 8)?;
          let mut val: ::pb_jelly::Fixed64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_fixed64 = val;
        }
        9 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage3", 9)?;
          let mut val: ::pb_jelly::Fixed32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_fixed32 = val;
        }
        10 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage3", 10)?;
          let mut val: ::pb_jelly::Sfixed64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_sfixed64 = val;
        }
        11 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage3", 11)?;
          let mut val: ::pb_jelly::Sfixed32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_sfixed32 = val;
        }
        12 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage3", 12)?;
          let mut val: f64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_double = val;
        }
        13 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 13)?;
          let mut val: bool = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_bool = val;
        }
        14 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 14)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.optional_string = val;
        }
        15 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 15)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::vec::Vec<u8> = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.optional_bytes = val;
        }
        16 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage3", 16)?;
          let mut val: f32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_float = val;
        }
        19 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 19)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ForeignMessage3 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.optional_foreign_message = Some(val);
        }
        21 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 21)?;
          let mut val: TestMessage3_NestedEnum3 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_nested_enum = val;
        }
        22 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 22)?;
          let mut val: ForeignEnum3 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.optional_foreign_enum = val;
        }
        31 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: i32 = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_int32.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 31)?;
              let mut val: i32 = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_int32.push(val);
            }
          }
        }
        32 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: i64 = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_int64.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 32)?;
              let mut val: i64 = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_int64.push(val);
            }
          }
        }
        33 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: u32 = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_uint32.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 33)?;
              let mut val: u32 = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_uint32.push(val);
            }
          }
        }
        34 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: u64 = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_uint64.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 34)?;
              let mut val: u64 = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_uint64.push(val);
            }
          }
        }
        38 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: ::pb_jelly::Fixed64 = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_fixed64.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage3", 38)?;
              let mut val: ::pb_jelly::Fixed64 = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_fixed64.push(val);
            }
          }
        }
        39 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: ::pb_jelly::Fixed32 = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_fixed32.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage3", 39)?;
              let mut val: ::pb_jelly::Fixed32 = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_fixed32.push(val);
            }
          }
        }
        40 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: ::pb_jelly::Sfixed64 = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_sfixed64.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage3", 40)?;
              let mut val: ::pb_jelly::Sfixed64 = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_sfixed64.push(val);
            }
          }
        }
        41 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: ::pb_jelly::Sfixed32 = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_sfixed32.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage3", 41)?;
              let mut val: ::pb_jelly::Sfixed32 = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_sfixed32.push(val);
            }
          }
        }
        42 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: f64 = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_double.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage3", 42)?;
              let mut val: f64 = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_double.push(val);
            }
          }
        }
        43 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: bool = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_bool.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 43)?;
              let mut val: bool = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_bool.push(val);
            }
          }
        }
        44 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 44)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.repeated_string.push(val);
        }
        45 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 45)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::vec::Vec<u8> = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.repeated_bytes.push(val);
        }
        46 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: f32 = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_float.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage3", 46)?;
              let mut val: f32 = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_float.push(val);
            }
          }
        }
        49 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 49)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ForeignMessage3 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.repeated_foreign_message.push(val);
        }
        51 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: TestMessage3_NestedEnum3 = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_nested_enum.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 51)?;
              let mut val: TestMessage3_NestedEnum3 = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_nested_enum.push(val);
            }
          }
        }
        52 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: ForeignEnum3 = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.repeated_foreign_enum.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 52)?;
              let mut val: ForeignEnum3 = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.repeated_foreign_enum.push(val);
            }
          }
        }
        53 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 53)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: super::pbtest2::ForeignMessage = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.proto2_msg = Some(val);
        }
        54 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 54)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: super::pbtest2::ForeignMessage = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.proto2_msg_empty = Some(val);
        }
        55 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 55)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: super::pbtest2::ForeignMessage = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.proto2_msg_missing = Some(val);
        }
        56 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 56)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ForeignMessage3 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.optional_foreign_message_boxed = Some(Box::new(val));
        }
        69 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 69)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ForeignMessage3 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.optional_foreign_message_nonnullable = val;
        }
        57 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 57)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.oneof_int = Some(TestMessage3_OneofInt::Int1(val));
        }
        58 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 58)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ForeignMessage3 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.oneof_int = Some(TestMessage3_OneofInt::Foreign1(val));
        }
        59 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 59)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.oneof_foreign = Some(TestMessage3_OneofForeign::Int2(val));
        }
        60 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 60)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ForeignMessage3 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.oneof_foreign = Some(TestMessage3_OneofForeign::Foreign2(val));
        }
        61 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 61)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.oneof_zero = Some(TestMessage3_OneofZero::Int3(val));
        }
        62 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 62)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ForeignMessage3 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.oneof_zero = Some(TestMessage3_OneofZero::Foreign3(val));
        }
        63 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 63)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.oneof_null = Some(TestMessage3_OneofNull::Int4(val));
        }
        64 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 64)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ForeignMessage3 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.oneof_null = Some(TestMessage3_OneofNull::Foreign4(val));
        }
        65 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 65)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.oneof_unset = Some(TestMessage3_OneofUnset::Int5(val));
        }
        66 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 66)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ForeignMessage3 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.oneof_unset = Some(TestMessage3_OneofUnset::Foreign5(val));
        }
        67 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 67)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.oneof_primitives = Some(TestMessage3_OneofPrimitives::Int6(val));
        }
        68 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 68)?;
          let mut val: bool = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.oneof_primitives = Some(TestMessage3_OneofPrimitives::Bool6(val));
        }
        70 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 70)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::proto_google::empty::Empty = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          oneof_oneof_empty_field = Some(TestMessage3_OneofEmptyField::A);
        }
        71 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 71)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::proto_google::empty::Empty = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          oneof_oneof_empty_field = Some(TestMessage3_OneofEmptyField::B);
        }
        72 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 72)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          oneof_oneof_empty_field = Some(TestMessage3_OneofEmptyField::C(val));
        }
        73 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 73)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: TestMessage3_NestedMessage = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.nested = val;
        }
        74 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 74)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: TestMessage3_NestedMessage = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.nested_nullable = Some(val);
        }
        75 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 75)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: TestMessage3_NestedMessage = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.nested_repeated.push(val);
        }
        76 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 76)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: [u8; 4] = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.fixed_length = val;
        }
        77 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 77)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: [u8; 4] = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.fixed_length_repeated.push(val);
        }
        78 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 78)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: Option<[u8; 4]> = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.zero_or_fixed_length = val;
        }
        79 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3", 79)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: Option<[u8; 4]> = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.zero_or_fixed_length_repeated.push(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_oneof_empty_field {
      Some(v) => self.oneof_empty_field = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'oneof_empty_field' while parsing message pbtest.TestMessage3")),
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for TestMessage3 {
  const NAME: &'static str = "TestMessage3";
  const FULL_NAME: &'static str = "pbtest.TestMessage3";
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3_NestedMessage {
  pub nested_oneof: TestMessage3_NestedMessage_NestedOneof,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TestMessage3_NestedMessage_NestedOneof {
  F(TestMessage3_NestedMessage_File),
  D(TestMessage3_NestedMessage_Dir),
  E(TestMessage3_NestedMessage_Enum),
  N(TestMessage3_NestedMessage_NonNullableEnum),
}
impl ::std::default::Default for TestMessage3_NestedMessage {
  fn default() -> Self {
    TestMessage3_NestedMessage {
      nested_oneof: TestMessage3_NestedMessage_NestedOneof::F(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3_NestedMessage_default: TestMessage3_NestedMessage = TestMessage3_NestedMessage::default();
}
impl ::pb_jelly::Message for TestMessage3_NestedMessage {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut f_size = 0;
    if let TestMessage3_NestedMessage_NestedOneof::F(ref val) = self.nested_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      f_size += ::pb_jelly::wire_format::serialized_length(3);
      f_size += ::pb_jelly::varint::serialized_length(l as u64);
      f_size += l;
    }
    size += f_size;
    let mut d_size = 0;
    if let TestMessage3_NestedMessage_NestedOneof::D(ref val) = self.nested_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      d_size += ::pb_jelly::wire_format::serialized_length(4);
      d_size += ::pb_jelly::varint::serialized_length(l as u64);
      d_size += l;
    }
    size += d_size;
    let mut e_size = 0;
    if let TestMessage3_NestedMessage_NestedOneof::E(ref val) = self.nested_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      e_size += ::pb_jelly::wire_format::serialized_length(5);
      e_size += l;
    }
    size += e_size;
    let mut n_size = 0;
    if let TestMessage3_NestedMessage_NestedOneof::N(ref val) = self.nested_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      n_size += ::pb_jelly::wire_format::serialized_length(6);
      n_size += l;
    }
    size += n_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if let TestMessage3_NestedMessage_NestedOneof::F(ref val) = self.nested_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let TestMessage3_NestedMessage_NestedOneof::D(ref val) = self.nested_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let TestMessage3_NestedMessage_NestedOneof::E(ref val) = self.nested_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let TestMessage3_NestedMessage_NestedOneof::N(ref val) = self.nested_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let TestMessage3_NestedMessage_NestedOneof::F(ref val) = self.nested_oneof {
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3_NestedMessage_NestedOneof::D(ref val) = self.nested_oneof {
      ::pb_jelly::wire_format::write(4, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3_NestedMessage_NestedOneof::E(ref val) = self.nested_oneof {
      ::pb_jelly::wire_format::write(5, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3_NestedMessage_NestedOneof::N(ref val) = self.nested_oneof {
      ::pb_jelly::wire_format::write(6, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_nested_oneof: ::std::option::Option<TestMessage3_NestedMessage_NestedOneof> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        3 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3_NestedMessage", 3)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: TestMessage3_NestedMessage_File = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          oneof_nested_oneof = Some(TestMessage3_NestedMessage_NestedOneof::F(val));
        }
        4 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3_NestedMessage", 4)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: TestMessage3_NestedMessage_Dir = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          oneof_nested_oneof = Some(TestMessage3_NestedMessage_NestedOneof::D(val));
        }
        5 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3_NestedMessage", 5)?;
          let mut val: TestMessage3_NestedMessage_Enum = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          oneof_nested_oneof = Some(TestMessage3_NestedMessage_NestedOneof::E(val));
        }
        6 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3_NestedMessage", 6)?;
          let mut val: TestMessage3_NestedMessage_NonNullableEnum = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          oneof_nested_oneof = Some(TestMessage3_NestedMessage_NestedOneof::N(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_nested_oneof {
      Some(v) => self.nested_oneof = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'nested_oneof' while parsing message pbtest.NestedMessage")),
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for TestMessage3_NestedMessage {
  const NAME: &'static str = "TestMessage3_NestedMessage";
  const FULL_NAME: &'static str = "pbtest.TestMessage3_NestedMessage";
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3_NestedMessage_File {
  pub blocklist: ::std::vec::Vec<::std::vec::Vec<u8>>,
  pub size: u32,
}
impl ::std::default::Default for TestMessage3_NestedMessage_File {
  fn default() -> Self {
    TestMessage3_NestedMessage_File {
      blocklist: ::std::default::Default::default(),
      size: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3_NestedMessage_File_default: TestMessage3_NestedMessage_File = TestMessage3_NestedMessage_File::default();
}
impl ::pb_jelly::Message for TestMessage3_NestedMessage_File {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut blocklist_size = 0;
    for val in &self.blocklist {
      let l = ::pb_jelly::Message::compute_size(val);
      blocklist_size += ::pb_jelly::wire_format::serialized_length(1);
      blocklist_size += ::pb_jelly::varint::serialized_length(l as u64);
      blocklist_size += l;
    }
    size += blocklist_size;
    let mut size_size = 0;
    if self.size != <u32 as ::std::default::Default>::default() {
      let val = &self.size;
      let l = ::pb_jelly::Message::compute_size(val);
      size_size += ::pb_jelly::wire_format::serialized_length(2);
      size_size += l;
    }
    size += size_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    for val in &self.blocklist {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.size != <u32 as ::std::default::Default>::default() {
      let val = &self.size;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.blocklist {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.size != <u32 as ::std::default::Default>::default() {
      let val = &self.size;
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3_NestedMessage_File", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::vec::Vec<u8> = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.blocklist.push(val);
        }
        2 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3_NestedMessage_File", 2)?;
          let mut val: u32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.size = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for TestMessage3_NestedMessage_File {
  const NAME: &'static str = "TestMessage3_NestedMessage_File";
  const FULL_NAME: &'static str = "pbtest.TestMessage3_NestedMessage_File";
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3_NestedMessage_Dir {
}
impl ::std::default::Default for TestMessage3_NestedMessage_Dir {
  fn default() -> Self {
    TestMessage3_NestedMessage_Dir {
    }
  }
}
lazy_static! {
  pub static ref TestMessage3_NestedMessage_Dir_default: TestMessage3_NestedMessage_Dir = TestMessage3_NestedMessage_Dir::default();
}
impl ::pb_jelly::Message for TestMessage3_NestedMessage_Dir {
  fn compute_size(&self) -> usize  {
    0
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    0
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for TestMessage3_NestedMessage_Dir {
  const NAME: &'static str = "TestMessage3_NestedMessage_Dir";
  const FULL_NAME: &'static str = "pbtest.TestMessage3_NestedMessage_Dir";
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3NonNullableOneof {
  pub other_field: u64,
  pub non_nullable_oneof: TestMessage3NonNullableOneof_NonNullableOneof,
}
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TestMessage3NonNullableOneof_NonNullableOneof {
  A(i32),
  B(i32),
}
impl ::std::default::Default for TestMessage3NonNullableOneof {
  fn default() -> Self {
    TestMessage3NonNullableOneof {
      other_field: ::std::default::Default::default(),
      non_nullable_oneof: TestMessage3NonNullableOneof_NonNullableOneof::A(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3NonNullableOneof_default: TestMessage3NonNullableOneof = TestMessage3NonNullableOneof::default();
}
impl ::pb_jelly::Message for TestMessage3NonNullableOneof {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut a_size = 0;
    if let TestMessage3NonNullableOneof_NonNullableOneof::A(ref val) = self.non_nullable_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      a_size += ::pb_jelly::wire_format::serialized_length(1);
      a_size += l;
    }
    size += a_size;
    let mut b_size = 0;
    if let TestMessage3NonNullableOneof_NonNullableOneof::B(ref val) = self.non_nullable_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      b_size += ::pb_jelly::wire_format::serialized_length(2);
      b_size += l;
    }
    size += b_size;
    let mut other_field_size = 0;
    if self.other_field != <u64 as ::std::default::Default>::default() {
      let val = &self.other_field;
      let l = ::pb_jelly::Message::compute_size(val);
      other_field_size += ::pb_jelly::wire_format::serialized_length(3);
      other_field_size += l;
    }
    size += other_field_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if let TestMessage3NonNullableOneof_NonNullableOneof::A(ref val) = self.non_nullable_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if let TestMessage3NonNullableOneof_NonNullableOneof::B(ref val) = self.non_nullable_oneof {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.other_field != <u64 as ::std::default::Default>::default() {
      let val = &self.other_field;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let TestMessage3NonNullableOneof_NonNullableOneof::A(ref val) = self.non_nullable_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3NonNullableOneof_NonNullableOneof::B(ref val) = self.non_nullable_oneof {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.other_field != <u64 as ::std::default::Default>::default() {
      let val = &self.other_field;
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_non_nullable_oneof: ::std::option::Option<TestMessage3NonNullableOneof_NonNullableOneof> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3NonNullableOneof", 1)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          oneof_non_nullable_oneof = Some(TestMessage3NonNullableOneof_NonNullableOneof::A(val));
        }
        2 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3NonNullableOneof", 2)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          oneof_non_nullable_oneof = Some(TestMessage3NonNullableOneof_NonNullableOneof::B(val));
        }
        3 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3NonNullableOneof", 3)?;
          let mut val: u64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.other_field = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_non_nullable_oneof {
      Some(v) => self.non_nullable_oneof = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'non_nullable_oneof' while parsing message pbtest.TestMessage3NonNullableOneof")),
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for TestMessage3NonNullableOneof {
  const NAME: &'static str = "TestMessage3NonNullableOneof";
  const FULL_NAME: &'static str = "pbtest.TestMessage3NonNullableOneof";
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3ErrIfDefaultEnum {
  pub field: TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum,
}
impl ::std::default::Default for TestMessage3ErrIfDefaultEnum {
  fn default() -> Self {
    TestMessage3ErrIfDefaultEnum {
      field: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3ErrIfDefaultEnum_default: TestMessage3ErrIfDefaultEnum = TestMessage3ErrIfDefaultEnum::default();
}
impl ::pb_jelly::Message for TestMessage3ErrIfDefaultEnum {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut field_size = 0;
    let val = &self.field;
    let l = ::pb_jelly::Message::compute_size(val);
    field_size += ::pb_jelly::wire_format::serialized_length(1);
    field_size += l;
    size += field_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    let val = &self.field;
    size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    let val = &self.field;
    ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
    ::pb_jelly::Message::serialize(val, w)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut field: ::std::option::Option<TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3ErrIfDefaultEnum", 1)?;
          let mut val: TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          field = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match field {
      Some(v) => self.field = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "err_if_default_or_unknown 'field' had no value while parsing message pbtest.TestMessage3ErrIfDefaultEnum")),
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for TestMessage3ErrIfDefaultEnum {
  const NAME: &'static str = "TestMessage3ErrIfDefaultEnum";
  const FULL_NAME: &'static str = "pbtest.TestMessage3ErrIfDefaultEnum";
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3ErrIfDefaultEnumOneof {
  pub nothing: ::std::option::Option<::proto_google::empty::Empty>,
  pub maybe: ::std::option::Option<TestMessage3ErrIfDefaultEnumOneof_Maybe>,
}
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TestMessage3ErrIfDefaultEnumOneof_Maybe {
  Something(TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum),
}
impl ::std::default::Default for TestMessage3ErrIfDefaultEnumOneof {
  fn default() -> Self {
    TestMessage3ErrIfDefaultEnumOneof {
      nothing: ::std::default::Default::default(),
      maybe: None,
    }
  }
}
lazy_static! {
  pub static ref TestMessage3ErrIfDefaultEnumOneof_default: TestMessage3ErrIfDefaultEnumOneof = TestMessage3ErrIfDefaultEnumOneof::default();
}
impl ::pb_jelly::Message for TestMessage3ErrIfDefaultEnumOneof {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut something_size = 0;
    if let Some(TestMessage3ErrIfDefaultEnumOneof_Maybe::Something(ref val)) = self.maybe {
      let l = ::pb_jelly::Message::compute_size(val);
      something_size += ::pb_jelly::wire_format::serialized_length(1);
      something_size += l;
    }
    size += something_size;
    let mut nothing_size = 0;
    for val in &self.nothing {
      let l = ::pb_jelly::Message::compute_size(val);
      nothing_size += ::pb_jelly::wire_format::serialized_length(2);
      nothing_size += ::pb_jelly::varint::serialized_length(l as u64);
      nothing_size += l;
    }
    size += nothing_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if let Some(TestMessage3ErrIfDefaultEnumOneof_Maybe::Something(ref val)) = self.maybe {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.nothing {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(TestMessage3ErrIfDefaultEnumOneof_Maybe::Something(ref val)) = self.maybe {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.nothing {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut something: ::std::option::Option<TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3ErrIfDefaultEnumOneof", 1)?;
          let mut val: TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.maybe = Some(TestMessage3ErrIfDefaultEnumOneof_Maybe::Something(val));
        }
        2 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestMessage3ErrIfDefaultEnumOneof", 2)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::proto_google::empty::Empty = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.nothing = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match something {
      Some(v) => self.something = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "err_if_default_or_unknown 'something' had no value while parsing message pbtest.TestMessage3ErrIfDefaultEnumOneof")),
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for TestMessage3ErrIfDefaultEnumOneof {
  const NAME: &'static str = "TestMessage3ErrIfDefaultEnumOneof";
  const FULL_NAME: &'static str = "pbtest.TestMessage3ErrIfDefaultEnumOneof";
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3RepeatedErrIfDefaultEnum {
  pub field: ::std::vec::Vec<TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum>,
}
impl ::std::default::Default for TestMessage3RepeatedErrIfDefaultEnum {
  fn default() -> Self {
    TestMessage3RepeatedErrIfDefaultEnum {
      field: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3RepeatedErrIfDefaultEnum_default: TestMessage3RepeatedErrIfDefaultEnum = TestMessage3RepeatedErrIfDefaultEnum::default();
}
impl ::pb_jelly::Message for TestMessage3RepeatedErrIfDefaultEnum {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut field_size = 0;
    for val in &self.field {
      let l = ::pb_jelly::Message::compute_size(val);
      field_size += l;
    }
    if !self.field.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(1);
      size += ::pb_jelly::varint::serialized_length(field_size as u64);
    }
    size += field_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    for val in &self.field {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if !self.field.is_empty() {
      let mut size = 0;
      for val in &self.field {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.field {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          match typ {
            ::pb_jelly::wire_format::Type::LengthDelimited => {
              let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
              let mut vals = ::pb_jelly::ensure_split(buf, len as usize)?;
              while vals.has_remaining() {
                let mut val: TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum = ::std::default::Default::default();
                ::pb_jelly::Message::deserialize(&mut val, &mut vals)?;
                self.field.push(val);
              }
            }
            _ => {
              ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3RepeatedErrIfDefaultEnum", 1)?;
              let mut val: TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum = ::std::default::Default::default();
              ::pb_jelly::Message::deserialize(&mut val, buf)?;
              self.field.push(val);
            }
          }
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for TestMessage3RepeatedErrIfDefaultEnum {
  const NAME: &'static str = "TestMessage3RepeatedErrIfDefaultEnum";
  const FULL_NAME: &'static str = "pbtest.TestMessage3RepeatedErrIfDefaultEnum";
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestPreserveUnrecognized1 {
  pub string1: ::std::string::String,
  pub _unrecognized: Vec<u8>,
}
impl ::std::default::Default for TestPreserveUnrecognized1 {
  fn default() -> Self {
    TestPreserveUnrecognized1 {
      string1: ::std::default::Default::default(),
      _unrecognized: Vec::new(),
    }
  }
}
lazy_static! {
  pub static ref TestPreserveUnrecognized1_default: TestPreserveUnrecognized1 = TestPreserveUnrecognized1::default();
}
impl ::pb_jelly::Message for TestPreserveUnrecognized1 {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut string1_size = 0;
    if self.string1 != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.string1;
      let l = ::pb_jelly::Message::compute_size(val);
      string1_size += ::pb_jelly::wire_format::serialized_length(1);
      string1_size += ::pb_jelly::varint::serialized_length(l as u64);
      string1_size += l;
    }
    size += string1_size;
    size += self._unrecognized.len();
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if self.string1 != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.string1;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if self.string1 != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.string1;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    w.write_all(&self._unrecognized)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut unrecognized = ::pb_jelly::Unrecognized::default();
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestPreserveUnrecognized1", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.string1 = val;
        }
        _ => {
          unrecognized.gather(field_number, typ, &mut buf)?;
        }
      }
    }
    unrecognized.serialize(&mut self._unrecognized)?;
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for TestPreserveUnrecognized1 {
  const NAME: &'static str = "TestPreserveUnrecognized1";
  const FULL_NAME: &'static str = "pbtest.TestPreserveUnrecognized1";
}

#[derive(Clone, Debug, PartialEq)]
pub struct TestPreserveUnrecognized2 {
  pub a_string1: ::std::string::String,
  pub a_int32: i32,
  pub a_int64: i64,
  pub a_uint32: u32,
  pub a_uint64: u64,
  pub a_fixed64: ::pb_jelly::Fixed64,
  pub a_fixed32: ::pb_jelly::Fixed32,
  pub a_sfixed64: ::pb_jelly::Sfixed64,
  pub a_sfixed32: ::pb_jelly::Sfixed32,
  pub a_double: f64,
  pub a_bool: bool,
  pub a_string: ::std::string::String,
  pub a_bytes: ::std::vec::Vec<u8>,
  pub a_float: f32,
  pub _unrecognized: Vec<u8>,
}
impl ::std::default::Default for TestPreserveUnrecognized2 {
  fn default() -> Self {
    TestPreserveUnrecognized2 {
      a_string1: ::std::default::Default::default(),
      a_int32: ::std::default::Default::default(),
      a_int64: ::std::default::Default::default(),
      a_uint32: ::std::default::Default::default(),
      a_uint64: ::std::default::Default::default(),
      a_fixed64: ::std::default::Default::default(),
      a_fixed32: ::std::default::Default::default(),
      a_sfixed64: ::std::default::Default::default(),
      a_sfixed32: ::std::default::Default::default(),
      a_double: ::std::default::Default::default(),
      a_bool: ::std::default::Default::default(),
      a_string: ::std::default::Default::default(),
      a_bytes: ::std::default::Default::default(),
      a_float: ::std::default::Default::default(),
      _unrecognized: Vec::new(),
    }
  }
}
lazy_static! {
  pub static ref TestPreserveUnrecognized2_default: TestPreserveUnrecognized2 = TestPreserveUnrecognized2::default();
}
impl ::pb_jelly::Message for TestPreserveUnrecognized2 {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    let mut a_string1_size = 0;
    if self.a_string1 != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.a_string1;
      let l = ::pb_jelly::Message::compute_size(val);
      a_string1_size += ::pb_jelly::wire_format::serialized_length(1);
      a_string1_size += ::pb_jelly::varint::serialized_length(l as u64);
      a_string1_size += l;
    }
    size += a_string1_size;
    let mut a_int32_size = 0;
    if self.a_int32 != <i32 as ::std::default::Default>::default() {
      let val = &self.a_int32;
      let l = ::pb_jelly::Message::compute_size(val);
      a_int32_size += ::pb_jelly::wire_format::serialized_length(2);
      a_int32_size += l;
    }
    size += a_int32_size;
    let mut a_int64_size = 0;
    if self.a_int64 != <i64 as ::std::default::Default>::default() {
      let val = &self.a_int64;
      let l = ::pb_jelly::Message::compute_size(val);
      a_int64_size += ::pb_jelly::wire_format::serialized_length(3);
      a_int64_size += l;
    }
    size += a_int64_size;
    let mut a_uint32_size = 0;
    if self.a_uint32 != <u32 as ::std::default::Default>::default() {
      let val = &self.a_uint32;
      let l = ::pb_jelly::Message::compute_size(val);
      a_uint32_size += ::pb_jelly::wire_format::serialized_length(4);
      a_uint32_size += l;
    }
    size += a_uint32_size;
    let mut a_uint64_size = 0;
    if self.a_uint64 != <u64 as ::std::default::Default>::default() {
      let val = &self.a_uint64;
      let l = ::pb_jelly::Message::compute_size(val);
      a_uint64_size += ::pb_jelly::wire_format::serialized_length(5);
      a_uint64_size += l;
    }
    size += a_uint64_size;
    let mut a_fixed64_size = 0;
    if self.a_fixed64 != <::pb_jelly::Fixed64 as ::std::default::Default>::default() {
      let val = &self.a_fixed64;
      let l = ::pb_jelly::Message::compute_size(val);
      a_fixed64_size += ::pb_jelly::wire_format::serialized_length(6);
      a_fixed64_size += l;
    }
    size += a_fixed64_size;
    let mut a_fixed32_size = 0;
    if self.a_fixed32 != <::pb_jelly::Fixed32 as ::std::default::Default>::default() {
      let val = &self.a_fixed32;
      let l = ::pb_jelly::Message::compute_size(val);
      a_fixed32_size += ::pb_jelly::wire_format::serialized_length(7);
      a_fixed32_size += l;
    }
    size += a_fixed32_size;
    let mut a_sfixed64_size = 0;
    if self.a_sfixed64 != <::pb_jelly::Sfixed64 as ::std::default::Default>::default() {
      let val = &self.a_sfixed64;
      let l = ::pb_jelly::Message::compute_size(val);
      a_sfixed64_size += ::pb_jelly::wire_format::serialized_length(8);
      a_sfixed64_size += l;
    }
    size += a_sfixed64_size;
    let mut a_sfixed32_size = 0;
    if self.a_sfixed32 != <::pb_jelly::Sfixed32 as ::std::default::Default>::default() {
      let val = &self.a_sfixed32;
      let l = ::pb_jelly::Message::compute_size(val);
      a_sfixed32_size += ::pb_jelly::wire_format::serialized_length(9);
      a_sfixed32_size += l;
    }
    size += a_sfixed32_size;
    let mut a_double_size = 0;
    if self.a_double != <f64 as ::std::default::Default>::default() {
      let val = &self.a_double;
      let l = ::pb_jelly::Message::compute_size(val);
      a_double_size += ::pb_jelly::wire_format::serialized_length(10);
      a_double_size += l;
    }
    size += a_double_size;
    let mut a_bool_size = 0;
    if self.a_bool != <bool as ::std::default::Default>::default() {
      let val = &self.a_bool;
      let l = ::pb_jelly::Message::compute_size(val);
      a_bool_size += ::pb_jelly::wire_format::serialized_length(11);
      a_bool_size += l;
    }
    size += a_bool_size;
    let mut a_string_size = 0;
    if self.a_string != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.a_string;
      let l = ::pb_jelly::Message::compute_size(val);
      a_string_size += ::pb_jelly::wire_format::serialized_length(12);
      a_string_size += ::pb_jelly::varint::serialized_length(l as u64);
      a_string_size += l;
    }
    size += a_string_size;
    let mut a_bytes_size = 0;
    if self.a_bytes != <::std::vec::Vec<u8> as ::std::default::Default>::default() {
      let val = &self.a_bytes;
      let l = ::pb_jelly::Message::compute_size(val);
      a_bytes_size += ::pb_jelly::wire_format::serialized_length(13);
      a_bytes_size += ::pb_jelly::varint::serialized_length(l as u64);
      a_bytes_size += l;
    }
    size += a_bytes_size;
    let mut a_float_size = 0;
    if self.a_float != <f32 as ::std::default::Default>::default() {
      let val = &self.a_float;
      let l = ::pb_jelly::Message::compute_size(val);
      a_float_size += ::pb_jelly::wire_format::serialized_length(14);
      a_float_size += l;
    }
    size += a_float_size;
    size += self._unrecognized.len();
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    let mut size = 0;
    if self.a_string1 != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.a_string1;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_int32 != <i32 as ::std::default::Default>::default() {
      let val = &self.a_int32;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_int64 != <i64 as ::std::default::Default>::default() {
      let val = &self.a_int64;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_uint32 != <u32 as ::std::default::Default>::default() {
      let val = &self.a_uint32;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_uint64 != <u64 as ::std::default::Default>::default() {
      let val = &self.a_uint64;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_fixed64 != <::pb_jelly::Fixed64 as ::std::default::Default>::default() {
      let val = &self.a_fixed64;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_fixed32 != <::pb_jelly::Fixed32 as ::std::default::Default>::default() {
      let val = &self.a_fixed32;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_sfixed64 != <::pb_jelly::Sfixed64 as ::std::default::Default>::default() {
      let val = &self.a_sfixed64;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_sfixed32 != <::pb_jelly::Sfixed32 as ::std::default::Default>::default() {
      let val = &self.a_sfixed32;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_double != <f64 as ::std::default::Default>::default() {
      let val = &self.a_double;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_bool != <bool as ::std::default::Default>::default() {
      let val = &self.a_bool;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_string != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.a_string;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_bytes != <::std::vec::Vec<u8> as ::std::default::Default>::default() {
      let val = &self.a_bytes;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.a_float != <f32 as ::std::default::Default>::default() {
      let val = &self.a_float;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if self.a_string1 != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.a_string1;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_int32 != <i32 as ::std::default::Default>::default() {
      let val = &self.a_int32;
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_int64 != <i64 as ::std::default::Default>::default() {
      let val = &self.a_int64;
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_uint32 != <u32 as ::std::default::Default>::default() {
      let val = &self.a_uint32;
      ::pb_jelly::wire_format::write(4, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_uint64 != <u64 as ::std::default::Default>::default() {
      let val = &self.a_uint64;
      ::pb_jelly::wire_format::write(5, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_fixed64 != <::pb_jelly::Fixed64 as ::std::default::Default>::default() {
      let val = &self.a_fixed64;
      ::pb_jelly::wire_format::write(6, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_fixed32 != <::pb_jelly::Fixed32 as ::std::default::Default>::default() {
      let val = &self.a_fixed32;
      ::pb_jelly::wire_format::write(7, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_sfixed64 != <::pb_jelly::Sfixed64 as ::std::default::Default>::default() {
      let val = &self.a_sfixed64;
      ::pb_jelly::wire_format::write(8, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_sfixed32 != <::pb_jelly::Sfixed32 as ::std::default::Default>::default() {
      let val = &self.a_sfixed32;
      ::pb_jelly::wire_format::write(9, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_double != <f64 as ::std::default::Default>::default() {
      let val = &self.a_double;
      ::pb_jelly::wire_format::write(10, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_bool != <bool as ::std::default::Default>::default() {
      let val = &self.a_bool;
      ::pb_jelly::wire_format::write(11, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_string != <::std::string::String as ::std::default::Default>::default() {
      let val = &self.a_string;
      ::pb_jelly::wire_format::write(12, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_bytes != <::std::vec::Vec<u8> as ::std::default::Default>::default() {
      let val = &self.a_bytes;
      ::pb_jelly::wire_format::write(13, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if self.a_float != <f32 as ::std::default::Default>::default() {
      let val = &self.a_float;
      ::pb_jelly::wire_format::write(14, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    w.write_all(&self._unrecognized)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut unrecognized = ::pb_jelly::Unrecognized::default();
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestPreserveUnrecognized2", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.a_string1 = val;
        }
        2 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestPreserveUnrecognized2", 2)?;
          let mut val: i32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.a_int32 = val;
        }
        3 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestPreserveUnrecognized2", 3)?;
          let mut val: i64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.a_int64 = val;
        }
        4 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestPreserveUnrecognized2", 4)?;
          let mut val: u32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.a_uint32 = val;
        }
        5 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestPreserveUnrecognized2", 5)?;
          let mut val: u64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.a_uint64 = val;
        }
        6 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "TestPreserveUnrecognized2", 6)?;
          let mut val: ::pb_jelly::Fixed64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.a_fixed64 = val;
        }
        7 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed32, "TestPreserveUnrecognized2", 7)?;
          let mut val: ::pb_jelly::Fixed32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.a_fixed32 = val;
        }
        8 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "TestPreserveUnrecognized2", 8)?;
          let mut val: ::pb_jelly::Sfixed64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.a_sfixed64 = val;
        }
        9 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed32, "TestPreserveUnrecognized2", 9)?;
          let mut val: ::pb_jelly::Sfixed32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.a_sfixed32 = val;
        }
        10 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "TestPreserveUnrecognized2", 10)?;
          let mut val: f64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.a_double = val;
        }
        11 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Varint, "TestPreserveUnrecognized2", 11)?;
          let mut val: bool = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.a_bool = val;
        }
        12 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestPreserveUnrecognized2", 12)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.a_string = val;
        }
        13 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "TestPreserveUnrecognized2", 13)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::vec::Vec<u8> = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.a_bytes = val;
        }
        14 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed32, "TestPreserveUnrecognized2", 14)?;
          let mut val: f32 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.a_float = val;
        }
        _ => {
          unrecognized.gather(field_number, typ, &mut buf)?;
        }
      }
    }
    unrecognized.serialize(&mut self._unrecognized)?;
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for TestPreserveUnrecognized2 {
  const NAME: &'static str = "TestPreserveUnrecognized2";
  const FULL_NAME: &'static str = "pbtest.TestPreserveUnrecognized2";
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestPreserveUnrecognizedEmpty {
  pub _unrecognized: Vec<u8>,
}
impl ::std::default::Default for TestPreserveUnrecognizedEmpty {
  fn default() -> Self {
    TestPreserveUnrecognizedEmpty {
      _unrecognized: Vec::new(),
    }
  }
}
lazy_static! {
  pub static ref TestPreserveUnrecognizedEmpty_default: TestPreserveUnrecognizedEmpty = TestPreserveUnrecognizedEmpty::default();
}
impl ::pb_jelly::Message for TestPreserveUnrecognizedEmpty {
  fn compute_size(&self) -> usize  {
    let mut size = 0;
    size += self._unrecognized.len();
    size
  }
  fn compute_grpc_slices_size(&self) -> usize  {
    0
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    w.write_all(&self._unrecognized)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut unrecognized = ::pb_jelly::Unrecognized::default();
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        _ => {
          unrecognized.gather(field_number, typ, &mut buf)?;
        }
      }
    }
    unrecognized.serialize(&mut self._unrecognized)?;
    Ok(())
  }
}
impl ::pb_jelly::MessageDescriptor for TestPreserveUnrecognizedEmpty {
  const NAME: &'static str = "TestPreserveUnrecognizedEmpty";
  const FULL_NAME: &'static str = "pbtest.TestPreserveUnrecognizedEmpty";
}

