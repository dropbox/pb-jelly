// @generated, do not edit
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct ForeignEnum3(i32);
impl ForeignEnum3 {
  pub const FOREIGN3_FOO: ForeignEnum3 = ForeignEnum3(0);
  pub const FOREIGN3_BAR: ForeignEnum3 = ForeignEnum3(1);
  pub const FOREIGN3_BAZ: ForeignEnum3 = ForeignEnum3(2);
  pub const KNOWN_VARIANTS: [ForeignEnum3; 3] = [ForeignEnum3::FOREIGN3_FOO, ForeignEnum3::FOREIGN3_BAR, ForeignEnum3::FOREIGN3_BAZ];
  pub const fn value(self) -> i32 {
    self.0
  }
}
impl ::std::default::Default for ForeignEnum3 {
  fn default() -> Self {
    ForeignEnum3::FOREIGN3_FOO
  }
}
impl From<ForeignEnum3> for i32 {
  fn from(v: ForeignEnum3) -> i32 {
    v.0
  }
}
impl From<i32> for ForeignEnum3 {
  fn from(v: i32) -> ForeignEnum3 {
    ForeignEnum3(v)
  }
}
impl From<ForeignEnum3_Closed> for ForeignEnum3 {
  fn from(v: ForeignEnum3_Closed) -> ForeignEnum3 {
    ForeignEnum3(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for ForeignEnum3 {
}
impl ::pb_jelly::OpenProtoEnum for ForeignEnum3 {
  type Closed = ForeignEnum3_Closed;
  fn into_known(self) -> ::std::option::Option<ForeignEnum3_Closed> {
    match self {
      ForeignEnum3::FOREIGN3_FOO => ::std::option::Option::Some(ForeignEnum3_Closed::FOREIGN3_FOO),
      ForeignEnum3::FOREIGN3_BAR => ::std::option::Option::Some(ForeignEnum3_Closed::FOREIGN3_BAR),
      ForeignEnum3::FOREIGN3_BAZ => ::std::option::Option::Some(ForeignEnum3_Closed::FOREIGN3_BAZ),
      _ => None,
    }
  }
}
impl ::std::fmt::Debug for ForeignEnum3 {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    match <Self as ::pb_jelly::OpenProtoEnum>::name(*self) {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum ForeignEnum3_Closed {
  FOREIGN3_FOO = 0,
  FOREIGN3_BAR = 1,
  FOREIGN3_BAZ = 2,
}
impl ForeignEnum3_Closed {
  pub const KNOWN_VARIANTS: [ForeignEnum3_Closed; 3] = [ForeignEnum3_Closed::FOREIGN3_FOO, ForeignEnum3_Closed::FOREIGN3_BAR, ForeignEnum3_Closed::FOREIGN3_BAZ];
}
impl ::std::default::Default for ForeignEnum3_Closed {
  fn default() -> Self {
    ForeignEnum3_Closed::FOREIGN3_FOO
  }
}
impl From<ForeignEnum3_Closed> for i32 {
  fn from(v: ForeignEnum3_Closed) -> i32 {
    match v {
      ForeignEnum3_Closed::FOREIGN3_FOO => 0,
      ForeignEnum3_Closed::FOREIGN3_BAR => 1,
      ForeignEnum3_Closed::FOREIGN3_BAZ => 2,
    }
  }
}
impl ::std::convert::TryFrom<i32> for ForeignEnum3_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(ForeignEnum3_Closed::FOREIGN3_FOO),
      1 => Ok(ForeignEnum3_Closed::FOREIGN3_BAR),
      2 => Ok(ForeignEnum3_Closed::FOREIGN3_BAZ),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for ForeignEnum3_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for ForeignEnum3_Closed {
  fn name(self) -> &'static str {
    match self {
      ForeignEnum3_Closed::FOREIGN3_FOO => "FOREIGN3_FOO",
      ForeignEnum3_Closed::FOREIGN3_BAR => "FOREIGN3_BAR",
      ForeignEnum3_Closed::FOREIGN3_BAZ => "FOREIGN3_BAZ",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct Version31Enum_TestEnum(i32);
impl Version31Enum_TestEnum {
  pub const ENUM0: Version31Enum_TestEnum = Version31Enum_TestEnum(0);
  pub const KNOWN_VARIANTS: [Version31Enum_TestEnum; 1] = [Version31Enum_TestEnum::ENUM0];
  pub const fn value(self) -> i32 {
    self.0
  }
}
impl ::std::default::Default for Version31Enum_TestEnum {
  fn default() -> Self {
    Version31Enum_TestEnum::ENUM0
  }
}
impl From<Version31Enum_TestEnum> for i32 {
  fn from(v: Version31Enum_TestEnum) -> i32 {
    v.0
  }
}
impl From<i32> for Version31Enum_TestEnum {
  fn from(v: i32) -> Version31Enum_TestEnum {
    Version31Enum_TestEnum(v)
  }
}
impl From<Version31Enum_TestEnum_Closed> for Version31Enum_TestEnum {
  fn from(v: Version31Enum_TestEnum_Closed) -> Version31Enum_TestEnum {
    Version31Enum_TestEnum(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for Version31Enum_TestEnum {
}
impl ::pb_jelly::OpenProtoEnum for Version31Enum_TestEnum {
  type Closed = Version31Enum_TestEnum_Closed;
  fn into_known(self) -> ::std::option::Option<Version31Enum_TestEnum_Closed> {
    match self {
      Version31Enum_TestEnum::ENUM0 => ::std::option::Option::Some(Version31Enum_TestEnum_Closed::ENUM0),
      _ => None,
    }
  }
}
impl ::std::fmt::Debug for Version31Enum_TestEnum {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    match <Self as ::pb_jelly::OpenProtoEnum>::name(*self) {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum Version31Enum_TestEnum_Closed {
  ENUM0 = 0,
}
impl Version31Enum_TestEnum_Closed {
  pub const KNOWN_VARIANTS: [Version31Enum_TestEnum_Closed; 1] = [Version31Enum_TestEnum_Closed::ENUM0];
}
impl ::std::default::Default for Version31Enum_TestEnum_Closed {
  fn default() -> Self {
    Version31Enum_TestEnum_Closed::ENUM0
  }
}
impl From<Version31Enum_TestEnum_Closed> for i32 {
  fn from(v: Version31Enum_TestEnum_Closed) -> i32 {
    match v {
      Version31Enum_TestEnum_Closed::ENUM0 => 0,
    }
  }
}
impl ::std::convert::TryFrom<i32> for Version31Enum_TestEnum_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(Version31Enum_TestEnum_Closed::ENUM0),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for Version31Enum_TestEnum_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for Version31Enum_TestEnum_Closed {
  fn name(self) -> &'static str {
    match self {
      Version31Enum_TestEnum_Closed::ENUM0 => "ENUM0",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct Version32Enum_TestEnum(i32);
impl Version32Enum_TestEnum {
  pub const ENUM0: Version32Enum_TestEnum = Version32Enum_TestEnum(0);
  pub const ENUM1: Version32Enum_TestEnum = Version32Enum_TestEnum(1);
  pub const KNOWN_VARIANTS: [Version32Enum_TestEnum; 2] = [Version32Enum_TestEnum::ENUM0, Version32Enum_TestEnum::ENUM1];
  pub const fn value(self) -> i32 {
    self.0
  }
}
impl ::std::default::Default for Version32Enum_TestEnum {
  fn default() -> Self {
    Version32Enum_TestEnum::ENUM0
  }
}
impl From<Version32Enum_TestEnum> for i32 {
  fn from(v: Version32Enum_TestEnum) -> i32 {
    v.0
  }
}
impl From<i32> for Version32Enum_TestEnum {
  fn from(v: i32) -> Version32Enum_TestEnum {
    Version32Enum_TestEnum(v)
  }
}
impl From<Version32Enum_TestEnum_Closed> for Version32Enum_TestEnum {
  fn from(v: Version32Enum_TestEnum_Closed) -> Version32Enum_TestEnum {
    Version32Enum_TestEnum(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for Version32Enum_TestEnum {
}
impl ::pb_jelly::OpenProtoEnum for Version32Enum_TestEnum {
  type Closed = Version32Enum_TestEnum_Closed;
  fn into_known(self) -> ::std::option::Option<Version32Enum_TestEnum_Closed> {
    match self {
      Version32Enum_TestEnum::ENUM0 => ::std::option::Option::Some(Version32Enum_TestEnum_Closed::ENUM0),
      Version32Enum_TestEnum::ENUM1 => ::std::option::Option::Some(Version32Enum_TestEnum_Closed::ENUM1),
      _ => None,
    }
  }
}
impl ::std::fmt::Debug for Version32Enum_TestEnum {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    match <Self as ::pb_jelly::OpenProtoEnum>::name(*self) {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum Version32Enum_TestEnum_Closed {
  ENUM0 = 0,
  ENUM1 = 1,
}
impl Version32Enum_TestEnum_Closed {
  pub const KNOWN_VARIANTS: [Version32Enum_TestEnum_Closed; 2] = [Version32Enum_TestEnum_Closed::ENUM0, Version32Enum_TestEnum_Closed::ENUM1];
}
impl ::std::default::Default for Version32Enum_TestEnum_Closed {
  fn default() -> Self {
    Version32Enum_TestEnum_Closed::ENUM0
  }
}
impl From<Version32Enum_TestEnum_Closed> for i32 {
  fn from(v: Version32Enum_TestEnum_Closed) -> i32 {
    match v {
      Version32Enum_TestEnum_Closed::ENUM0 => 0,
      Version32Enum_TestEnum_Closed::ENUM1 => 1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for Version32Enum_TestEnum_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(Version32Enum_TestEnum_Closed::ENUM0),
      1 => Ok(Version32Enum_TestEnum_Closed::ENUM1),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for Version32Enum_TestEnum_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for Version32Enum_TestEnum_Closed {
  fn name(self) -> &'static str {
    match self {
      Version32Enum_TestEnum_Closed::ENUM0 => "ENUM0",
      Version32Enum_TestEnum_Closed::ENUM1 => "ENUM1",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct TestMessage3_NestedEnum3(i32);
impl TestMessage3_NestedEnum3 {
  pub const FOO: TestMessage3_NestedEnum3 = TestMessage3_NestedEnum3(0);
  pub const BAR: TestMessage3_NestedEnum3 = TestMessage3_NestedEnum3(1);
  pub const BAZ: TestMessage3_NestedEnum3 = TestMessage3_NestedEnum3(2);
  /// Intentionally negative.
  pub const NEG: TestMessage3_NestedEnum3 = TestMessage3_NestedEnum3(-1);
  pub const KNOWN_VARIANTS: [TestMessage3_NestedEnum3; 4] = [TestMessage3_NestedEnum3::FOO, TestMessage3_NestedEnum3::BAR, TestMessage3_NestedEnum3::BAZ, TestMessage3_NestedEnum3::NEG];
  pub const fn value(self) -> i32 {
    self.0
  }
}
impl ::std::default::Default for TestMessage3_NestedEnum3 {
  fn default() -> Self {
    TestMessage3_NestedEnum3::FOO
  }
}
impl From<TestMessage3_NestedEnum3> for i32 {
  fn from(v: TestMessage3_NestedEnum3) -> i32 {
    v.0
  }
}
impl From<i32> for TestMessage3_NestedEnum3 {
  fn from(v: i32) -> TestMessage3_NestedEnum3 {
    TestMessage3_NestedEnum3(v)
  }
}
impl From<TestMessage3_NestedEnum3_Closed> for TestMessage3_NestedEnum3 {
  fn from(v: TestMessage3_NestedEnum3_Closed) -> TestMessage3_NestedEnum3 {
    TestMessage3_NestedEnum3(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3_NestedEnum3 {
}
impl ::pb_jelly::OpenProtoEnum for TestMessage3_NestedEnum3 {
  type Closed = TestMessage3_NestedEnum3_Closed;
  fn into_known(self) -> ::std::option::Option<TestMessage3_NestedEnum3_Closed> {
    match self {
      TestMessage3_NestedEnum3::FOO => ::std::option::Option::Some(TestMessage3_NestedEnum3_Closed::FOO),
      TestMessage3_NestedEnum3::BAR => ::std::option::Option::Some(TestMessage3_NestedEnum3_Closed::BAR),
      TestMessage3_NestedEnum3::BAZ => ::std::option::Option::Some(TestMessage3_NestedEnum3_Closed::BAZ),
      TestMessage3_NestedEnum3::NEG => ::std::option::Option::Some(TestMessage3_NestedEnum3_Closed::NEG),
      _ => None,
    }
  }
}
impl ::std::fmt::Debug for TestMessage3_NestedEnum3 {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    match <Self as ::pb_jelly::OpenProtoEnum>::name(*self) {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage3_NestedEnum3_Closed {
  FOO = 0,
  BAR = 1,
  BAZ = 2,
  /// Intentionally negative.
  NEG = -1,
}
impl TestMessage3_NestedEnum3_Closed {
  pub const KNOWN_VARIANTS: [TestMessage3_NestedEnum3_Closed; 4] = [TestMessage3_NestedEnum3_Closed::FOO, TestMessage3_NestedEnum3_Closed::BAR, TestMessage3_NestedEnum3_Closed::BAZ, TestMessage3_NestedEnum3_Closed::NEG];
}
impl ::std::default::Default for TestMessage3_NestedEnum3_Closed {
  fn default() -> Self {
    TestMessage3_NestedEnum3_Closed::FOO
  }
}
impl From<TestMessage3_NestedEnum3_Closed> for i32 {
  fn from(v: TestMessage3_NestedEnum3_Closed) -> i32 {
    match v {
      TestMessage3_NestedEnum3_Closed::FOO => 0,
      TestMessage3_NestedEnum3_Closed::BAR => 1,
      TestMessage3_NestedEnum3_Closed::BAZ => 2,
      TestMessage3_NestedEnum3_Closed::NEG => -1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage3_NestedEnum3_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(TestMessage3_NestedEnum3_Closed::FOO),
      1 => Ok(TestMessage3_NestedEnum3_Closed::BAR),
      2 => Ok(TestMessage3_NestedEnum3_Closed::BAZ),
      -1 => Ok(TestMessage3_NestedEnum3_Closed::NEG),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3_NestedEnum3_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage3_NestedEnum3_Closed {
  fn name(self) -> &'static str {
    match self {
      TestMessage3_NestedEnum3_Closed::FOO => "FOO",
      TestMessage3_NestedEnum3_Closed::BAR => "BAR",
      TestMessage3_NestedEnum3_Closed::BAZ => "BAZ",
      TestMessage3_NestedEnum3_Closed::NEG => "NEG",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(transparent)]
pub struct TestMessage3_NestedMessage_Enum(i32);
impl TestMessage3_NestedMessage_Enum {
  pub const ENUM_VARIANT_ONE: TestMessage3_NestedMessage_Enum = TestMessage3_NestedMessage_Enum(0);
  pub const KNOWN_VARIANTS: [TestMessage3_NestedMessage_Enum; 1] = [TestMessage3_NestedMessage_Enum::ENUM_VARIANT_ONE];
  pub const fn value(self) -> i32 {
    self.0
  }
}
impl ::std::default::Default for TestMessage3_NestedMessage_Enum {
  fn default() -> Self {
    TestMessage3_NestedMessage_Enum::ENUM_VARIANT_ONE
  }
}
impl From<TestMessage3_NestedMessage_Enum> for i32 {
  fn from(v: TestMessage3_NestedMessage_Enum) -> i32 {
    v.0
  }
}
impl From<i32> for TestMessage3_NestedMessage_Enum {
  fn from(v: i32) -> TestMessage3_NestedMessage_Enum {
    TestMessage3_NestedMessage_Enum(v)
  }
}
impl From<TestMessage3_NestedMessage_Enum_Closed> for TestMessage3_NestedMessage_Enum {
  fn from(v: TestMessage3_NestedMessage_Enum_Closed) -> TestMessage3_NestedMessage_Enum {
    TestMessage3_NestedMessage_Enum(v as i32)
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3_NestedMessage_Enum {
}
impl ::pb_jelly::OpenProtoEnum for TestMessage3_NestedMessage_Enum {
  type Closed = TestMessage3_NestedMessage_Enum_Closed;
  fn into_known(self) -> ::std::option::Option<TestMessage3_NestedMessage_Enum_Closed> {
    match self {
      TestMessage3_NestedMessage_Enum::ENUM_VARIANT_ONE => ::std::option::Option::Some(TestMessage3_NestedMessage_Enum_Closed::ENUM_VARIANT_ONE),
      _ => None,
    }
  }
}
impl ::std::fmt::Debug for TestMessage3_NestedMessage_Enum {
  fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
    match <Self as ::pb_jelly::OpenProtoEnum>::name(*self) {
      Some(s) => write!(f, "{}", s),
      None => write!(f, "Unknown({})", self.0),
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage3_NestedMessage_Enum_Closed {
  ENUM_VARIANT_ONE = 0,
}
impl TestMessage3_NestedMessage_Enum_Closed {
  pub const KNOWN_VARIANTS: [TestMessage3_NestedMessage_Enum_Closed; 1] = [TestMessage3_NestedMessage_Enum_Closed::ENUM_VARIANT_ONE];
}
impl ::std::default::Default for TestMessage3_NestedMessage_Enum_Closed {
  fn default() -> Self {
    TestMessage3_NestedMessage_Enum_Closed::ENUM_VARIANT_ONE
  }
}
impl From<TestMessage3_NestedMessage_Enum_Closed> for i32 {
  fn from(v: TestMessage3_NestedMessage_Enum_Closed) -> i32 {
    match v {
      TestMessage3_NestedMessage_Enum_Closed::ENUM_VARIANT_ONE => 0,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage3_NestedMessage_Enum_Closed {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(TestMessage3_NestedMessage_Enum_Closed::ENUM_VARIANT_ONE),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3_NestedMessage_Enum_Closed {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage3_NestedMessage_Enum_Closed {
  fn name(self) -> &'static str {
    match self {
      TestMessage3_NestedMessage_Enum_Closed::ENUM_VARIANT_ONE => "ENUM_VARIANT_ONE",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage3_NestedMessage_NonNullableEnum {
  NON_NULLABLE_VARIANT_ONE = 1,
}
impl TestMessage3_NestedMessage_NonNullableEnum {
  pub const KNOWN_VARIANTS: [TestMessage3_NestedMessage_NonNullableEnum; 1] = [TestMessage3_NestedMessage_NonNullableEnum::NON_NULLABLE_VARIANT_ONE];
}
impl ::std::default::Default for TestMessage3_NestedMessage_NonNullableEnum {
  fn default() -> Self {
    TestMessage3_NestedMessage_NonNullableEnum::NON_NULLABLE_VARIANT_ONE
  }
}
impl From<TestMessage3_NestedMessage_NonNullableEnum> for i32 {
  fn from(v: TestMessage3_NestedMessage_NonNullableEnum) -> i32 {
    match v {
      TestMessage3_NestedMessage_NonNullableEnum::NON_NULLABLE_VARIANT_ONE => 1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage3_NestedMessage_NonNullableEnum {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      1 => Ok(TestMessage3_NestedMessage_NonNullableEnum::NON_NULLABLE_VARIANT_ONE),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3_NestedMessage_NonNullableEnum {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage3_NestedMessage_NonNullableEnum {
  fn name(self) -> &'static str {
    match self {
      TestMessage3_NestedMessage_NonNullableEnum::NON_NULLABLE_VARIANT_ONE => "NON_NULLABLE_VARIANT_ONE",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum {
  THE_OTHER_ONE = 1,
}
impl TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum {
  pub const KNOWN_VARIANTS: [TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum; 1] = [TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum::THE_OTHER_ONE];
}
impl ::std::default::Default for TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum {
  fn default() -> Self {
    TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum::THE_OTHER_ONE
  }
}
impl From<TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum> for i32 {
  fn from(v: TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum) -> i32 {
    match v {
      TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum::THE_OTHER_ONE => 1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      1 => Ok(TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum::THE_OTHER_ONE),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum {
  fn name(self) -> &'static str {
    match self {
      TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum::THE_OTHER_ONE => "THE_OTHER_ONE",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum {
  THE_OTHER_ONE = 1,
}
impl TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum {
  pub const KNOWN_VARIANTS: [TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum; 1] = [TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum::THE_OTHER_ONE];
}
impl ::std::default::Default for TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum {
  fn default() -> Self {
    TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum::THE_OTHER_ONE
  }
}
impl From<TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum> for i32 {
  fn from(v: TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum) -> i32 {
    match v {
      TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum::THE_OTHER_ONE => 1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      1 => Ok(TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum::THE_OTHER_ONE),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum {
  fn name(self) -> &'static str {
    match self {
      TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum::THE_OTHER_ONE => "THE_OTHER_ONE",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage3ClosedEnum_ClosedEnum {
  DEFAULT = 0,
  ONE = 1,
}
impl TestMessage3ClosedEnum_ClosedEnum {
  pub const KNOWN_VARIANTS: [TestMessage3ClosedEnum_ClosedEnum; 2] = [TestMessage3ClosedEnum_ClosedEnum::DEFAULT, TestMessage3ClosedEnum_ClosedEnum::ONE];
}
impl ::std::default::Default for TestMessage3ClosedEnum_ClosedEnum {
  fn default() -> Self {
    TestMessage3ClosedEnum_ClosedEnum::DEFAULT
  }
}
impl From<TestMessage3ClosedEnum_ClosedEnum> for i32 {
  fn from(v: TestMessage3ClosedEnum_ClosedEnum) -> i32 {
    match v {
      TestMessage3ClosedEnum_ClosedEnum::DEFAULT => 0,
      TestMessage3ClosedEnum_ClosedEnum::ONE => 1,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage3ClosedEnum_ClosedEnum {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(TestMessage3ClosedEnum_ClosedEnum::DEFAULT),
      1 => Ok(TestMessage3ClosedEnum_ClosedEnum::ONE),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3ClosedEnum_ClosedEnum {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage3ClosedEnum_ClosedEnum {
  fn name(self) -> &'static str {
    match self {
      TestMessage3ClosedEnum_ClosedEnum::DEFAULT => "DEFAULT",
      TestMessage3ClosedEnum_ClosedEnum::ONE => "ONE",
    }
  }
}

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]
#[repr(i32)]
pub enum TestMessage3ClosedEnum2_ClosedEnum {
  DEFAULT = 0,
  ONE = 1,
  TWO = 2,
}
impl TestMessage3ClosedEnum2_ClosedEnum {
  pub const KNOWN_VARIANTS: [TestMessage3ClosedEnum2_ClosedEnum; 3] = [TestMessage3ClosedEnum2_ClosedEnum::DEFAULT, TestMessage3ClosedEnum2_ClosedEnum::ONE, TestMessage3ClosedEnum2_ClosedEnum::TWO];
}
impl ::std::default::Default for TestMessage3ClosedEnum2_ClosedEnum {
  fn default() -> Self {
    TestMessage3ClosedEnum2_ClosedEnum::DEFAULT
  }
}
impl From<TestMessage3ClosedEnum2_ClosedEnum> for i32 {
  fn from(v: TestMessage3ClosedEnum2_ClosedEnum) -> i32 {
    match v {
      TestMessage3ClosedEnum2_ClosedEnum::DEFAULT => 0,
      TestMessage3ClosedEnum2_ClosedEnum::ONE => 1,
      TestMessage3ClosedEnum2_ClosedEnum::TWO => 2,
    }
  }
}
impl ::std::convert::TryFrom<i32> for TestMessage3ClosedEnum2_ClosedEnum {
  type Error = i32;
  fn try_from(v: i32) -> ::std::result::Result<Self, i32> {
    match v {
      0 => Ok(TestMessage3ClosedEnum2_ClosedEnum::DEFAULT),
      1 => Ok(TestMessage3ClosedEnum2_ClosedEnum::ONE),
      2 => Ok(TestMessage3ClosedEnum2_ClosedEnum::TWO),
      _ => Err(v),
    }
  }
}
impl ::pb_jelly::ProtoEnum for TestMessage3ClosedEnum2_ClosedEnum {
}
impl ::pb_jelly::ClosedProtoEnum for TestMessage3ClosedEnum2_ClosedEnum {
  fn name(self) -> &'static str {
    match self {
      TestMessage3ClosedEnum2_ClosedEnum::DEFAULT => "DEFAULT",
      TestMessage3ClosedEnum2_ClosedEnum::ONE => "ONE",
      TestMessage3ClosedEnum2_ClosedEnum::TWO => "TWO",
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ForeignMessage3 {
  pub c: i32,
}
impl ::std::default::Default for ForeignMessage3 {
  fn default() -> Self {
    ForeignMessage3 {
      c: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref ForeignMessage3_default: ForeignMessage3 = ForeignMessage3::default();
}
impl ::pb_jelly::Message for ForeignMessage3 {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "ForeignMessage3",
      full_name: "pbtest.ForeignMessage3",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "c",
          full_name: "pbtest.ForeignMessage3.c",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<i32>(&self.c, 1, ::pb_jelly::wire_format::Type::Varint);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, i32>(w, &self.c, 1, ::pb_jelly::wire_format::Type::Varint)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "ForeignMessage3", 1)?;
          self.c = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for ForeignMessage3 {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "c" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.c)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version31OneOfNoneNullable {
  pub test_oneof: Version31OneOfNoneNullable_TestOneof,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version31OneOfNoneNullable_TestOneof {
  StringOneOf(::std::string::String),
  StringTwoOf(::std::string::String),
}
impl ::std::default::Default for Version31OneOfNoneNullable {
  fn default() -> Self {
    Version31OneOfNoneNullable {
      test_oneof: Version31OneOfNoneNullable_TestOneof::StringOneOf(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref Version31OneOfNoneNullable_default: Version31OneOfNoneNullable = Version31OneOfNoneNullable::default();
}
impl ::pb_jelly::Message for Version31OneOfNoneNullable {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version31OneOfNoneNullable",
      full_name: "pbtest.Version31OneOfNoneNullable",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "string_one_of",
          full_name: "pbtest.Version31OneOfNoneNullable.string_one_of",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "string_two_of",
          full_name: "pbtest.Version31OneOfNoneNullable.string_two_of",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "test_oneof",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Version31OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    let mut string_two_of_size = 0;
    if let Version31OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_two_of_size += ::pb_jelly::wire_format::serialized_length(2);
      string_two_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_two_of_size += l;
    }
    size += string_two_of_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Version31OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Version31OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_test_oneof: ::std::option::Option<Version31OneOfNoneNullable_TestOneof> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version31OneOfNoneNullable", 1)?;
          oneof_test_oneof = Some(Version31OneOfNoneNullable_TestOneof::StringOneOf(val));
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version31OneOfNoneNullable", 2)?;
          oneof_test_oneof = Some(Version31OneOfNoneNullable_TestOneof::StringTwoOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_test_oneof {
      Some(v) => self.test_oneof = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'test_oneof' while parsing message pbtest.Version31OneOfNoneNullable")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version31OneOfNoneNullable {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "test_oneof" => {
        if let Version31OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
          return Some("string_one_of");
        }
        if let Version31OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
          return Some("string_two_of");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "string_one_of" => {
        match self.test_oneof {
          Version31OneOfNoneNullable_TestOneof::StringOneOf(_) => (),
          _ => {
            self.test_oneof = Version31OneOfNoneNullable_TestOneof::StringOneOf(::std::default::Default::default());
          },
        }
        if let Version31OneOfNoneNullable_TestOneof::StringOneOf(ref mut val) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "string_two_of" => {
        match self.test_oneof {
          Version31OneOfNoneNullable_TestOneof::StringTwoOf(_) => (),
          _ => {
            self.test_oneof = Version31OneOfNoneNullable_TestOneof::StringTwoOf(::std::default::Default::default());
          },
        }
        if let Version31OneOfNoneNullable_TestOneof::StringTwoOf(ref mut val) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version32OneOfNoneNullable {
  pub test_oneof: Version32OneOfNoneNullable_TestOneof,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version32OneOfNoneNullable_TestOneof {
  StringOneOf(::std::string::String),
  StringTwoOf(::std::string::String),
  IntOneOf(i32),
}
impl ::std::default::Default for Version32OneOfNoneNullable {
  fn default() -> Self {
    Version32OneOfNoneNullable {
      test_oneof: Version32OneOfNoneNullable_TestOneof::StringOneOf(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref Version32OneOfNoneNullable_default: Version32OneOfNoneNullable = Version32OneOfNoneNullable::default();
}
impl ::pb_jelly::Message for Version32OneOfNoneNullable {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version32OneOfNoneNullable",
      full_name: "pbtest.Version32OneOfNoneNullable",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "string_one_of",
          full_name: "pbtest.Version32OneOfNoneNullable.string_one_of",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "string_two_of",
          full_name: "pbtest.Version32OneOfNoneNullable.string_two_of",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int_one_Of",
          full_name: "pbtest.Version32OneOfNoneNullable.int_one_Of",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "test_oneof",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Version32OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    let mut string_two_of_size = 0;
    if let Version32OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_two_of_size += ::pb_jelly::wire_format::serialized_length(2);
      string_two_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_two_of_size += l;
    }
    size += string_two_of_size;
    let mut int_one_Of_size = 0;
    if let Version32OneOfNoneNullable_TestOneof::IntOneOf(ref val) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      int_one_Of_size += ::pb_jelly::wire_format::serialized_length(3);
      int_one_Of_size += l;
    }
    size += int_one_Of_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Version32OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Version32OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Version32OneOfNoneNullable_TestOneof::IntOneOf(ref val) = self.test_oneof {
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_test_oneof: ::std::option::Option<Version32OneOfNoneNullable_TestOneof> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version32OneOfNoneNullable", 1)?;
          oneof_test_oneof = Some(Version32OneOfNoneNullable_TestOneof::StringOneOf(val));
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version32OneOfNoneNullable", 2)?;
          oneof_test_oneof = Some(Version32OneOfNoneNullable_TestOneof::StringTwoOf(val));
        }
        3 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version32OneOfNoneNullable", 3)?;
          oneof_test_oneof = Some(Version32OneOfNoneNullable_TestOneof::IntOneOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_test_oneof {
      Some(v) => self.test_oneof = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'test_oneof' while parsing message pbtest.Version32OneOfNoneNullable")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version32OneOfNoneNullable {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "test_oneof" => {
        if let Version32OneOfNoneNullable_TestOneof::StringOneOf(ref val) = self.test_oneof {
          return Some("string_one_of");
        }
        if let Version32OneOfNoneNullable_TestOneof::StringTwoOf(ref val) = self.test_oneof {
          return Some("string_two_of");
        }
        if let Version32OneOfNoneNullable_TestOneof::IntOneOf(ref val) = self.test_oneof {
          return Some("int_one_Of");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "string_one_of" => {
        match self.test_oneof {
          Version32OneOfNoneNullable_TestOneof::StringOneOf(_) => (),
          _ => {
            self.test_oneof = Version32OneOfNoneNullable_TestOneof::StringOneOf(::std::default::Default::default());
          },
        }
        if let Version32OneOfNoneNullable_TestOneof::StringOneOf(ref mut val) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "string_two_of" => {
        match self.test_oneof {
          Version32OneOfNoneNullable_TestOneof::StringTwoOf(_) => (),
          _ => {
            self.test_oneof = Version32OneOfNoneNullable_TestOneof::StringTwoOf(::std::default::Default::default());
          },
        }
        if let Version32OneOfNoneNullable_TestOneof::StringTwoOf(ref mut val) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int_one_Of" => {
        match self.test_oneof {
          Version32OneOfNoneNullable_TestOneof::IntOneOf(_) => (),
          _ => {
            self.test_oneof = Version32OneOfNoneNullable_TestOneof::IntOneOf(::std::default::Default::default());
          },
        }
        if let Version32OneOfNoneNullable_TestOneof::IntOneOf(ref mut val) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version31Enum {
  pub enum_field: Version31Enum_TestEnum,
}
impl ::std::default::Default for Version31Enum {
  fn default() -> Self {
    Version31Enum {
      enum_field: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version31Enum_default: Version31Enum = Version31Enum::default();
}
impl ::pb_jelly::Message for Version31Enum {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version31Enum",
      full_name: "pbtest.Version31Enum",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "enum_field",
          full_name: "pbtest.Version31Enum.enum_field",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<Version31Enum_TestEnum>(&self.enum_field, 1, ::pb_jelly::wire_format::Type::Varint);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, Version31Enum_TestEnum>(w, &self.enum_field, 1, ::pb_jelly::wire_format::Type::Varint)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, Version31Enum_TestEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version31Enum", 1)?;
          self.enum_field = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version31Enum {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "enum_field" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.enum_field)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version32Enum {
  pub enum_field: Version32Enum_TestEnum,
}
impl ::std::default::Default for Version32Enum {
  fn default() -> Self {
    Version32Enum {
      enum_field: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version32Enum_default: Version32Enum = Version32Enum::default();
}
impl ::pb_jelly::Message for Version32Enum {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version32Enum",
      full_name: "pbtest.Version32Enum",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "enum_field",
          full_name: "pbtest.Version32Enum.enum_field",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<Version32Enum_TestEnum>(&self.enum_field, 1, ::pb_jelly::wire_format::Type::Varint);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, Version32Enum_TestEnum>(w, &self.enum_field, 1, ::pb_jelly::wire_format::Type::Varint)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, Version32Enum_TestEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version32Enum", 1)?;
          self.enum_field = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version32Enum {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "enum_field" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.enum_field)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version31OneOf {
  pub test_oneof: ::std::option::Option<Version31OneOf_TestOneof>,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version31OneOf_TestOneof {
  StringOneOf(::std::string::String),
}
impl ::std::default::Default for Version31OneOf {
  fn default() -> Self {
    Version31OneOf {
      test_oneof: None,
    }
  }
}
lazy_static! {
  pub static ref Version31OneOf_default: Version31OneOf = Version31OneOf::default();
}
impl ::pb_jelly::Message for Version31OneOf {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version31OneOf",
      full_name: "pbtest.Version31OneOf",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "string_one_of",
          full_name: "pbtest.Version31OneOf.string_one_of",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "test_oneof",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Some(Version31OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(Version31OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version31OneOf", 1)?;
          self.test_oneof = Some(Version31OneOf_TestOneof::StringOneOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version31OneOf {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "test_oneof" => {
        if let Some(Version31OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
          return Some("string_one_of");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "string_one_of" => {
        match self.test_oneof {
          Some(Version31OneOf_TestOneof::StringOneOf(_)) => (),
          _ => {
            self.test_oneof = Some(Version31OneOf_TestOneof::StringOneOf(::std::default::Default::default()));
          },
        }
        if let Some(Version31OneOf_TestOneof::StringOneOf(ref mut val)) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version32OneOf {
  pub test_oneof: ::std::option::Option<Version32OneOf_TestOneof>,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Version32OneOf_TestOneof {
  StringOneOf(::std::string::String),
  IntOneOf(i32),
}
impl ::std::default::Default for Version32OneOf {
  fn default() -> Self {
    Version32OneOf {
      test_oneof: None,
    }
  }
}
lazy_static! {
  pub static ref Version32OneOf_default: Version32OneOf = Version32OneOf::default();
}
impl ::pb_jelly::Message for Version32OneOf {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version32OneOf",
      full_name: "pbtest.Version32OneOf",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "string_one_of",
          full_name: "pbtest.Version32OneOf.string_one_of",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int_one_of",
          full_name: "pbtest.Version32OneOf.int_one_of",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "test_oneof",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut string_one_of_size = 0;
    if let Some(Version32OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      string_one_of_size += ::pb_jelly::wire_format::serialized_length(1);
      string_one_of_size += ::pb_jelly::varint::serialized_length(l as u64);
      string_one_of_size += l;
    }
    size += string_one_of_size;
    let mut int_one_of_size = 0;
    if let Some(Version32OneOf_TestOneof::IntOneOf(ref val)) = self.test_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      int_one_of_size += ::pb_jelly::wire_format::serialized_length(2);
      int_one_of_size += l;
    }
    size += int_one_of_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(Version32OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(Version32OneOf_TestOneof::IntOneOf(ref val)) = self.test_oneof {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version32OneOf", 1)?;
          self.test_oneof = Some(Version32OneOf_TestOneof::StringOneOf(val));
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version32OneOf", 2)?;
          self.test_oneof = Some(Version32OneOf_TestOneof::IntOneOf(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version32OneOf {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "test_oneof" => {
        if let Some(Version32OneOf_TestOneof::StringOneOf(ref val)) = self.test_oneof {
          return Some("string_one_of");
        }
        if let Some(Version32OneOf_TestOneof::IntOneOf(ref val)) = self.test_oneof {
          return Some("int_one_of");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "string_one_of" => {
        match self.test_oneof {
          Some(Version32OneOf_TestOneof::StringOneOf(_)) => (),
          _ => {
            self.test_oneof = Some(Version32OneOf_TestOneof::StringOneOf(::std::default::Default::default()));
          },
        }
        if let Some(Version32OneOf_TestOneof::StringOneOf(ref mut val)) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int_one_of" => {
        match self.test_oneof {
          Some(Version32OneOf_TestOneof::IntOneOf(_)) => (),
          _ => {
            self.test_oneof = Some(Version32OneOf_TestOneof::IntOneOf(::std::default::Default::default()));
          },
        }
        if let Some(Version32OneOf_TestOneof::IntOneOf(ref mut val)) = self.test_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version31 {
  pub optional_string1: ::std::string::String,
}
impl ::std::default::Default for Version31 {
  fn default() -> Self {
    Version31 {
      optional_string1: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version31_default: Version31 = Version31::default();
}
impl ::pb_jelly::Message for Version31 {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version31",
      full_name: "pbtest.Version31",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "optional_string1",
          full_name: "pbtest.Version31.optional_string1",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<::std::string::String>(&self.optional_string1, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, ::std::string::String>(w, &self.optional_string1, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version31", 1)?;
          self.optional_string1 = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version31 {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "optional_string1" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_string1)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Version31SSO {
  pub optional_string1: ::compact_str::CompactString,
}
impl ::std::default::Default for Version31SSO {
  fn default() -> Self {
    Version31SSO {
      optional_string1: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version31SSO_default: Version31SSO = Version31SSO::default();
}
impl ::pb_jelly::Message for Version31SSO {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version31SSO",
      full_name: "pbtest.Version31SSO",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "optional_string1",
          full_name: "pbtest.Version31SSO.optional_string1",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<::compact_str::CompactString>(&self.optional_string1, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, ::compact_str::CompactString>(w, &self.optional_string1, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::compact_str::CompactString>(buf, typ, "Version31SSO", 1)?;
          self.optional_string1 = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version31SSO {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "optional_string1" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_string1)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct Version32 {
  pub optional_string1: ::std::string::String,
  pub optional_int32: i32,
  pub optional_int64: i64,
  pub optional_uint32: u32,
  pub optional_uint64: u64,
  pub optional_fixed64: ::pb_jelly::Fixed64,
  pub optional_fixed32: ::pb_jelly::Fixed32,
  pub optional_sfixed64: ::pb_jelly::Sfixed64,
  pub optional_sfixed32: ::pb_jelly::Sfixed32,
  pub optional_double: f64,
  pub optional_bool: bool,
  pub optional_string: ::std::string::String,
  pub optional_bytes: ::std::vec::Vec<u8>,
  pub optional_float: f32,
}
impl ::std::default::Default for Version32 {
  fn default() -> Self {
    Version32 {
      optional_string1: ::std::default::Default::default(),
      optional_int32: ::std::default::Default::default(),
      optional_int64: ::std::default::Default::default(),
      optional_uint32: ::std::default::Default::default(),
      optional_uint64: ::std::default::Default::default(),
      optional_fixed64: ::std::default::Default::default(),
      optional_fixed32: ::std::default::Default::default(),
      optional_sfixed64: ::std::default::Default::default(),
      optional_sfixed32: ::std::default::Default::default(),
      optional_double: ::std::default::Default::default(),
      optional_bool: ::std::default::Default::default(),
      optional_string: ::std::default::Default::default(),
      optional_bytes: ::std::default::Default::default(),
      optional_float: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref Version32_default: Version32 = Version32::default();
}
impl ::pb_jelly::Message for Version32 {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Version32",
      full_name: "pbtest.Version32",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "optional_string1",
          full_name: "pbtest.Version32.optional_string1",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_int32",
          full_name: "pbtest.Version32.optional_int32",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_int64",
          full_name: "pbtest.Version32.optional_int64",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_uint32",
          full_name: "pbtest.Version32.optional_uint32",
          index: 3,
          number: 4,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_uint64",
          full_name: "pbtest.Version32.optional_uint64",
          index: 4,
          number: 5,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_fixed64",
          full_name: "pbtest.Version32.optional_fixed64",
          index: 5,
          number: 6,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_fixed32",
          full_name: "pbtest.Version32.optional_fixed32",
          index: 6,
          number: 7,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_sfixed64",
          full_name: "pbtest.Version32.optional_sfixed64",
          index: 7,
          number: 8,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_sfixed32",
          full_name: "pbtest.Version32.optional_sfixed32",
          index: 8,
          number: 9,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_double",
          full_name: "pbtest.Version32.optional_double",
          index: 9,
          number: 10,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_bool",
          full_name: "pbtest.Version32.optional_bool",
          index: 10,
          number: 11,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_string",
          full_name: "pbtest.Version32.optional_string",
          index: 11,
          number: 12,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_bytes",
          full_name: "pbtest.Version32.optional_bytes",
          index: 12,
          number: 13,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_float",
          full_name: "pbtest.Version32.optional_float",
          index: 13,
          number: 14,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<::std::string::String>(&self.optional_string1, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    size += ::pb_jelly::helpers::compute_size_scalar::<i32>(&self.optional_int32, 2, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<i64>(&self.optional_int64, 3, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<u32>(&self.optional_uint32, 4, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<u64>(&self.optional_uint64, 5, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Fixed64>(&self.optional_fixed64, 6, ::pb_jelly::wire_format::Type::Fixed64);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Fixed32>(&self.optional_fixed32, 7, ::pb_jelly::wire_format::Type::Fixed32);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Sfixed64>(&self.optional_sfixed64, 8, ::pb_jelly::wire_format::Type::Fixed64);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Sfixed32>(&self.optional_sfixed32, 9, ::pb_jelly::wire_format::Type::Fixed32);
    size += ::pb_jelly::helpers::compute_size_scalar::<f64>(&self.optional_double, 10, ::pb_jelly::wire_format::Type::Fixed64);
    size += ::pb_jelly::helpers::compute_size_scalar::<bool>(&self.optional_bool, 11, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<::std::string::String>(&self.optional_string, 12, ::pb_jelly::wire_format::Type::LengthDelimited);
    size += ::pb_jelly::helpers::compute_size_scalar::<::std::vec::Vec<u8>>(&self.optional_bytes, 13, ::pb_jelly::wire_format::Type::LengthDelimited);
    size += ::pb_jelly::helpers::compute_size_scalar::<f32>(&self.optional_float, 14, ::pb_jelly::wire_format::Type::Fixed32);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, ::std::string::String>(w, &self.optional_string1, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    ::pb_jelly::helpers::serialize_scalar::<W, i32>(w, &self.optional_int32, 2, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, i64>(w, &self.optional_int64, 3, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, u32>(w, &self.optional_uint32, 4, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, u64>(w, &self.optional_uint64, 5, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Fixed64>(w, &self.optional_fixed64, 6, ::pb_jelly::wire_format::Type::Fixed64)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Fixed32>(w, &self.optional_fixed32, 7, ::pb_jelly::wire_format::Type::Fixed32)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Sfixed64>(w, &self.optional_sfixed64, 8, ::pb_jelly::wire_format::Type::Fixed64)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Sfixed32>(w, &self.optional_sfixed32, 9, ::pb_jelly::wire_format::Type::Fixed32)?;
    ::pb_jelly::helpers::serialize_scalar::<W, f64>(w, &self.optional_double, 10, ::pb_jelly::wire_format::Type::Fixed64)?;
    ::pb_jelly::helpers::serialize_scalar::<W, bool>(w, &self.optional_bool, 11, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::std::string::String>(w, &self.optional_string, 12, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::std::vec::Vec<u8>>(w, &self.optional_bytes, 13, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    ::pb_jelly::helpers::serialize_scalar::<W, f32>(w, &self.optional_float, 14, ::pb_jelly::wire_format::Type::Fixed32)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version32", 1)?;
          self.optional_string1 = val;
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version32", 2)?;
          self.optional_int32 = val;
        }
        3 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version32", 3)?;
          self.optional_int64 = val;
        }
        4 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version32", 4)?;
          self.optional_uint32 = val;
        }
        5 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version32", 5)?;
          self.optional_uint64 = val;
        }
        6 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Fixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "Version32", 6)?;
          self.optional_fixed64 = val;
        }
        7 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Fixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "Version32", 7)?;
          self.optional_fixed32 = val;
        }
        8 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Sfixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "Version32", 8)?;
          self.optional_sfixed64 = val;
        }
        9 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Sfixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "Version32", 9)?;
          self.optional_sfixed32 = val;
        }
        10 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "Version32", 10)?;
          self.optional_double = val;
        }
        11 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, bool>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "Version32", 11)?;
          self.optional_bool = val;
        }
        12 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "Version32", 12)?;
          self.optional_string = val;
        }
        13 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::vec::Vec<u8>>(buf, typ, "Version32", 13)?;
          self.optional_bytes = val;
        }
        14 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "Version32", 14)?;
          self.optional_float = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Version32 {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "optional_string1" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_string1)
      }
      "optional_int32" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_int32)
      }
      "optional_int64" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_int64)
      }
      "optional_uint32" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_uint32)
      }
      "optional_uint64" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_uint64)
      }
      "optional_fixed64" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_fixed64)
      }
      "optional_fixed32" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_fixed32)
      }
      "optional_sfixed64" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_sfixed64)
      }
      "optional_sfixed32" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_sfixed32)
      }
      "optional_double" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_double)
      }
      "optional_bool" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_bool)
      }
      "optional_string" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_string)
      }
      "optional_bytes" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_bytes)
      }
      "optional_float" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_float)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct TestMessage3 {
  pub optional_int32: i32,
  pub optional_int64: i64,
  pub optional_uint32: u32,
  pub optional_uint64: u64,
  pub optional_fixed64: ::pb_jelly::Fixed64,
  pub optional_fixed32: ::pb_jelly::Fixed32,
  pub optional_sfixed64: ::pb_jelly::Sfixed64,
  pub optional_sfixed32: ::pb_jelly::Sfixed32,
  pub optional_double: f64,
  pub optional_bool: bool,
  pub optional_string: ::std::string::String,
  pub optional_bytes: ::std::vec::Vec<u8>,
  pub optional_float: f32,
  pub optional_foreign_message: ::std::option::Option<ForeignMessage3>,
  pub optional_nested_enum: TestMessage3_NestedEnum3,
  pub optional_foreign_enum: ForeignEnum3,
  pub repeated_int32: ::std::vec::Vec<i32>,
  pub repeated_int64: ::std::vec::Vec<i64>,
  pub repeated_uint32: ::std::vec::Vec<u32>,
  pub repeated_uint64: ::std::vec::Vec<u64>,
  pub repeated_fixed64: ::std::vec::Vec<::pb_jelly::Fixed64>,
  pub repeated_fixed32: ::std::vec::Vec<::pb_jelly::Fixed32>,
  pub repeated_sfixed64: ::std::vec::Vec<::pb_jelly::Sfixed64>,
  pub repeated_sfixed32: ::std::vec::Vec<::pb_jelly::Sfixed32>,
  pub repeated_double: ::std::vec::Vec<f64>,
  pub repeated_bool: ::std::vec::Vec<bool>,
  pub repeated_string: ::std::vec::Vec<::std::string::String>,
  pub repeated_bytes: ::std::vec::Vec<::std::vec::Vec<u8>>,
  pub repeated_float: ::std::vec::Vec<f32>,
  pub repeated_foreign_message: ::std::vec::Vec<ForeignMessage3>,
  pub repeated_nested_enum: ::std::vec::Vec<TestMessage3_NestedEnum3>,
  pub repeated_foreign_enum: ::std::vec::Vec<ForeignEnum3>,
  /// Message compatibility with proto2.
  /// proto2 enum are not compatible, but messages are.
  pub proto2_msg: ::std::option::Option<super::pbtest2::ForeignMessage>,
  pub proto2_msg_empty: ::std::option::Option<super::pbtest2::ForeignMessage>,
  pub proto2_msg_missing: ::std::option::Option<super::pbtest2::ForeignMessage>,
  pub optional_foreign_message_boxed: ::std::option::Option<::std::boxed::Box<ForeignMessage3>>,
  pub optional_foreign_message_nonnullable: ForeignMessage3,
  pub nested: TestMessage3_NestedMessage,
  pub nested_nullable: ::std::option::Option<TestMessage3_NestedMessage>,
  pub nested_repeated: ::std::vec::Vec<TestMessage3_NestedMessage>,
  pub fixed_length: [u8; 4],
  pub fixed_length_repeated: ::std::vec::Vec<[u8; 4]>,
  pub zero_or_fixed_length: Option<[u8; 4]>,
  pub zero_or_fixed_length_repeated: ::std::vec::Vec<Option<[u8; 4]>>,
  pub oneof_int: ::std::option::Option<TestMessage3_OneofInt>,
  pub oneof_foreign: ::std::option::Option<TestMessage3_OneofForeign>,
  pub oneof_zero: ::std::option::Option<TestMessage3_OneofZero>,
  pub oneof_null: ::std::option::Option<TestMessage3_OneofNull>,
  pub oneof_unset: ::std::option::Option<TestMessage3_OneofUnset>,
  pub oneof_primitives: ::std::option::Option<TestMessage3_OneofPrimitives>,
  pub oneof_empty_field: TestMessage3_OneofEmptyField,
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofInt {
  Int1(i32),
  Foreign1(ForeignMessage3),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofForeign {
  Int2(i32),
  Foreign2(ForeignMessage3),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofZero {
  Int3(i32),
  Foreign3(ForeignMessage3),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofNull {
  Int4(i32),
  Foreign4(ForeignMessage3),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofUnset {
  Int5(i32),
  Foreign5(ForeignMessage3),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofPrimitives {
  Int6(i32),
  Bool6(bool),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestMessage3_OneofEmptyField {
  A,
  B,
  C(i32),
}
impl ::std::default::Default for TestMessage3 {
  fn default() -> Self {
    TestMessage3 {
      optional_int32: ::std::default::Default::default(),
      optional_int64: ::std::default::Default::default(),
      optional_uint32: ::std::default::Default::default(),
      optional_uint64: ::std::default::Default::default(),
      optional_fixed64: ::std::default::Default::default(),
      optional_fixed32: ::std::default::Default::default(),
      optional_sfixed64: ::std::default::Default::default(),
      optional_sfixed32: ::std::default::Default::default(),
      optional_double: ::std::default::Default::default(),
      optional_bool: ::std::default::Default::default(),
      optional_string: ::std::default::Default::default(),
      optional_bytes: ::std::default::Default::default(),
      optional_float: ::std::default::Default::default(),
      optional_foreign_message: ::std::default::Default::default(),
      optional_nested_enum: ::std::default::Default::default(),
      optional_foreign_enum: ::std::default::Default::default(),
      repeated_int32: ::std::default::Default::default(),
      repeated_int64: ::std::default::Default::default(),
      repeated_uint32: ::std::default::Default::default(),
      repeated_uint64: ::std::default::Default::default(),
      repeated_fixed64: ::std::default::Default::default(),
      repeated_fixed32: ::std::default::Default::default(),
      repeated_sfixed64: ::std::default::Default::default(),
      repeated_sfixed32: ::std::default::Default::default(),
      repeated_double: ::std::default::Default::default(),
      repeated_bool: ::std::default::Default::default(),
      repeated_string: ::std::default::Default::default(),
      repeated_bytes: ::std::default::Default::default(),
      repeated_float: ::std::default::Default::default(),
      repeated_foreign_message: ::std::default::Default::default(),
      repeated_nested_enum: ::std::default::Default::default(),
      repeated_foreign_enum: ::std::default::Default::default(),
      proto2_msg: ::std::default::Default::default(),
      proto2_msg_empty: ::std::default::Default::default(),
      proto2_msg_missing: ::std::default::Default::default(),
      optional_foreign_message_boxed: ::std::default::Default::default(),
      optional_foreign_message_nonnullable: ::std::default::Default::default(),
      nested: ::std::default::Default::default(),
      nested_nullable: ::std::default::Default::default(),
      nested_repeated: ::std::default::Default::default(),
      fixed_length: ::std::default::Default::default(),
      fixed_length_repeated: ::std::default::Default::default(),
      zero_or_fixed_length: ::std::default::Default::default(),
      zero_or_fixed_length_repeated: ::std::default::Default::default(),
      oneof_int: None,
      oneof_foreign: None,
      oneof_zero: None,
      oneof_null: None,
      oneof_unset: None,
      oneof_primitives: None,
      oneof_empty_field: TestMessage3_OneofEmptyField::A,
    }
  }
}
lazy_static! {
  pub static ref TestMessage3_default: TestMessage3 = TestMessage3::default();
}
impl ::pb_jelly::Message for TestMessage3 {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage3",
      full_name: "pbtest.TestMessage3",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "optional_int32",
          full_name: "pbtest.TestMessage3.optional_int32",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_int64",
          full_name: "pbtest.TestMessage3.optional_int64",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_uint32",
          full_name: "pbtest.TestMessage3.optional_uint32",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_uint64",
          full_name: "pbtest.TestMessage3.optional_uint64",
          index: 3,
          number: 4,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_fixed64",
          full_name: "pbtest.TestMessage3.optional_fixed64",
          index: 4,
          number: 8,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_fixed32",
          full_name: "pbtest.TestMessage3.optional_fixed32",
          index: 5,
          number: 9,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_sfixed64",
          full_name: "pbtest.TestMessage3.optional_sfixed64",
          index: 6,
          number: 10,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_sfixed32",
          full_name: "pbtest.TestMessage3.optional_sfixed32",
          index: 7,
          number: 11,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_double",
          full_name: "pbtest.TestMessage3.optional_double",
          index: 8,
          number: 12,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_bool",
          full_name: "pbtest.TestMessage3.optional_bool",
          index: 9,
          number: 13,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_string",
          full_name: "pbtest.TestMessage3.optional_string",
          index: 10,
          number: 14,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_bytes",
          full_name: "pbtest.TestMessage3.optional_bytes",
          index: 11,
          number: 15,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_float",
          full_name: "pbtest.TestMessage3.optional_float",
          index: 12,
          number: 16,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_foreign_message",
          full_name: "pbtest.TestMessage3.optional_foreign_message",
          index: 13,
          number: 19,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_nested_enum",
          full_name: "pbtest.TestMessage3.optional_nested_enum",
          index: 14,
          number: 21,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_foreign_enum",
          full_name: "pbtest.TestMessage3.optional_foreign_enum",
          index: 15,
          number: 22,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_int32",
          full_name: "pbtest.TestMessage3.repeated_int32",
          index: 16,
          number: 31,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_int64",
          full_name: "pbtest.TestMessage3.repeated_int64",
          index: 17,
          number: 32,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_uint32",
          full_name: "pbtest.TestMessage3.repeated_uint32",
          index: 18,
          number: 33,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_uint64",
          full_name: "pbtest.TestMessage3.repeated_uint64",
          index: 19,
          number: 34,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_fixed64",
          full_name: "pbtest.TestMessage3.repeated_fixed64",
          index: 20,
          number: 38,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_fixed32",
          full_name: "pbtest.TestMessage3.repeated_fixed32",
          index: 21,
          number: 39,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_sfixed64",
          full_name: "pbtest.TestMessage3.repeated_sfixed64",
          index: 22,
          number: 40,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_sfixed32",
          full_name: "pbtest.TestMessage3.repeated_sfixed32",
          index: 23,
          number: 41,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_double",
          full_name: "pbtest.TestMessage3.repeated_double",
          index: 24,
          number: 42,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_bool",
          full_name: "pbtest.TestMessage3.repeated_bool",
          index: 25,
          number: 43,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_string",
          full_name: "pbtest.TestMessage3.repeated_string",
          index: 26,
          number: 44,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_bytes",
          full_name: "pbtest.TestMessage3.repeated_bytes",
          index: 27,
          number: 45,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_float",
          full_name: "pbtest.TestMessage3.repeated_float",
          index: 28,
          number: 46,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_foreign_message",
          full_name: "pbtest.TestMessage3.repeated_foreign_message",
          index: 29,
          number: 49,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_nested_enum",
          full_name: "pbtest.TestMessage3.repeated_nested_enum",
          index: 30,
          number: 51,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "repeated_foreign_enum",
          full_name: "pbtest.TestMessage3.repeated_foreign_enum",
          index: 31,
          number: 52,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "proto2_msg",
          full_name: "pbtest.TestMessage3.proto2_msg",
          index: 32,
          number: 53,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "proto2_msg_empty",
          full_name: "pbtest.TestMessage3.proto2_msg_empty",
          index: 33,
          number: 54,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "proto2_msg_missing",
          full_name: "pbtest.TestMessage3.proto2_msg_missing",
          index: 34,
          number: 55,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_foreign_message_boxed",
          full_name: "pbtest.TestMessage3.optional_foreign_message_boxed",
          index: 35,
          number: 56,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "optional_foreign_message_nonnullable",
          full_name: "pbtest.TestMessage3.optional_foreign_message_nonnullable",
          index: 36,
          number: 69,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "int1",
          full_name: "pbtest.TestMessage3.int1",
          index: 37,
          number: 57,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "foreign1",
          full_name: "pbtest.TestMessage3.foreign1",
          index: 38,
          number: 58,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int2",
          full_name: "pbtest.TestMessage3.int2",
          index: 39,
          number: 59,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(1),
        },
        ::pb_jelly::FieldDescriptor {
          name: "foreign2",
          full_name: "pbtest.TestMessage3.foreign2",
          index: 40,
          number: 60,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(1),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int3",
          full_name: "pbtest.TestMessage3.int3",
          index: 41,
          number: 61,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(2),
        },
        ::pb_jelly::FieldDescriptor {
          name: "foreign3",
          full_name: "pbtest.TestMessage3.foreign3",
          index: 42,
          number: 62,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(2),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int4",
          full_name: "pbtest.TestMessage3.int4",
          index: 43,
          number: 63,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(3),
        },
        ::pb_jelly::FieldDescriptor {
          name: "foreign4",
          full_name: "pbtest.TestMessage3.foreign4",
          index: 44,
          number: 64,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(3),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int5",
          full_name: "pbtest.TestMessage3.int5",
          index: 45,
          number: 65,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(4),
        },
        ::pb_jelly::FieldDescriptor {
          name: "foreign5",
          full_name: "pbtest.TestMessage3.foreign5",
          index: 46,
          number: 66,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(4),
        },
        ::pb_jelly::FieldDescriptor {
          name: "int6",
          full_name: "pbtest.TestMessage3.int6",
          index: 47,
          number: 67,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(5),
        },
        ::pb_jelly::FieldDescriptor {
          name: "bool6",
          full_name: "pbtest.TestMessage3.bool6",
          index: 48,
          number: 68,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(5),
        },
        ::pb_jelly::FieldDescriptor {
          name: "a",
          full_name: "pbtest.TestMessage3.a",
          index: 49,
          number: 70,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(6),
        },
        ::pb_jelly::FieldDescriptor {
          name: "b",
          full_name: "pbtest.TestMessage3.b",
          index: 50,
          number: 71,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(6),
        },
        ::pb_jelly::FieldDescriptor {
          name: "c",
          full_name: "pbtest.TestMessage3.c",
          index: 51,
          number: 72,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(6),
        },
        ::pb_jelly::FieldDescriptor {
          name: "nested",
          full_name: "pbtest.TestMessage3.nested",
          index: 52,
          number: 73,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "nested_nullable",
          full_name: "pbtest.TestMessage3.nested_nullable",
          index: 53,
          number: 74,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "nested_repeated",
          full_name: "pbtest.TestMessage3.nested_repeated",
          index: 54,
          number: 75,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "fixed_length",
          full_name: "pbtest.TestMessage3.fixed_length",
          index: 55,
          number: 76,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "fixed_length_repeated",
          full_name: "pbtest.TestMessage3.fixed_length_repeated",
          index: 56,
          number: 77,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "zero_or_fixed_length",
          full_name: "pbtest.TestMessage3.zero_or_fixed_length",
          index: 57,
          number: 78,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "zero_or_fixed_length_repeated",
          full_name: "pbtest.TestMessage3.zero_or_fixed_length_repeated",
          index: 58,
          number: 79,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "oneof_int",
        },
        ::pb_jelly::OneofDescriptor {
          name: "oneof_foreign",
        },
        ::pb_jelly::OneofDescriptor {
          name: "oneof_zero",
        },
        ::pb_jelly::OneofDescriptor {
          name: "oneof_null",
        },
        ::pb_jelly::OneofDescriptor {
          name: "oneof_unset",
        },
        ::pb_jelly::OneofDescriptor {
          name: "oneof_primitives",
        },
        ::pb_jelly::OneofDescriptor {
          name: "oneof_empty_field",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<i32>(&self.optional_int32, 1, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<i64>(&self.optional_int64, 2, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<u32>(&self.optional_uint32, 3, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<u64>(&self.optional_uint64, 4, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Fixed64>(&self.optional_fixed64, 8, ::pb_jelly::wire_format::Type::Fixed64);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Fixed32>(&self.optional_fixed32, 9, ::pb_jelly::wire_format::Type::Fixed32);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Sfixed64>(&self.optional_sfixed64, 10, ::pb_jelly::wire_format::Type::Fixed64);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Sfixed32>(&self.optional_sfixed32, 11, ::pb_jelly::wire_format::Type::Fixed32);
    size += ::pb_jelly::helpers::compute_size_scalar::<f64>(&self.optional_double, 12, ::pb_jelly::wire_format::Type::Fixed64);
    size += ::pb_jelly::helpers::compute_size_scalar::<bool>(&self.optional_bool, 13, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<::std::string::String>(&self.optional_string, 14, ::pb_jelly::wire_format::Type::LengthDelimited);
    size += ::pb_jelly::helpers::compute_size_scalar::<::std::vec::Vec<u8>>(&self.optional_bytes, 15, ::pb_jelly::wire_format::Type::LengthDelimited);
    size += ::pb_jelly::helpers::compute_size_scalar::<f32>(&self.optional_float, 16, ::pb_jelly::wire_format::Type::Fixed32);
    let mut optional_foreign_message_size = 0;
    if let Some(ref val) = self.optional_foreign_message {
      let l = ::pb_jelly::Message::compute_size(val);
      optional_foreign_message_size += ::pb_jelly::wire_format::serialized_length(19);
      optional_foreign_message_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_foreign_message_size += l;
    }
    size += optional_foreign_message_size;
    size += ::pb_jelly::helpers::compute_size_scalar::<TestMessage3_NestedEnum3>(&self.optional_nested_enum, 21, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<ForeignEnum3>(&self.optional_foreign_enum, 22, ::pb_jelly::wire_format::Type::Varint);
    let mut repeated_int32_size = 0;
    for val in &self.repeated_int32 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_int32_size += l;
    }
    if !self.repeated_int32.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(31);
      size += ::pb_jelly::varint::serialized_length(repeated_int32_size as u64);
    }
    size += repeated_int32_size;
    let mut repeated_int64_size = 0;
    for val in &self.repeated_int64 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_int64_size += l;
    }
    if !self.repeated_int64.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(32);
      size += ::pb_jelly::varint::serialized_length(repeated_int64_size as u64);
    }
    size += repeated_int64_size;
    let mut repeated_uint32_size = 0;
    for val in &self.repeated_uint32 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_uint32_size += l;
    }
    if !self.repeated_uint32.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(33);
      size += ::pb_jelly::varint::serialized_length(repeated_uint32_size as u64);
    }
    size += repeated_uint32_size;
    let mut repeated_uint64_size = 0;
    for val in &self.repeated_uint64 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_uint64_size += l;
    }
    if !self.repeated_uint64.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(34);
      size += ::pb_jelly::varint::serialized_length(repeated_uint64_size as u64);
    }
    size += repeated_uint64_size;
    let mut repeated_fixed64_size = 0;
    for val in &self.repeated_fixed64 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_fixed64_size += l;
    }
    if !self.repeated_fixed64.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(38);
      size += ::pb_jelly::varint::serialized_length(repeated_fixed64_size as u64);
    }
    size += repeated_fixed64_size;
    let mut repeated_fixed32_size = 0;
    for val in &self.repeated_fixed32 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_fixed32_size += l;
    }
    if !self.repeated_fixed32.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(39);
      size += ::pb_jelly::varint::serialized_length(repeated_fixed32_size as u64);
    }
    size += repeated_fixed32_size;
    let mut repeated_sfixed64_size = 0;
    for val in &self.repeated_sfixed64 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_sfixed64_size += l;
    }
    if !self.repeated_sfixed64.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(40);
      size += ::pb_jelly::varint::serialized_length(repeated_sfixed64_size as u64);
    }
    size += repeated_sfixed64_size;
    let mut repeated_sfixed32_size = 0;
    for val in &self.repeated_sfixed32 {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_sfixed32_size += l;
    }
    if !self.repeated_sfixed32.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(41);
      size += ::pb_jelly::varint::serialized_length(repeated_sfixed32_size as u64);
    }
    size += repeated_sfixed32_size;
    let mut repeated_double_size = 0;
    for val in &self.repeated_double {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_double_size += l;
    }
    if !self.repeated_double.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(42);
      size += ::pb_jelly::varint::serialized_length(repeated_double_size as u64);
    }
    size += repeated_double_size;
    let mut repeated_bool_size = 0;
    for val in &self.repeated_bool {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_bool_size += l;
    }
    if !self.repeated_bool.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(43);
      size += ::pb_jelly::varint::serialized_length(repeated_bool_size as u64);
    }
    size += repeated_bool_size;
    let mut repeated_string_size = 0;
    for val in &self.repeated_string {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_string_size += ::pb_jelly::wire_format::serialized_length(44);
      repeated_string_size += ::pb_jelly::varint::serialized_length(l as u64);
      repeated_string_size += l;
    }
    size += repeated_string_size;
    let mut repeated_bytes_size = 0;
    for val in &self.repeated_bytes {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_bytes_size += ::pb_jelly::wire_format::serialized_length(45);
      repeated_bytes_size += ::pb_jelly::varint::serialized_length(l as u64);
      repeated_bytes_size += l;
    }
    size += repeated_bytes_size;
    let mut repeated_float_size = 0;
    for val in &self.repeated_float {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_float_size += l;
    }
    if !self.repeated_float.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(46);
      size += ::pb_jelly::varint::serialized_length(repeated_float_size as u64);
    }
    size += repeated_float_size;
    let mut repeated_foreign_message_size = 0;
    for val in &self.repeated_foreign_message {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_foreign_message_size += ::pb_jelly::wire_format::serialized_length(49);
      repeated_foreign_message_size += ::pb_jelly::varint::serialized_length(l as u64);
      repeated_foreign_message_size += l;
    }
    size += repeated_foreign_message_size;
    let mut repeated_nested_enum_size = 0;
    for val in &self.repeated_nested_enum {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_nested_enum_size += l;
    }
    if !self.repeated_nested_enum.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(51);
      size += ::pb_jelly::varint::serialized_length(repeated_nested_enum_size as u64);
    }
    size += repeated_nested_enum_size;
    let mut repeated_foreign_enum_size = 0;
    for val in &self.repeated_foreign_enum {
      let l = ::pb_jelly::Message::compute_size(val);
      repeated_foreign_enum_size += l;
    }
    if !self.repeated_foreign_enum.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(52);
      size += ::pb_jelly::varint::serialized_length(repeated_foreign_enum_size as u64);
    }
    size += repeated_foreign_enum_size;
    let mut proto2_msg_size = 0;
    if let Some(ref val) = self.proto2_msg {
      let l = ::pb_jelly::Message::compute_size(val);
      proto2_msg_size += ::pb_jelly::wire_format::serialized_length(53);
      proto2_msg_size += ::pb_jelly::varint::serialized_length(l as u64);
      proto2_msg_size += l;
    }
    size += proto2_msg_size;
    let mut proto2_msg_empty_size = 0;
    if let Some(ref val) = self.proto2_msg_empty {
      let l = ::pb_jelly::Message::compute_size(val);
      proto2_msg_empty_size += ::pb_jelly::wire_format::serialized_length(54);
      proto2_msg_empty_size += ::pb_jelly::varint::serialized_length(l as u64);
      proto2_msg_empty_size += l;
    }
    size += proto2_msg_empty_size;
    let mut proto2_msg_missing_size = 0;
    if let Some(ref val) = self.proto2_msg_missing {
      let l = ::pb_jelly::Message::compute_size(val);
      proto2_msg_missing_size += ::pb_jelly::wire_format::serialized_length(55);
      proto2_msg_missing_size += ::pb_jelly::varint::serialized_length(l as u64);
      proto2_msg_missing_size += l;
    }
    size += proto2_msg_missing_size;
    let mut optional_foreign_message_boxed_size = 0;
    if let Some(ref val) = self.optional_foreign_message_boxed {
      let val = &**val;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_foreign_message_boxed_size += ::pb_jelly::wire_format::serialized_length(56);
      optional_foreign_message_boxed_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_foreign_message_boxed_size += l;
    }
    size += optional_foreign_message_boxed_size;
    let mut optional_foreign_message_nonnullable_size = 0;
     {
      let val = &self.optional_foreign_message_nonnullable;
      let l = ::pb_jelly::Message::compute_size(val);
      optional_foreign_message_nonnullable_size += ::pb_jelly::wire_format::serialized_length(69);
      optional_foreign_message_nonnullable_size += ::pb_jelly::varint::serialized_length(l as u64);
      optional_foreign_message_nonnullable_size += l;
    }
    size += optional_foreign_message_nonnullable_size;
    let mut int1_size = 0;
    if let Some(TestMessage3_OneofInt::Int1(ref val)) = self.oneof_int {
      let l = ::pb_jelly::Message::compute_size(val);
      int1_size += ::pb_jelly::wire_format::serialized_length(57);
      int1_size += l;
    }
    size += int1_size;
    let mut foreign1_size = 0;
    if let Some(TestMessage3_OneofInt::Foreign1(ref val)) = self.oneof_int {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign1_size += ::pb_jelly::wire_format::serialized_length(58);
      foreign1_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign1_size += l;
    }
    size += foreign1_size;
    let mut int2_size = 0;
    if let Some(TestMessage3_OneofForeign::Int2(ref val)) = self.oneof_foreign {
      let l = ::pb_jelly::Message::compute_size(val);
      int2_size += ::pb_jelly::wire_format::serialized_length(59);
      int2_size += l;
    }
    size += int2_size;
    let mut foreign2_size = 0;
    if let Some(TestMessage3_OneofForeign::Foreign2(ref val)) = self.oneof_foreign {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign2_size += ::pb_jelly::wire_format::serialized_length(60);
      foreign2_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign2_size += l;
    }
    size += foreign2_size;
    let mut int3_size = 0;
    if let Some(TestMessage3_OneofZero::Int3(ref val)) = self.oneof_zero {
      let l = ::pb_jelly::Message::compute_size(val);
      int3_size += ::pb_jelly::wire_format::serialized_length(61);
      int3_size += l;
    }
    size += int3_size;
    let mut foreign3_size = 0;
    if let Some(TestMessage3_OneofZero::Foreign3(ref val)) = self.oneof_zero {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign3_size += ::pb_jelly::wire_format::serialized_length(62);
      foreign3_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign3_size += l;
    }
    size += foreign3_size;
    let mut int4_size = 0;
    if let Some(TestMessage3_OneofNull::Int4(ref val)) = self.oneof_null {
      let l = ::pb_jelly::Message::compute_size(val);
      int4_size += ::pb_jelly::wire_format::serialized_length(63);
      int4_size += l;
    }
    size += int4_size;
    let mut foreign4_size = 0;
    if let Some(TestMessage3_OneofNull::Foreign4(ref val)) = self.oneof_null {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign4_size += ::pb_jelly::wire_format::serialized_length(64);
      foreign4_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign4_size += l;
    }
    size += foreign4_size;
    let mut int5_size = 0;
    if let Some(TestMessage3_OneofUnset::Int5(ref val)) = self.oneof_unset {
      let l = ::pb_jelly::Message::compute_size(val);
      int5_size += ::pb_jelly::wire_format::serialized_length(65);
      int5_size += l;
    }
    size += int5_size;
    let mut foreign5_size = 0;
    if let Some(TestMessage3_OneofUnset::Foreign5(ref val)) = self.oneof_unset {
      let l = ::pb_jelly::Message::compute_size(val);
      foreign5_size += ::pb_jelly::wire_format::serialized_length(66);
      foreign5_size += ::pb_jelly::varint::serialized_length(l as u64);
      foreign5_size += l;
    }
    size += foreign5_size;
    let mut int6_size = 0;
    if let Some(TestMessage3_OneofPrimitives::Int6(ref val)) = self.oneof_primitives {
      let l = ::pb_jelly::Message::compute_size(val);
      int6_size += ::pb_jelly::wire_format::serialized_length(67);
      int6_size += l;
    }
    size += int6_size;
    let mut bool6_size = 0;
    if let Some(TestMessage3_OneofPrimitives::Bool6(ref val)) = self.oneof_primitives {
      let l = ::pb_jelly::Message::compute_size(val);
      bool6_size += ::pb_jelly::wire_format::serialized_length(68);
      bool6_size += l;
    }
    size += bool6_size;
    let mut a_size = 0;
    if let TestMessage3_OneofEmptyField::A = self.oneof_empty_field {
      let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
      let l = ::pb_jelly::Message::compute_size(val);
      a_size += ::pb_jelly::wire_format::serialized_length(70);
      a_size += ::pb_jelly::varint::serialized_length(l as u64);
      a_size += l;
    }
    size += a_size;
    let mut b_size = 0;
    if let TestMessage3_OneofEmptyField::B = self.oneof_empty_field {
      let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
      let l = ::pb_jelly::Message::compute_size(val);
      b_size += ::pb_jelly::wire_format::serialized_length(71);
      b_size += ::pb_jelly::varint::serialized_length(l as u64);
      b_size += l;
    }
    size += b_size;
    let mut c_size = 0;
    if let TestMessage3_OneofEmptyField::C(ref val) = self.oneof_empty_field {
      let l = ::pb_jelly::Message::compute_size(val);
      c_size += ::pb_jelly::wire_format::serialized_length(72);
      c_size += l;
    }
    size += c_size;
    let mut nested_size = 0;
     {
      let val = &self.nested;
      let l = ::pb_jelly::Message::compute_size(val);
      nested_size += ::pb_jelly::wire_format::serialized_length(73);
      nested_size += ::pb_jelly::varint::serialized_length(l as u64);
      nested_size += l;
    }
    size += nested_size;
    let mut nested_nullable_size = 0;
    if let Some(ref val) = self.nested_nullable {
      let l = ::pb_jelly::Message::compute_size(val);
      nested_nullable_size += ::pb_jelly::wire_format::serialized_length(74);
      nested_nullable_size += ::pb_jelly::varint::serialized_length(l as u64);
      nested_nullable_size += l;
    }
    size += nested_nullable_size;
    let mut nested_repeated_size = 0;
    for val in &self.nested_repeated {
      let l = ::pb_jelly::Message::compute_size(val);
      nested_repeated_size += ::pb_jelly::wire_format::serialized_length(75);
      nested_repeated_size += ::pb_jelly::varint::serialized_length(l as u64);
      nested_repeated_size += l;
    }
    size += nested_repeated_size;
    size += ::pb_jelly::helpers::compute_size_scalar::<[u8; 4]>(&self.fixed_length, 76, ::pb_jelly::wire_format::Type::LengthDelimited);
    let mut fixed_length_repeated_size = 0;
    for val in &self.fixed_length_repeated {
      let l = ::pb_jelly::Message::compute_size(val);
      fixed_length_repeated_size += ::pb_jelly::wire_format::serialized_length(77);
      fixed_length_repeated_size += ::pb_jelly::varint::serialized_length(l as u64);
      fixed_length_repeated_size += l;
    }
    size += fixed_length_repeated_size;
    size += ::pb_jelly::helpers::compute_size_scalar::<Option<[u8; 4]>>(&self.zero_or_fixed_length, 78, ::pb_jelly::wire_format::Type::LengthDelimited);
    let mut zero_or_fixed_length_repeated_size = 0;
    for val in &self.zero_or_fixed_length_repeated {
      let l = ::pb_jelly::Message::compute_size(val);
      zero_or_fixed_length_repeated_size += ::pb_jelly::wire_format::serialized_length(79);
      zero_or_fixed_length_repeated_size += ::pb_jelly::varint::serialized_length(l as u64);
      zero_or_fixed_length_repeated_size += l;
    }
    size += zero_or_fixed_length_repeated_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize {
    let mut size = 0;
    if self.fixed_length != <[u8; 4] as ::std::default::Default>::default() {
      let val = &self.fixed_length;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.fixed_length_repeated {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.zero_or_fixed_length != <Option<[u8; 4]> as ::std::default::Default>::default() {
      let val = &self.zero_or_fixed_length;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.zero_or_fixed_length_repeated {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, i32>(w, &self.optional_int32, 1, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, i64>(w, &self.optional_int64, 2, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, u32>(w, &self.optional_uint32, 3, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, u64>(w, &self.optional_uint64, 4, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Fixed64>(w, &self.optional_fixed64, 8, ::pb_jelly::wire_format::Type::Fixed64)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Fixed32>(w, &self.optional_fixed32, 9, ::pb_jelly::wire_format::Type::Fixed32)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Sfixed64>(w, &self.optional_sfixed64, 10, ::pb_jelly::wire_format::Type::Fixed64)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Sfixed32>(w, &self.optional_sfixed32, 11, ::pb_jelly::wire_format::Type::Fixed32)?;
    ::pb_jelly::helpers::serialize_scalar::<W, f64>(w, &self.optional_double, 12, ::pb_jelly::wire_format::Type::Fixed64)?;
    ::pb_jelly::helpers::serialize_scalar::<W, bool>(w, &self.optional_bool, 13, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::std::string::String>(w, &self.optional_string, 14, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::std::vec::Vec<u8>>(w, &self.optional_bytes, 15, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    ::pb_jelly::helpers::serialize_scalar::<W, f32>(w, &self.optional_float, 16, ::pb_jelly::wire_format::Type::Fixed32)?;
    if let Some(ref val) = self.optional_foreign_message {
      ::pb_jelly::wire_format::write(19, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    ::pb_jelly::helpers::serialize_scalar::<W, TestMessage3_NestedEnum3>(w, &self.optional_nested_enum, 21, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ForeignEnum3>(w, &self.optional_foreign_enum, 22, ::pb_jelly::wire_format::Type::Varint)?;
    if !self.repeated_int32.is_empty() {
      let mut size = 0;
      for val in &self.repeated_int32 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(31, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_int32 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_int64.is_empty() {
      let mut size = 0;
      for val in &self.repeated_int64 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(32, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_int64 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_uint32.is_empty() {
      let mut size = 0;
      for val in &self.repeated_uint32 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(33, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_uint32 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_uint64.is_empty() {
      let mut size = 0;
      for val in &self.repeated_uint64 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(34, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_uint64 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_fixed64.is_empty() {
      let mut size = 0;
      for val in &self.repeated_fixed64 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(38, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_fixed64 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_fixed32.is_empty() {
      let mut size = 0;
      for val in &self.repeated_fixed32 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(39, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_fixed32 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_sfixed64.is_empty() {
      let mut size = 0;
      for val in &self.repeated_sfixed64 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(40, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_sfixed64 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_sfixed32.is_empty() {
      let mut size = 0;
      for val in &self.repeated_sfixed32 {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(41, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_sfixed32 {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_double.is_empty() {
      let mut size = 0;
      for val in &self.repeated_double {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(42, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_double {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_bool.is_empty() {
      let mut size = 0;
      for val in &self.repeated_bool {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(43, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_bool {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_string {
      ::pb_jelly::wire_format::write(44, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_bytes {
      ::pb_jelly::wire_format::write(45, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_float.is_empty() {
      let mut size = 0;
      for val in &self.repeated_float {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(46, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_float {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.repeated_foreign_message {
      ::pb_jelly::wire_format::write(49, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_nested_enum.is_empty() {
      let mut size = 0;
      for val in &self.repeated_nested_enum {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(51, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_nested_enum {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if !self.repeated_foreign_enum.is_empty() {
      let mut size = 0;
      for val in &self.repeated_foreign_enum {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(52, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.repeated_foreign_enum {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.proto2_msg {
      ::pb_jelly::wire_format::write(53, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.proto2_msg_empty {
      ::pb_jelly::wire_format::write(54, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.proto2_msg_missing {
      ::pb_jelly::wire_format::write(55, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.optional_foreign_message_boxed {
      let val = &**val;
      ::pb_jelly::wire_format::write(56, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofInt::Int1(ref val)) = self.oneof_int {
      ::pb_jelly::wire_format::write(57, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofInt::Foreign1(ref val)) = self.oneof_int {
      ::pb_jelly::wire_format::write(58, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofForeign::Int2(ref val)) = self.oneof_foreign {
      ::pb_jelly::wire_format::write(59, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofForeign::Foreign2(ref val)) = self.oneof_foreign {
      ::pb_jelly::wire_format::write(60, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofZero::Int3(ref val)) = self.oneof_zero {
      ::pb_jelly::wire_format::write(61, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofZero::Foreign3(ref val)) = self.oneof_zero {
      ::pb_jelly::wire_format::write(62, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofNull::Int4(ref val)) = self.oneof_null {
      ::pb_jelly::wire_format::write(63, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofNull::Foreign4(ref val)) = self.oneof_null {
      ::pb_jelly::wire_format::write(64, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofUnset::Int5(ref val)) = self.oneof_unset {
      ::pb_jelly::wire_format::write(65, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofUnset::Foreign5(ref val)) = self.oneof_unset {
      ::pb_jelly::wire_format::write(66, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofPrimitives::Int6(ref val)) = self.oneof_primitives {
      ::pb_jelly::wire_format::write(67, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestMessage3_OneofPrimitives::Bool6(ref val)) = self.oneof_primitives {
      ::pb_jelly::wire_format::write(68, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
     {
      let val = &self.optional_foreign_message_nonnullable;
      ::pb_jelly::wire_format::write(69, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3_OneofEmptyField::A = self.oneof_empty_field {
      let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
      ::pb_jelly::wire_format::write(70, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3_OneofEmptyField::B = self.oneof_empty_field {
      let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
      ::pb_jelly::wire_format::write(71, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3_OneofEmptyField::C(ref val) = self.oneof_empty_field {
      ::pb_jelly::wire_format::write(72, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
     {
      let val = &self.nested;
      ::pb_jelly::wire_format::write(73, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.nested_nullable {
      ::pb_jelly::wire_format::write(74, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.nested_repeated {
      ::pb_jelly::wire_format::write(75, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    ::pb_jelly::helpers::serialize_scalar::<W, [u8; 4]>(w, &self.fixed_length, 76, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    for val in &self.fixed_length_repeated {
      ::pb_jelly::wire_format::write(77, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    ::pb_jelly::helpers::serialize_scalar::<W, Option<[u8; 4]>>(w, &self.zero_or_fixed_length, 78, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    for val in &self.zero_or_fixed_length_repeated {
      ::pb_jelly::wire_format::write(79, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_oneof_empty_field: ::std::option::Option<TestMessage3_OneofEmptyField> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 1)?;
          self.optional_int32 = val;
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 2)?;
          self.optional_int64 = val;
        }
        3 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 3)?;
          self.optional_uint32 = val;
        }
        4 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 4)?;
          self.optional_uint64 = val;
        }
        8 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Fixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage3", 8)?;
          self.optional_fixed64 = val;
        }
        9 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Fixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage3", 9)?;
          self.optional_fixed32 = val;
        }
        10 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Sfixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage3", 10)?;
          self.optional_sfixed64 = val;
        }
        11 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Sfixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage3", 11)?;
          self.optional_sfixed32 = val;
        }
        12 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage3", 12)?;
          self.optional_double = val;
        }
        13 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, bool>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 13)?;
          self.optional_bool = val;
        }
        14 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestMessage3", 14)?;
          self.optional_string = val;
        }
        15 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::vec::Vec<u8>>(buf, typ, "TestMessage3", 15)?;
          self.optional_bytes = val;
        }
        16 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage3", 16)?;
          self.optional_float = val;
        }
        19 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "TestMessage3", 19)?;
          self.optional_foreign_message = Some(val);
        }
        21 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, TestMessage3_NestedEnum3>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 21)?;
          self.optional_nested_enum = val;
        }
        22 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ForeignEnum3>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 22)?;
          self.optional_foreign_enum = val;
        }
        31 => {
          ::pb_jelly::helpers::deserialize_packed::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 31, &mut self.repeated_int32)?;
        }
        32 => {
          ::pb_jelly::helpers::deserialize_packed::<B, i64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 32, &mut self.repeated_int64)?;
        }
        33 => {
          ::pb_jelly::helpers::deserialize_packed::<B, u32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 33, &mut self.repeated_uint32)?;
        }
        34 => {
          ::pb_jelly::helpers::deserialize_packed::<B, u64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 34, &mut self.repeated_uint64)?;
        }
        38 => {
          ::pb_jelly::helpers::deserialize_packed::<B, ::pb_jelly::Fixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage3", 38, &mut self.repeated_fixed64)?;
        }
        39 => {
          ::pb_jelly::helpers::deserialize_packed::<B, ::pb_jelly::Fixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage3", 39, &mut self.repeated_fixed32)?;
        }
        40 => {
          ::pb_jelly::helpers::deserialize_packed::<B, ::pb_jelly::Sfixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage3", 40, &mut self.repeated_sfixed64)?;
        }
        41 => {
          ::pb_jelly::helpers::deserialize_packed::<B, ::pb_jelly::Sfixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage3", 41, &mut self.repeated_sfixed32)?;
        }
        42 => {
          ::pb_jelly::helpers::deserialize_packed::<B, f64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestMessage3", 42, &mut self.repeated_double)?;
        }
        43 => {
          ::pb_jelly::helpers::deserialize_packed::<B, bool>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 43, &mut self.repeated_bool)?;
        }
        44 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestMessage3", 44)?;
          self.repeated_string.push(val);
        }
        45 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::vec::Vec<u8>>(buf, typ, "TestMessage3", 45)?;
          self.repeated_bytes.push(val);
        }
        46 => {
          ::pb_jelly::helpers::deserialize_packed::<B, f32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestMessage3", 46, &mut self.repeated_float)?;
        }
        49 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "TestMessage3", 49)?;
          self.repeated_foreign_message.push(val);
        }
        51 => {
          ::pb_jelly::helpers::deserialize_packed::<B, TestMessage3_NestedEnum3>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 51, &mut self.repeated_nested_enum)?;
        }
        52 => {
          ::pb_jelly::helpers::deserialize_packed::<B, ForeignEnum3>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 52, &mut self.repeated_foreign_enum)?;
        }
        53 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, super::pbtest2::ForeignMessage>(buf, typ, "TestMessage3", 53)?;
          self.proto2_msg = Some(val);
        }
        54 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, super::pbtest2::ForeignMessage>(buf, typ, "TestMessage3", 54)?;
          self.proto2_msg_empty = Some(val);
        }
        55 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, super::pbtest2::ForeignMessage>(buf, typ, "TestMessage3", 55)?;
          self.proto2_msg_missing = Some(val);
        }
        56 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "TestMessage3", 56)?;
          self.optional_foreign_message_boxed = Some(Box::new(val));
        }
        69 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "TestMessage3", 69)?;
          self.optional_foreign_message_nonnullable = val;
        }
        57 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 57)?;
          self.oneof_int = Some(TestMessage3_OneofInt::Int1(val));
        }
        58 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "TestMessage3", 58)?;
          self.oneof_int = Some(TestMessage3_OneofInt::Foreign1(val));
        }
        59 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 59)?;
          self.oneof_foreign = Some(TestMessage3_OneofForeign::Int2(val));
        }
        60 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "TestMessage3", 60)?;
          self.oneof_foreign = Some(TestMessage3_OneofForeign::Foreign2(val));
        }
        61 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 61)?;
          self.oneof_zero = Some(TestMessage3_OneofZero::Int3(val));
        }
        62 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "TestMessage3", 62)?;
          self.oneof_zero = Some(TestMessage3_OneofZero::Foreign3(val));
        }
        63 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 63)?;
          self.oneof_null = Some(TestMessage3_OneofNull::Int4(val));
        }
        64 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "TestMessage3", 64)?;
          self.oneof_null = Some(TestMessage3_OneofNull::Foreign4(val));
        }
        65 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 65)?;
          self.oneof_unset = Some(TestMessage3_OneofUnset::Int5(val));
        }
        66 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "TestMessage3", 66)?;
          self.oneof_unset = Some(TestMessage3_OneofUnset::Foreign5(val));
        }
        67 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 67)?;
          self.oneof_primitives = Some(TestMessage3_OneofPrimitives::Int6(val));
        }
        68 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, bool>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 68)?;
          self.oneof_primitives = Some(TestMessage3_OneofPrimitives::Bool6(val));
        }
        70 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::proto_google::protobuf::empty::Empty>(buf, typ, "TestMessage3", 70)?;
          oneof_oneof_empty_field = Some(TestMessage3_OneofEmptyField::A);
        }
        71 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::proto_google::protobuf::empty::Empty>(buf, typ, "TestMessage3", 71)?;
          oneof_oneof_empty_field = Some(TestMessage3_OneofEmptyField::B);
        }
        72 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3", 72)?;
          oneof_oneof_empty_field = Some(TestMessage3_OneofEmptyField::C(val));
        }
        73 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, TestMessage3_NestedMessage>(buf, typ, "TestMessage3", 73)?;
          self.nested = val;
        }
        74 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, TestMessage3_NestedMessage>(buf, typ, "TestMessage3", 74)?;
          self.nested_nullable = Some(val);
        }
        75 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, TestMessage3_NestedMessage>(buf, typ, "TestMessage3", 75)?;
          self.nested_repeated.push(val);
        }
        76 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, [u8; 4]>(buf, typ, "TestMessage3", 76)?;
          self.fixed_length = val;
        }
        77 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, [u8; 4]>(buf, typ, "TestMessage3", 77)?;
          self.fixed_length_repeated.push(val);
        }
        78 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, Option<[u8; 4]>>(buf, typ, "TestMessage3", 78)?;
          self.zero_or_fixed_length = val;
        }
        79 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, Option<[u8; 4]>>(buf, typ, "TestMessage3", 79)?;
          self.zero_or_fixed_length_repeated.push(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_oneof_empty_field {
      Some(v) => self.oneof_empty_field = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'oneof_empty_field' while parsing message pbtest.TestMessage3")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage3 {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "oneof_int" => {
        if let Some(TestMessage3_OneofInt::Int1(ref val)) = self.oneof_int {
          return Some("int1");
        }
        if let Some(TestMessage3_OneofInt::Foreign1(ref val)) = self.oneof_int {
          return Some("foreign1");
        }
        None
      }
      "oneof_foreign" => {
        if let Some(TestMessage3_OneofForeign::Int2(ref val)) = self.oneof_foreign {
          return Some("int2");
        }
        if let Some(TestMessage3_OneofForeign::Foreign2(ref val)) = self.oneof_foreign {
          return Some("foreign2");
        }
        None
      }
      "oneof_zero" => {
        if let Some(TestMessage3_OneofZero::Int3(ref val)) = self.oneof_zero {
          return Some("int3");
        }
        if let Some(TestMessage3_OneofZero::Foreign3(ref val)) = self.oneof_zero {
          return Some("foreign3");
        }
        None
      }
      "oneof_null" => {
        if let Some(TestMessage3_OneofNull::Int4(ref val)) = self.oneof_null {
          return Some("int4");
        }
        if let Some(TestMessage3_OneofNull::Foreign4(ref val)) = self.oneof_null {
          return Some("foreign4");
        }
        None
      }
      "oneof_unset" => {
        if let Some(TestMessage3_OneofUnset::Int5(ref val)) = self.oneof_unset {
          return Some("int5");
        }
        if let Some(TestMessage3_OneofUnset::Foreign5(ref val)) = self.oneof_unset {
          return Some("foreign5");
        }
        None
      }
      "oneof_primitives" => {
        if let Some(TestMessage3_OneofPrimitives::Int6(ref val)) = self.oneof_primitives {
          return Some("int6");
        }
        if let Some(TestMessage3_OneofPrimitives::Bool6(ref val)) = self.oneof_primitives {
          return Some("bool6");
        }
        None
      }
      "oneof_empty_field" => {
        if let TestMessage3_OneofEmptyField::A = self.oneof_empty_field {
          let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
          return Some("a");
        }
        if let TestMessage3_OneofEmptyField::B = self.oneof_empty_field {
          let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
          return Some("b");
        }
        if let TestMessage3_OneofEmptyField::C(ref val) = self.oneof_empty_field {
          return Some("c");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "optional_int32" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_int32)
      }
      "optional_int64" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_int64)
      }
      "optional_uint32" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_uint32)
      }
      "optional_uint64" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_uint64)
      }
      "optional_fixed64" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_fixed64)
      }
      "optional_fixed32" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_fixed32)
      }
      "optional_sfixed64" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_sfixed64)
      }
      "optional_sfixed32" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_sfixed32)
      }
      "optional_double" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_double)
      }
      "optional_bool" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_bool)
      }
      "optional_string" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_string)
      }
      "optional_bytes" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_bytes)
      }
      "optional_float" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_float)
      }
      "optional_foreign_message" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_foreign_message.get_or_insert_with(::std::default::Default::default))
      }
      "optional_nested_enum" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_nested_enum)
      }
      "optional_foreign_enum" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_foreign_enum)
      }
      "repeated_int32" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_int64" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_uint32" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_uint64" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_fixed64" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_fixed32" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_sfixed64" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_sfixed32" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_double" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_bool" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_string" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_bytes" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_float" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_foreign_message" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_nested_enum" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "repeated_foreign_enum" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "proto2_msg" => {
        ::pb_jelly::reflection::FieldMut::Value(self.proto2_msg.get_or_insert_with(::std::default::Default::default))
      }
      "proto2_msg_empty" => {
        ::pb_jelly::reflection::FieldMut::Value(self.proto2_msg_empty.get_or_insert_with(::std::default::Default::default))
      }
      "proto2_msg_missing" => {
        ::pb_jelly::reflection::FieldMut::Value(self.proto2_msg_missing.get_or_insert_with(::std::default::Default::default))
      }
      "optional_foreign_message_boxed" => {
        ::pb_jelly::reflection::FieldMut::Value(self.optional_foreign_message_boxed.get_or_insert_with(::std::default::Default::default).as_mut())
      }
      "optional_foreign_message_nonnullable" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.optional_foreign_message_nonnullable)
      }
      "int1" => {
        match self.oneof_int {
          Some(TestMessage3_OneofInt::Int1(_)) => (),
          _ => {
            self.oneof_int = Some(TestMessage3_OneofInt::Int1(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3_OneofInt::Int1(ref mut val)) = self.oneof_int {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "foreign1" => {
        match self.oneof_int {
          Some(TestMessage3_OneofInt::Foreign1(_)) => (),
          _ => {
            self.oneof_int = Some(TestMessage3_OneofInt::Foreign1(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3_OneofInt::Foreign1(ref mut val)) = self.oneof_int {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int2" => {
        match self.oneof_foreign {
          Some(TestMessage3_OneofForeign::Int2(_)) => (),
          _ => {
            self.oneof_foreign = Some(TestMessage3_OneofForeign::Int2(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3_OneofForeign::Int2(ref mut val)) = self.oneof_foreign {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "foreign2" => {
        match self.oneof_foreign {
          Some(TestMessage3_OneofForeign::Foreign2(_)) => (),
          _ => {
            self.oneof_foreign = Some(TestMessage3_OneofForeign::Foreign2(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3_OneofForeign::Foreign2(ref mut val)) = self.oneof_foreign {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int3" => {
        match self.oneof_zero {
          Some(TestMessage3_OneofZero::Int3(_)) => (),
          _ => {
            self.oneof_zero = Some(TestMessage3_OneofZero::Int3(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3_OneofZero::Int3(ref mut val)) = self.oneof_zero {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "foreign3" => {
        match self.oneof_zero {
          Some(TestMessage3_OneofZero::Foreign3(_)) => (),
          _ => {
            self.oneof_zero = Some(TestMessage3_OneofZero::Foreign3(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3_OneofZero::Foreign3(ref mut val)) = self.oneof_zero {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int4" => {
        match self.oneof_null {
          Some(TestMessage3_OneofNull::Int4(_)) => (),
          _ => {
            self.oneof_null = Some(TestMessage3_OneofNull::Int4(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3_OneofNull::Int4(ref mut val)) = self.oneof_null {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "foreign4" => {
        match self.oneof_null {
          Some(TestMessage3_OneofNull::Foreign4(_)) => (),
          _ => {
            self.oneof_null = Some(TestMessage3_OneofNull::Foreign4(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3_OneofNull::Foreign4(ref mut val)) = self.oneof_null {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int5" => {
        match self.oneof_unset {
          Some(TestMessage3_OneofUnset::Int5(_)) => (),
          _ => {
            self.oneof_unset = Some(TestMessage3_OneofUnset::Int5(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3_OneofUnset::Int5(ref mut val)) = self.oneof_unset {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "foreign5" => {
        match self.oneof_unset {
          Some(TestMessage3_OneofUnset::Foreign5(_)) => (),
          _ => {
            self.oneof_unset = Some(TestMessage3_OneofUnset::Foreign5(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3_OneofUnset::Foreign5(ref mut val)) = self.oneof_unset {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "int6" => {
        match self.oneof_primitives {
          Some(TestMessage3_OneofPrimitives::Int6(_)) => (),
          _ => {
            self.oneof_primitives = Some(TestMessage3_OneofPrimitives::Int6(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3_OneofPrimitives::Int6(ref mut val)) = self.oneof_primitives {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "bool6" => {
        match self.oneof_primitives {
          Some(TestMessage3_OneofPrimitives::Bool6(_)) => (),
          _ => {
            self.oneof_primitives = Some(TestMessage3_OneofPrimitives::Bool6(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3_OneofPrimitives::Bool6(ref mut val)) = self.oneof_primitives {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "a" => {
        match self.oneof_empty_field {
          TestMessage3_OneofEmptyField::A => (),
          _ => {
            self.oneof_empty_field = TestMessage3_OneofEmptyField::A;
          },
        }
        ::pb_jelly::reflection::FieldMut::Empty
      }
      "b" => {
        match self.oneof_empty_field {
          TestMessage3_OneofEmptyField::B => (),
          _ => {
            self.oneof_empty_field = TestMessage3_OneofEmptyField::B;
          },
        }
        ::pb_jelly::reflection::FieldMut::Empty
      }
      "c" => {
        match self.oneof_empty_field {
          TestMessage3_OneofEmptyField::C(_) => (),
          _ => {
            self.oneof_empty_field = TestMessage3_OneofEmptyField::C(::std::default::Default::default());
          },
        }
        if let TestMessage3_OneofEmptyField::C(ref mut val) = self.oneof_empty_field {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "nested" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.nested)
      }
      "nested_nullable" => {
        ::pb_jelly::reflection::FieldMut::Value(self.nested_nullable.get_or_insert_with(::std::default::Default::default))
      }
      "nested_repeated" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "fixed_length" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.fixed_length)
      }
      "fixed_length_repeated" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "zero_or_fixed_length" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.zero_or_fixed_length)
      }
      "zero_or_fixed_length_repeated" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3_NestedMessage {
  pub nested_oneof: TestMessage3_NestedMessage_NestedOneof,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TestMessage3_NestedMessage_NestedOneof {
  F(TestMessage3_NestedMessage_File),
  D(TestMessage3_NestedMessage_Dir),
  E(TestMessage3_NestedMessage_Enum),
  N(TestMessage3_NestedMessage_NonNullableEnum),
}
impl ::std::default::Default for TestMessage3_NestedMessage {
  fn default() -> Self {
    TestMessage3_NestedMessage {
      nested_oneof: TestMessage3_NestedMessage_NestedOneof::F(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3_NestedMessage_default: TestMessage3_NestedMessage = TestMessage3_NestedMessage::default();
}
impl ::pb_jelly::Message for TestMessage3_NestedMessage {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage3_NestedMessage",
      full_name: "pbtest.TestMessage3_NestedMessage",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "f",
          full_name: "pbtest.TestMessage3_NestedMessage.f",
          index: 0,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "d",
          full_name: "pbtest.TestMessage3_NestedMessage.d",
          index: 1,
          number: 4,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "e",
          full_name: "pbtest.TestMessage3_NestedMessage.e",
          index: 2,
          number: 5,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "n",
          full_name: "pbtest.TestMessage3_NestedMessage.n",
          index: 3,
          number: 6,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "nested_oneof",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut f_size = 0;
    if let TestMessage3_NestedMessage_NestedOneof::F(ref val) = self.nested_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      f_size += ::pb_jelly::wire_format::serialized_length(3);
      f_size += ::pb_jelly::varint::serialized_length(l as u64);
      f_size += l;
    }
    size += f_size;
    let mut d_size = 0;
    if let TestMessage3_NestedMessage_NestedOneof::D(ref val) = self.nested_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      d_size += ::pb_jelly::wire_format::serialized_length(4);
      d_size += ::pb_jelly::varint::serialized_length(l as u64);
      d_size += l;
    }
    size += d_size;
    let mut e_size = 0;
    if let TestMessage3_NestedMessage_NestedOneof::E(ref val) = self.nested_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      e_size += ::pb_jelly::wire_format::serialized_length(5);
      e_size += l;
    }
    size += e_size;
    let mut n_size = 0;
    if let TestMessage3_NestedMessage_NestedOneof::N(ref val) = self.nested_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      n_size += ::pb_jelly::wire_format::serialized_length(6);
      n_size += l;
    }
    size += n_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let TestMessage3_NestedMessage_NestedOneof::F(ref val) = self.nested_oneof {
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3_NestedMessage_NestedOneof::D(ref val) = self.nested_oneof {
      ::pb_jelly::wire_format::write(4, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3_NestedMessage_NestedOneof::E(ref val) = self.nested_oneof {
      ::pb_jelly::wire_format::write(5, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3_NestedMessage_NestedOneof::N(ref val) = self.nested_oneof {
      ::pb_jelly::wire_format::write(6, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_nested_oneof: ::std::option::Option<TestMessage3_NestedMessage_NestedOneof> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        3 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, TestMessage3_NestedMessage_File>(buf, typ, "TestMessage3_NestedMessage", 3)?;
          oneof_nested_oneof = Some(TestMessage3_NestedMessage_NestedOneof::F(val));
        }
        4 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, TestMessage3_NestedMessage_Dir>(buf, typ, "TestMessage3_NestedMessage", 4)?;
          oneof_nested_oneof = Some(TestMessage3_NestedMessage_NestedOneof::D(val));
        }
        5 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, TestMessage3_NestedMessage_Enum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3_NestedMessage", 5)?;
          oneof_nested_oneof = Some(TestMessage3_NestedMessage_NestedOneof::E(val));
        }
        6 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, TestMessage3_NestedMessage_NonNullableEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3_NestedMessage", 6)?;
          oneof_nested_oneof = Some(TestMessage3_NestedMessage_NestedOneof::N(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_nested_oneof {
      Some(v) => self.nested_oneof = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'nested_oneof' while parsing message pbtest.NestedMessage")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage3_NestedMessage {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "nested_oneof" => {
        if let TestMessage3_NestedMessage_NestedOneof::F(ref val) = self.nested_oneof {
          return Some("f");
        }
        if let TestMessage3_NestedMessage_NestedOneof::D(ref val) = self.nested_oneof {
          return Some("d");
        }
        if let TestMessage3_NestedMessage_NestedOneof::E(ref val) = self.nested_oneof {
          return Some("e");
        }
        if let TestMessage3_NestedMessage_NestedOneof::N(ref val) = self.nested_oneof {
          return Some("n");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "f" => {
        match self.nested_oneof {
          TestMessage3_NestedMessage_NestedOneof::F(_) => (),
          _ => {
            self.nested_oneof = TestMessage3_NestedMessage_NestedOneof::F(::std::default::Default::default());
          },
        }
        if let TestMessage3_NestedMessage_NestedOneof::F(ref mut val) = self.nested_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "d" => {
        match self.nested_oneof {
          TestMessage3_NestedMessage_NestedOneof::D(_) => (),
          _ => {
            self.nested_oneof = TestMessage3_NestedMessage_NestedOneof::D(::std::default::Default::default());
          },
        }
        if let TestMessage3_NestedMessage_NestedOneof::D(ref mut val) = self.nested_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "e" => {
        match self.nested_oneof {
          TestMessage3_NestedMessage_NestedOneof::E(_) => (),
          _ => {
            self.nested_oneof = TestMessage3_NestedMessage_NestedOneof::E(::std::default::Default::default());
          },
        }
        if let TestMessage3_NestedMessage_NestedOneof::E(ref mut val) = self.nested_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "n" => {
        match self.nested_oneof {
          TestMessage3_NestedMessage_NestedOneof::N(_) => (),
          _ => {
            self.nested_oneof = TestMessage3_NestedMessage_NestedOneof::N(::std::default::Default::default());
          },
        }
        if let TestMessage3_NestedMessage_NestedOneof::N(ref mut val) = self.nested_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3_NestedMessage_File {
  pub blocklist: ::std::vec::Vec<::std::vec::Vec<u8>>,
  pub size: u32,
}
impl ::std::default::Default for TestMessage3_NestedMessage_File {
  fn default() -> Self {
    TestMessage3_NestedMessage_File {
      blocklist: ::std::default::Default::default(),
      size: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3_NestedMessage_File_default: TestMessage3_NestedMessage_File = TestMessage3_NestedMessage_File::default();
}
impl ::pb_jelly::Message for TestMessage3_NestedMessage_File {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage3_NestedMessage_File",
      full_name: "pbtest.TestMessage3_NestedMessage_File",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "blocklist",
          full_name: "pbtest.TestMessage3_NestedMessage_File.blocklist",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "size",
          full_name: "pbtest.TestMessage3_NestedMessage_File.size",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut blocklist_size = 0;
    for val in &self.blocklist {
      let l = ::pb_jelly::Message::compute_size(val);
      blocklist_size += ::pb_jelly::wire_format::serialized_length(1);
      blocklist_size += ::pb_jelly::varint::serialized_length(l as u64);
      blocklist_size += l;
    }
    size += blocklist_size;
    size += ::pb_jelly::helpers::compute_size_scalar::<u32>(&self.size, 2, ::pb_jelly::wire_format::Type::Varint);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.blocklist {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    ::pb_jelly::helpers::serialize_scalar::<W, u32>(w, &self.size, 2, ::pb_jelly::wire_format::Type::Varint)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::vec::Vec<u8>>(buf, typ, "TestMessage3_NestedMessage_File", 1)?;
          self.blocklist.push(val);
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3_NestedMessage_File", 2)?;
          self.size = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage3_NestedMessage_File {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "blocklist" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      "size" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.size)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3_NestedMessage_Dir {
}
impl ::std::default::Default for TestMessage3_NestedMessage_Dir {
  fn default() -> Self {
    TestMessage3_NestedMessage_Dir {
    }
  }
}
lazy_static! {
  pub static ref TestMessage3_NestedMessage_Dir_default: TestMessage3_NestedMessage_Dir = TestMessage3_NestedMessage_Dir::default();
}
impl ::pb_jelly::Message for TestMessage3_NestedMessage_Dir {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage3_NestedMessage_Dir",
      full_name: "pbtest.TestMessage3_NestedMessage_Dir",
      fields: &[
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    0
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage3_NestedMessage_Dir {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestBoxedNonnullable {
  pub field: ::std::boxed::Box<ForeignMessage3>,
}
impl ::std::default::Default for TestBoxedNonnullable {
  fn default() -> Self {
    TestBoxedNonnullable {
      field: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestBoxedNonnullable_default: TestBoxedNonnullable = TestBoxedNonnullable::default();
}
impl ::pb_jelly::Message for TestBoxedNonnullable {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestBoxedNonnullable",
      full_name: "pbtest.TestBoxedNonnullable",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "field",
          full_name: "pbtest.TestBoxedNonnullable.field",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut field_size = 0;
     {
      let val = &*self.field;
      let l = ::pb_jelly::Message::compute_size(val);
      field_size += ::pb_jelly::wire_format::serialized_length(1);
      field_size += ::pb_jelly::varint::serialized_length(l as u64);
      field_size += l;
    }
    size += field_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
     {
      let val = &*self.field;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "TestBoxedNonnullable", 1)?;
          self.field = Box::new(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestBoxedNonnullable {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "field" => {
        ::pb_jelly::reflection::FieldMut::Value(self.field.as_mut())
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3NonNullableOneof {
  pub other_field: u64,
  pub non_nullable_oneof: TestMessage3NonNullableOneof_NonNullableOneof,
}
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TestMessage3NonNullableOneof_NonNullableOneof {
  A(i32),
  B(i32),
}
impl ::std::default::Default for TestMessage3NonNullableOneof {
  fn default() -> Self {
    TestMessage3NonNullableOneof {
      other_field: ::std::default::Default::default(),
      non_nullable_oneof: TestMessage3NonNullableOneof_NonNullableOneof::A(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3NonNullableOneof_default: TestMessage3NonNullableOneof = TestMessage3NonNullableOneof::default();
}
impl ::pb_jelly::Message for TestMessage3NonNullableOneof {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage3NonNullableOneof",
      full_name: "pbtest.TestMessage3NonNullableOneof",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "a",
          full_name: "pbtest.TestMessage3NonNullableOneof.a",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "b",
          full_name: "pbtest.TestMessage3NonNullableOneof.b",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "other_field",
          full_name: "pbtest.TestMessage3NonNullableOneof.other_field",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "non_nullable_oneof",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut a_size = 0;
    if let TestMessage3NonNullableOneof_NonNullableOneof::A(ref val) = self.non_nullable_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      a_size += ::pb_jelly::wire_format::serialized_length(1);
      a_size += l;
    }
    size += a_size;
    let mut b_size = 0;
    if let TestMessage3NonNullableOneof_NonNullableOneof::B(ref val) = self.non_nullable_oneof {
      let l = ::pb_jelly::Message::compute_size(val);
      b_size += ::pb_jelly::wire_format::serialized_length(2);
      b_size += l;
    }
    size += b_size;
    size += ::pb_jelly::helpers::compute_size_scalar::<u64>(&self.other_field, 3, ::pb_jelly::wire_format::Type::Varint);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let TestMessage3NonNullableOneof_NonNullableOneof::A(ref val) = self.non_nullable_oneof {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestMessage3NonNullableOneof_NonNullableOneof::B(ref val) = self.non_nullable_oneof {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    ::pb_jelly::helpers::serialize_scalar::<W, u64>(w, &self.other_field, 3, ::pb_jelly::wire_format::Type::Varint)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_non_nullable_oneof: ::std::option::Option<TestMessage3NonNullableOneof_NonNullableOneof> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3NonNullableOneof", 1)?;
          oneof_non_nullable_oneof = Some(TestMessage3NonNullableOneof_NonNullableOneof::A(val));
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3NonNullableOneof", 2)?;
          oneof_non_nullable_oneof = Some(TestMessage3NonNullableOneof_NonNullableOneof::B(val));
        }
        3 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3NonNullableOneof", 3)?;
          self.other_field = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_non_nullable_oneof {
      Some(v) => self.non_nullable_oneof = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'non_nullable_oneof' while parsing message pbtest.TestMessage3NonNullableOneof")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage3NonNullableOneof {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "non_nullable_oneof" => {
        if let TestMessage3NonNullableOneof_NonNullableOneof::A(ref val) = self.non_nullable_oneof {
          return Some("a");
        }
        if let TestMessage3NonNullableOneof_NonNullableOneof::B(ref val) = self.non_nullable_oneof {
          return Some("b");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "a" => {
        match self.non_nullable_oneof {
          TestMessage3NonNullableOneof_NonNullableOneof::A(_) => (),
          _ => {
            self.non_nullable_oneof = TestMessage3NonNullableOneof_NonNullableOneof::A(::std::default::Default::default());
          },
        }
        if let TestMessage3NonNullableOneof_NonNullableOneof::A(ref mut val) = self.non_nullable_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "b" => {
        match self.non_nullable_oneof {
          TestMessage3NonNullableOneof_NonNullableOneof::B(_) => (),
          _ => {
            self.non_nullable_oneof = TestMessage3NonNullableOneof_NonNullableOneof::B(::std::default::Default::default());
          },
        }
        if let TestMessage3NonNullableOneof_NonNullableOneof::B(ref mut val) = self.non_nullable_oneof {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "other_field" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.other_field)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3ErrIfDefaultEnum {
  pub field: TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum,
}
impl ::std::default::Default for TestMessage3ErrIfDefaultEnum {
  fn default() -> Self {
    TestMessage3ErrIfDefaultEnum {
      field: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3ErrIfDefaultEnum_default: TestMessage3ErrIfDefaultEnum = TestMessage3ErrIfDefaultEnum::default();
}
impl ::pb_jelly::Message for TestMessage3ErrIfDefaultEnum {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage3ErrIfDefaultEnum",
      full_name: "pbtest.TestMessage3ErrIfDefaultEnum",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "field",
          full_name: "pbtest.TestMessage3ErrIfDefaultEnum.field",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut field_size = 0;
    let val = &self.field;
    let l = ::pb_jelly::Message::compute_size(val);
    field_size += ::pb_jelly::wire_format::serialized_length(1);
    field_size += l;
    size += field_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    let val = &self.field;
    ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
    ::pb_jelly::Message::serialize(val, w)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut field: ::std::option::Option<TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3ErrIfDefaultEnum", 1)?;
          field = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match field {
      Some(v) => self.field = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "err_if_default_or_unknown 'field' had no value while parsing message pbtest.TestMessage3ErrIfDefaultEnum")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage3ErrIfDefaultEnum {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "field" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.field)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3ErrIfDefaultEnumOneof {
  pub nothing: ::std::option::Option<::proto_google::protobuf::empty::Empty>,
  pub maybe: ::std::option::Option<TestMessage3ErrIfDefaultEnumOneof_Maybe>,
}
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TestMessage3ErrIfDefaultEnumOneof_Maybe {
  Something(TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum),
}
impl ::std::default::Default for TestMessage3ErrIfDefaultEnumOneof {
  fn default() -> Self {
    TestMessage3ErrIfDefaultEnumOneof {
      nothing: ::std::default::Default::default(),
      maybe: None,
    }
  }
}
lazy_static! {
  pub static ref TestMessage3ErrIfDefaultEnumOneof_default: TestMessage3ErrIfDefaultEnumOneof = TestMessage3ErrIfDefaultEnumOneof::default();
}
impl ::pb_jelly::Message for TestMessage3ErrIfDefaultEnumOneof {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage3ErrIfDefaultEnumOneof",
      full_name: "pbtest.TestMessage3ErrIfDefaultEnumOneof",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "something",
          full_name: "pbtest.TestMessage3ErrIfDefaultEnumOneof.something",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "nothing",
          full_name: "pbtest.TestMessage3ErrIfDefaultEnumOneof.nothing",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "maybe",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut something_size = 0;
    if let Some(TestMessage3ErrIfDefaultEnumOneof_Maybe::Something(ref val)) = self.maybe {
      let l = ::pb_jelly::Message::compute_size(val);
      something_size += ::pb_jelly::wire_format::serialized_length(1);
      something_size += l;
    }
    size += something_size;
    let mut nothing_size = 0;
    if let Some(ref val) = self.nothing {
      let l = ::pb_jelly::Message::compute_size(val);
      nothing_size += ::pb_jelly::wire_format::serialized_length(2);
      nothing_size += ::pb_jelly::varint::serialized_length(l as u64);
      nothing_size += l;
    }
    size += nothing_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(TestMessage3ErrIfDefaultEnumOneof_Maybe::Something(ref val)) = self.maybe {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.nothing {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, TestMessage3ErrIfDefaultEnumOneof_ErrIfDefaultEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3ErrIfDefaultEnumOneof", 1)?;
          self.maybe = Some(TestMessage3ErrIfDefaultEnumOneof_Maybe::Something(val));
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::proto_google::protobuf::empty::Empty>(buf, typ, "TestMessage3ErrIfDefaultEnumOneof", 2)?;
          self.nothing = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage3ErrIfDefaultEnumOneof {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "maybe" => {
        if let Some(TestMessage3ErrIfDefaultEnumOneof_Maybe::Something(ref val)) = self.maybe {
          return Some("something");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "something" => {
        match self.maybe {
          Some(TestMessage3ErrIfDefaultEnumOneof_Maybe::Something(_)) => (),
          _ => {
            self.maybe = Some(TestMessage3ErrIfDefaultEnumOneof_Maybe::Something(::std::default::Default::default()));
          },
        }
        if let Some(TestMessage3ErrIfDefaultEnumOneof_Maybe::Something(ref mut val)) = self.maybe {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "nothing" => {
        ::pb_jelly::reflection::FieldMut::Value(self.nothing.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3RepeatedErrIfDefaultEnum {
  pub field: ::std::vec::Vec<TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum>,
}
impl ::std::default::Default for TestMessage3RepeatedErrIfDefaultEnum {
  fn default() -> Self {
    TestMessage3RepeatedErrIfDefaultEnum {
      field: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3RepeatedErrIfDefaultEnum_default: TestMessage3RepeatedErrIfDefaultEnum = TestMessage3RepeatedErrIfDefaultEnum::default();
}
impl ::pb_jelly::Message for TestMessage3RepeatedErrIfDefaultEnum {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage3RepeatedErrIfDefaultEnum",
      full_name: "pbtest.TestMessage3RepeatedErrIfDefaultEnum",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "field",
          full_name: "pbtest.TestMessage3RepeatedErrIfDefaultEnum.field",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut field_size = 0;
    for val in &self.field {
      let l = ::pb_jelly::Message::compute_size(val);
      field_size += l;
    }
    if !self.field.is_empty() {
      size += ::pb_jelly::wire_format::serialized_length(1);
      size += ::pb_jelly::varint::serialized_length(field_size as u64);
    }
    size += field_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if !self.field.is_empty() {
      let mut size = 0;
      for val in &self.field {
        size += ::pb_jelly::Message::compute_size(val);
      }
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      ::pb_jelly::varint::write(size as u64, w)?;
    }
    for val in &self.field {
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::helpers::deserialize_packed::<B, TestMessage3ErrIfDefaultEnum_ErrIfDefaultEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3RepeatedErrIfDefaultEnum", 1, &mut self.field)?;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage3RepeatedErrIfDefaultEnum {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "field" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3ClosedEnum {
  pub value: TestMessage3ClosedEnum_ClosedEnum,
}
impl ::std::default::Default for TestMessage3ClosedEnum {
  fn default() -> Self {
    TestMessage3ClosedEnum {
      value: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3ClosedEnum_default: TestMessage3ClosedEnum = TestMessage3ClosedEnum::default();
}
impl ::pb_jelly::Message for TestMessage3ClosedEnum {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage3ClosedEnum",
      full_name: "pbtest.TestMessage3ClosedEnum",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "value",
          full_name: "pbtest.TestMessage3ClosedEnum.value",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<TestMessage3ClosedEnum_ClosedEnum>(&self.value, 1, ::pb_jelly::wire_format::Type::Varint);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, TestMessage3ClosedEnum_ClosedEnum>(w, &self.value, 1, ::pb_jelly::wire_format::Type::Varint)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, TestMessage3ClosedEnum_ClosedEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3ClosedEnum", 1)?;
          self.value = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage3ClosedEnum {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "value" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.value)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3ClosedEnum2 {
  pub value: TestMessage3ClosedEnum2_ClosedEnum,
}
impl ::std::default::Default for TestMessage3ClosedEnum2 {
  fn default() -> Self {
    TestMessage3ClosedEnum2 {
      value: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3ClosedEnum2_default: TestMessage3ClosedEnum2 = TestMessage3ClosedEnum2::default();
}
impl ::pb_jelly::Message for TestMessage3ClosedEnum2 {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage3ClosedEnum2",
      full_name: "pbtest.TestMessage3ClosedEnum2",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "value",
          full_name: "pbtest.TestMessage3ClosedEnum2.value",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<TestMessage3ClosedEnum2_ClosedEnum>(&self.value, 1, ::pb_jelly::wire_format::Type::Varint);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, TestMessage3ClosedEnum2_ClosedEnum>(w, &self.value, 1, ::pb_jelly::wire_format::Type::Varint)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, TestMessage3ClosedEnum2_ClosedEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestMessage3ClosedEnum2", 1)?;
          self.value = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage3ClosedEnum2 {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "value" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.value)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3NonOptionalBoxedMessage {
  pub msg: ::std::boxed::Box<TestMessage3NonOptionalBoxedMessage_InnerMessage>,
}
impl ::std::default::Default for TestMessage3NonOptionalBoxedMessage {
  fn default() -> Self {
    TestMessage3NonOptionalBoxedMessage {
      msg: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3NonOptionalBoxedMessage_default: TestMessage3NonOptionalBoxedMessage = TestMessage3NonOptionalBoxedMessage::default();
}
impl ::pb_jelly::Message for TestMessage3NonOptionalBoxedMessage {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage3NonOptionalBoxedMessage",
      full_name: "pbtest.TestMessage3NonOptionalBoxedMessage",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "msg",
          full_name: "pbtest.TestMessage3NonOptionalBoxedMessage.msg",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut msg_size = 0;
     {
      let val = &*self.msg;
      let l = ::pb_jelly::Message::compute_size(val);
      msg_size += ::pb_jelly::wire_format::serialized_length(1);
      msg_size += ::pb_jelly::varint::serialized_length(l as u64);
      msg_size += l;
    }
    size += msg_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
     {
      let val = &*self.msg;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, TestMessage3NonOptionalBoxedMessage_InnerMessage>(buf, typ, "TestMessage3NonOptionalBoxedMessage", 1)?;
          self.msg = Box::new(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage3NonOptionalBoxedMessage {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "msg" => {
        ::pb_jelly::reflection::FieldMut::Value(self.msg.as_mut())
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestMessage3NonOptionalBoxedMessage_InnerMessage {
  pub name: ::std::string::String,
}
impl ::std::default::Default for TestMessage3NonOptionalBoxedMessage_InnerMessage {
  fn default() -> Self {
    TestMessage3NonOptionalBoxedMessage_InnerMessage {
      name: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestMessage3NonOptionalBoxedMessage_InnerMessage_default: TestMessage3NonOptionalBoxedMessage_InnerMessage = TestMessage3NonOptionalBoxedMessage_InnerMessage::default();
}
impl ::pb_jelly::Message for TestMessage3NonOptionalBoxedMessage_InnerMessage {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestMessage3NonOptionalBoxedMessage_InnerMessage",
      full_name: "pbtest.TestMessage3NonOptionalBoxedMessage_InnerMessage",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "name",
          full_name: "pbtest.TestMessage3NonOptionalBoxedMessage_InnerMessage.name",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<::std::string::String>(&self.name, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, ::std::string::String>(w, &self.name, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestMessage3NonOptionalBoxedMessage_InnerMessage", 1)?;
          self.name = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestMessage3NonOptionalBoxedMessage_InnerMessage {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "name" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.name)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestPreserveUnrecognized1 {
  pub string1: ::std::string::String,
  pub _unrecognized: Vec<u8>,
}
impl ::std::default::Default for TestPreserveUnrecognized1 {
  fn default() -> Self {
    TestPreserveUnrecognized1 {
      string1: ::std::default::Default::default(),
      _unrecognized: Vec::new(),
    }
  }
}
lazy_static! {
  pub static ref TestPreserveUnrecognized1_default: TestPreserveUnrecognized1 = TestPreserveUnrecognized1::default();
}
impl ::pb_jelly::Message for TestPreserveUnrecognized1 {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestPreserveUnrecognized1",
      full_name: "pbtest.TestPreserveUnrecognized1",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "string1",
          full_name: "pbtest.TestPreserveUnrecognized1.string1",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<::std::string::String>(&self.string1, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    size += self._unrecognized.len();
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, ::std::string::String>(w, &self.string1, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    w.write_all(&self._unrecognized)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut unrecognized = ::pb_jelly::Unrecognized::default();
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestPreserveUnrecognized1", 1)?;
          self.string1 = val;
        }
        _ => {
          unrecognized.gather(field_number, typ, &mut buf)?;
        }
      }
    }
    self._unrecognized.reserve(unrecognized.compute_size());
    unrecognized.serialize(&mut std::io::Cursor::new(&mut self._unrecognized))?;
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestPreserveUnrecognized1 {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "string1" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.string1)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct TestPreserveUnrecognized2 {
  pub a_string1: ::std::string::String,
  pub a_int32: i32,
  pub a_int64: i64,
  pub a_uint32: u32,
  pub a_uint64: u64,
  pub a_fixed64: ::pb_jelly::Fixed64,
  pub a_fixed32: ::pb_jelly::Fixed32,
  pub a_sfixed64: ::pb_jelly::Sfixed64,
  pub a_sfixed32: ::pb_jelly::Sfixed32,
  pub a_double: f64,
  pub a_bool: bool,
  pub a_string: ::std::string::String,
  pub a_bytes: ::std::vec::Vec<u8>,
  pub a_float: f32,
  pub _unrecognized: Vec<u8>,
}
impl ::std::default::Default for TestPreserveUnrecognized2 {
  fn default() -> Self {
    TestPreserveUnrecognized2 {
      a_string1: ::std::default::Default::default(),
      a_int32: ::std::default::Default::default(),
      a_int64: ::std::default::Default::default(),
      a_uint32: ::std::default::Default::default(),
      a_uint64: ::std::default::Default::default(),
      a_fixed64: ::std::default::Default::default(),
      a_fixed32: ::std::default::Default::default(),
      a_sfixed64: ::std::default::Default::default(),
      a_sfixed32: ::std::default::Default::default(),
      a_double: ::std::default::Default::default(),
      a_bool: ::std::default::Default::default(),
      a_string: ::std::default::Default::default(),
      a_bytes: ::std::default::Default::default(),
      a_float: ::std::default::Default::default(),
      _unrecognized: Vec::new(),
    }
  }
}
lazy_static! {
  pub static ref TestPreserveUnrecognized2_default: TestPreserveUnrecognized2 = TestPreserveUnrecognized2::default();
}
impl ::pb_jelly::Message for TestPreserveUnrecognized2 {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestPreserveUnrecognized2",
      full_name: "pbtest.TestPreserveUnrecognized2",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "a_string1",
          full_name: "pbtest.TestPreserveUnrecognized2.a_string1",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_int32",
          full_name: "pbtest.TestPreserveUnrecognized2.a_int32",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_int64",
          full_name: "pbtest.TestPreserveUnrecognized2.a_int64",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_uint32",
          full_name: "pbtest.TestPreserveUnrecognized2.a_uint32",
          index: 3,
          number: 4,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_uint64",
          full_name: "pbtest.TestPreserveUnrecognized2.a_uint64",
          index: 4,
          number: 5,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_fixed64",
          full_name: "pbtest.TestPreserveUnrecognized2.a_fixed64",
          index: 5,
          number: 6,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_fixed32",
          full_name: "pbtest.TestPreserveUnrecognized2.a_fixed32",
          index: 6,
          number: 7,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_sfixed64",
          full_name: "pbtest.TestPreserveUnrecognized2.a_sfixed64",
          index: 7,
          number: 8,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_sfixed32",
          full_name: "pbtest.TestPreserveUnrecognized2.a_sfixed32",
          index: 8,
          number: 9,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_double",
          full_name: "pbtest.TestPreserveUnrecognized2.a_double",
          index: 9,
          number: 10,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_bool",
          full_name: "pbtest.TestPreserveUnrecognized2.a_bool",
          index: 10,
          number: 11,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_string",
          full_name: "pbtest.TestPreserveUnrecognized2.a_string",
          index: 11,
          number: 12,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_bytes",
          full_name: "pbtest.TestPreserveUnrecognized2.a_bytes",
          index: 12,
          number: 13,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_float",
          full_name: "pbtest.TestPreserveUnrecognized2.a_float",
          index: 13,
          number: 14,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<::std::string::String>(&self.a_string1, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    size += ::pb_jelly::helpers::compute_size_scalar::<i32>(&self.a_int32, 2, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<i64>(&self.a_int64, 3, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<u32>(&self.a_uint32, 4, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<u64>(&self.a_uint64, 5, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Fixed64>(&self.a_fixed64, 6, ::pb_jelly::wire_format::Type::Fixed64);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Fixed32>(&self.a_fixed32, 7, ::pb_jelly::wire_format::Type::Fixed32);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Sfixed64>(&self.a_sfixed64, 8, ::pb_jelly::wire_format::Type::Fixed64);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Sfixed32>(&self.a_sfixed32, 9, ::pb_jelly::wire_format::Type::Fixed32);
    size += ::pb_jelly::helpers::compute_size_scalar::<f64>(&self.a_double, 10, ::pb_jelly::wire_format::Type::Fixed64);
    size += ::pb_jelly::helpers::compute_size_scalar::<bool>(&self.a_bool, 11, ::pb_jelly::wire_format::Type::Varint);
    size += ::pb_jelly::helpers::compute_size_scalar::<::std::string::String>(&self.a_string, 12, ::pb_jelly::wire_format::Type::LengthDelimited);
    size += ::pb_jelly::helpers::compute_size_scalar::<::std::vec::Vec<u8>>(&self.a_bytes, 13, ::pb_jelly::wire_format::Type::LengthDelimited);
    size += ::pb_jelly::helpers::compute_size_scalar::<f32>(&self.a_float, 14, ::pb_jelly::wire_format::Type::Fixed32);
    size += self._unrecognized.len();
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, ::std::string::String>(w, &self.a_string1, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    ::pb_jelly::helpers::serialize_scalar::<W, i32>(w, &self.a_int32, 2, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, i64>(w, &self.a_int64, 3, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, u32>(w, &self.a_uint32, 4, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, u64>(w, &self.a_uint64, 5, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Fixed64>(w, &self.a_fixed64, 6, ::pb_jelly::wire_format::Type::Fixed64)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Fixed32>(w, &self.a_fixed32, 7, ::pb_jelly::wire_format::Type::Fixed32)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Sfixed64>(w, &self.a_sfixed64, 8, ::pb_jelly::wire_format::Type::Fixed64)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Sfixed32>(w, &self.a_sfixed32, 9, ::pb_jelly::wire_format::Type::Fixed32)?;
    ::pb_jelly::helpers::serialize_scalar::<W, f64>(w, &self.a_double, 10, ::pb_jelly::wire_format::Type::Fixed64)?;
    ::pb_jelly::helpers::serialize_scalar::<W, bool>(w, &self.a_bool, 11, ::pb_jelly::wire_format::Type::Varint)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::std::string::String>(w, &self.a_string, 12, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::std::vec::Vec<u8>>(w, &self.a_bytes, 13, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    ::pb_jelly::helpers::serialize_scalar::<W, f32>(w, &self.a_float, 14, ::pb_jelly::wire_format::Type::Fixed32)?;
    w.write_all(&self._unrecognized)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut unrecognized = ::pb_jelly::Unrecognized::default();
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestPreserveUnrecognized2", 1)?;
          self.a_string1 = val;
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestPreserveUnrecognized2", 2)?;
          self.a_int32 = val;
        }
        3 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestPreserveUnrecognized2", 3)?;
          self.a_int64 = val;
        }
        4 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestPreserveUnrecognized2", 4)?;
          self.a_uint32 = val;
        }
        5 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestPreserveUnrecognized2", 5)?;
          self.a_uint64 = val;
        }
        6 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Fixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestPreserveUnrecognized2", 6)?;
          self.a_fixed64 = val;
        }
        7 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Fixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestPreserveUnrecognized2", 7)?;
          self.a_fixed32 = val;
        }
        8 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Sfixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestPreserveUnrecognized2", 8)?;
          self.a_sfixed64 = val;
        }
        9 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Sfixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestPreserveUnrecognized2", 9)?;
          self.a_sfixed32 = val;
        }
        10 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestPreserveUnrecognized2", 10)?;
          self.a_double = val;
        }
        11 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, bool>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestPreserveUnrecognized2", 11)?;
          self.a_bool = val;
        }
        12 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestPreserveUnrecognized2", 12)?;
          self.a_string = val;
        }
        13 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::vec::Vec<u8>>(buf, typ, "TestPreserveUnrecognized2", 13)?;
          self.a_bytes = val;
        }
        14 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestPreserveUnrecognized2", 14)?;
          self.a_float = val;
        }
        _ => {
          unrecognized.gather(field_number, typ, &mut buf)?;
        }
      }
    }
    self._unrecognized.reserve(unrecognized.compute_size());
    unrecognized.serialize(&mut std::io::Cursor::new(&mut self._unrecognized))?;
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestPreserveUnrecognized2 {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "a_string1" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_string1)
      }
      "a_int32" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_int32)
      }
      "a_int64" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_int64)
      }
      "a_uint32" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_uint32)
      }
      "a_uint64" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_uint64)
      }
      "a_fixed64" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_fixed64)
      }
      "a_fixed32" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_fixed32)
      }
      "a_sfixed64" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_sfixed64)
      }
      "a_sfixed32" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_sfixed32)
      }
      "a_double" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_double)
      }
      "a_bool" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_bool)
      }
      "a_string" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_string)
      }
      "a_bytes" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_bytes)
      }
      "a_float" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.a_float)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestPreserveUnrecognizedEmpty {
  pub _unrecognized: Vec<u8>,
}
impl ::std::default::Default for TestPreserveUnrecognizedEmpty {
  fn default() -> Self {
    TestPreserveUnrecognizedEmpty {
      _unrecognized: Vec::new(),
    }
  }
}
lazy_static! {
  pub static ref TestPreserveUnrecognizedEmpty_default: TestPreserveUnrecognizedEmpty = TestPreserveUnrecognizedEmpty::default();
}
impl ::pb_jelly::Message for TestPreserveUnrecognizedEmpty {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestPreserveUnrecognizedEmpty",
      full_name: "pbtest.TestPreserveUnrecognizedEmpty",
      fields: &[
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += self._unrecognized.len();
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    w.write_all(&self._unrecognized)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut unrecognized = ::pb_jelly::Unrecognized::default();
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        _ => {
          unrecognized.gather(field_number, typ, &mut buf)?;
        }
      }
    }
    self._unrecognized.reserve(unrecognized.compute_size());
    unrecognized.serialize(&mut std::io::Cursor::new(&mut self._unrecognized))?;
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestPreserveUnrecognizedEmpty {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestSmallString {
  pub compact: ::compact_str::CompactString,
}
impl ::std::default::Default for TestSmallString {
  fn default() -> Self {
    TestSmallString {
      compact: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestSmallString_default: TestSmallString = TestSmallString::default();
}
impl ::pb_jelly::Message for TestSmallString {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestSmallString",
      full_name: "pbtest.TestSmallString",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "compact",
          full_name: "pbtest.TestSmallString.compact",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<::compact_str::CompactString>(&self.compact, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, ::compact_str::CompactString>(w, &self.compact, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::compact_str::CompactString>(buf, typ, "TestSmallString", 1)?;
          self.compact = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestSmallString {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "compact" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.compact)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestBoxedSmallString {
  pub compact: ::compact_str::CompactString,
}
impl ::std::default::Default for TestBoxedSmallString {
  fn default() -> Self {
    TestBoxedSmallString {
      compact: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestBoxedSmallString_default: TestBoxedSmallString = TestBoxedSmallString::default();
}
impl ::pb_jelly::Message for TestBoxedSmallString {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestBoxedSmallString",
      full_name: "pbtest.TestBoxedSmallString",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "compact",
          full_name: "pbtest.TestBoxedSmallString.compact",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<::compact_str::CompactString>(&self.compact, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, ::compact_str::CompactString>(w, &self.compact, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::compact_str::CompactString>(buf, typ, "TestBoxedSmallString", 1)?;
          self.compact = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestBoxedSmallString {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "compact" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.compact)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestNonOptionalSmallString {
  pub compact: ::compact_str::CompactString,
}
impl ::std::default::Default for TestNonOptionalSmallString {
  fn default() -> Self {
    TestNonOptionalSmallString {
      compact: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestNonOptionalSmallString_default: TestNonOptionalSmallString = TestNonOptionalSmallString::default();
}
impl ::pb_jelly::Message for TestNonOptionalSmallString {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestNonOptionalSmallString",
      full_name: "pbtest.TestNonOptionalSmallString",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "compact",
          full_name: "pbtest.TestNonOptionalSmallString.compact",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<::compact_str::CompactString>(&self.compact, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, ::compact_str::CompactString>(w, &self.compact, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::compact_str::CompactString>(buf, typ, "TestNonOptionalSmallString", 1)?;
          self.compact = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestNonOptionalSmallString {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "compact" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.compact)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TestSmallStringPreserveUnrecognized {
  pub compact: ::std::string::String,
  pub _unrecognized: Vec<u8>,
}
impl ::std::default::Default for TestSmallStringPreserveUnrecognized {
  fn default() -> Self {
    TestSmallStringPreserveUnrecognized {
      compact: ::std::default::Default::default(),
      _unrecognized: Vec::new(),
    }
  }
}
lazy_static! {
  pub static ref TestSmallStringPreserveUnrecognized_default: TestSmallStringPreserveUnrecognized = TestSmallStringPreserveUnrecognized::default();
}
impl ::pb_jelly::Message for TestSmallStringPreserveUnrecognized {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestSmallStringPreserveUnrecognized",
      full_name: "pbtest.TestSmallStringPreserveUnrecognized",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "compact",
          full_name: "pbtest.TestSmallStringPreserveUnrecognized.compact",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<::std::string::String>(&self.compact, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    size += self._unrecognized.len();
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, ::std::string::String>(w, &self.compact, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    w.write_all(&self._unrecognized)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut unrecognized = ::pb_jelly::Unrecognized::default();
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestSmallStringPreserveUnrecognized", 1)?;
          self.compact = val;
        }
        _ => {
          unrecognized.gather(field_number, typ, &mut buf)?;
        }
      }
    }
    self._unrecognized.reserve(unrecognized.compute_size());
    unrecognized.serialize(&mut std::io::Cursor::new(&mut self._unrecognized))?;
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestSmallStringPreserveUnrecognized {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "compact" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.compact)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct TestProto3Optional {
  /// optional doesn't mean anything here, messages are already optional
  pub a_message: ::std::option::Option<ForeignMessage3>,
  pub a_int32: ::std::option::Option<i32>,
  pub a_int64: ::std::option::Option<i64>,
  pub a_uint32: ::std::option::Option<u32>,
  pub a_uint64: ::std::option::Option<u64>,
  pub a_fixed64: ::std::option::Option<::pb_jelly::Fixed64>,
  pub a_fixed32: ::std::option::Option<::pb_jelly::Fixed32>,
  pub a_sfixed64: ::std::option::Option<::pb_jelly::Sfixed64>,
  pub a_sfixed32: ::std::option::Option<::pb_jelly::Sfixed32>,
  pub a_double: ::std::option::Option<f64>,
  pub a_bool: ::std::option::Option<bool>,
  pub a_string: ::std::option::Option<::std::string::String>,
  pub a_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
  pub a_float: ::std::option::Option<f32>,
  pub real_oneof_1: ::std::option::Option<TestProto3Optional_RealOneof1>,
  pub real_oneof_2: TestProto3Optional_RealOneof2,
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestProto3Optional_RealOneof1 {
  RealOneof11(::std::string::String),
  RealOneof12(::std::string::String),
}
#[derive(Clone, Debug, PartialEq)]
pub enum TestProto3Optional_RealOneof2 {
  RealOneof21(::std::string::String),
  RealOneof22(::std::string::String),
}
impl ::std::default::Default for TestProto3Optional {
  fn default() -> Self {
    TestProto3Optional {
      a_message: ::std::default::Default::default(),
      a_int32: ::std::default::Default::default(),
      a_int64: ::std::default::Default::default(),
      a_uint32: ::std::default::Default::default(),
      a_uint64: ::std::default::Default::default(),
      a_fixed64: ::std::default::Default::default(),
      a_fixed32: ::std::default::Default::default(),
      a_sfixed64: ::std::default::Default::default(),
      a_sfixed32: ::std::default::Default::default(),
      a_double: ::std::default::Default::default(),
      a_bool: ::std::default::Default::default(),
      a_string: ::std::default::Default::default(),
      a_bytes: ::std::default::Default::default(),
      a_float: ::std::default::Default::default(),
      real_oneof_1: None,
      real_oneof_2: TestProto3Optional_RealOneof2::RealOneof21(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref TestProto3Optional_default: TestProto3Optional = TestProto3Optional::default();
}
impl ::pb_jelly::Message for TestProto3Optional {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestProto3Optional",
      full_name: "pbtest.TestProto3Optional",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "a_message",
          full_name: "pbtest.TestProto3Optional.a_message",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_int32",
          full_name: "pbtest.TestProto3Optional.a_int32",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_int64",
          full_name: "pbtest.TestProto3Optional.a_int64",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_uint32",
          full_name: "pbtest.TestProto3Optional.a_uint32",
          index: 3,
          number: 4,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_uint64",
          full_name: "pbtest.TestProto3Optional.a_uint64",
          index: 4,
          number: 5,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_fixed64",
          full_name: "pbtest.TestProto3Optional.a_fixed64",
          index: 5,
          number: 6,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_fixed32",
          full_name: "pbtest.TestProto3Optional.a_fixed32",
          index: 6,
          number: 7,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_sfixed64",
          full_name: "pbtest.TestProto3Optional.a_sfixed64",
          index: 7,
          number: 8,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_sfixed32",
          full_name: "pbtest.TestProto3Optional.a_sfixed32",
          index: 8,
          number: 9,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_double",
          full_name: "pbtest.TestProto3Optional.a_double",
          index: 9,
          number: 10,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_bool",
          full_name: "pbtest.TestProto3Optional.a_bool",
          index: 10,
          number: 11,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_string",
          full_name: "pbtest.TestProto3Optional.a_string",
          index: 11,
          number: 12,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_bytes",
          full_name: "pbtest.TestProto3Optional.a_bytes",
          index: 12,
          number: 13,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "a_float",
          full_name: "pbtest.TestProto3Optional.a_float",
          index: 13,
          number: 14,
          typ: ::pb_jelly::wire_format::Type::Fixed32,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "real_oneof_1_1",
          full_name: "pbtest.TestProto3Optional.real_oneof_1_1",
          index: 14,
          number: 15,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "real_oneof_1_2",
          full_name: "pbtest.TestProto3Optional.real_oneof_1_2",
          index: 15,
          number: 16,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "real_oneof_2_1",
          full_name: "pbtest.TestProto3Optional.real_oneof_2_1",
          index: 16,
          number: 17,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(1),
        },
        ::pb_jelly::FieldDescriptor {
          name: "real_oneof_2_2",
          full_name: "pbtest.TestProto3Optional.real_oneof_2_2",
          index: 17,
          number: 18,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(1),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "real_oneof_1",
        },
        ::pb_jelly::OneofDescriptor {
          name: "real_oneof_2",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut a_message_size = 0;
    if let Some(ref val) = self.a_message {
      let l = ::pb_jelly::Message::compute_size(val);
      a_message_size += ::pb_jelly::wire_format::serialized_length(1);
      a_message_size += ::pb_jelly::varint::serialized_length(l as u64);
      a_message_size += l;
    }
    size += a_message_size;
    let mut a_int32_size = 0;
    if let Some(ref val) = self.a_int32 {
      let l = ::pb_jelly::Message::compute_size(val);
      a_int32_size += ::pb_jelly::wire_format::serialized_length(2);
      a_int32_size += l;
    }
    size += a_int32_size;
    let mut a_int64_size = 0;
    if let Some(ref val) = self.a_int64 {
      let l = ::pb_jelly::Message::compute_size(val);
      a_int64_size += ::pb_jelly::wire_format::serialized_length(3);
      a_int64_size += l;
    }
    size += a_int64_size;
    let mut a_uint32_size = 0;
    if let Some(ref val) = self.a_uint32 {
      let l = ::pb_jelly::Message::compute_size(val);
      a_uint32_size += ::pb_jelly::wire_format::serialized_length(4);
      a_uint32_size += l;
    }
    size += a_uint32_size;
    let mut a_uint64_size = 0;
    if let Some(ref val) = self.a_uint64 {
      let l = ::pb_jelly::Message::compute_size(val);
      a_uint64_size += ::pb_jelly::wire_format::serialized_length(5);
      a_uint64_size += l;
    }
    size += a_uint64_size;
    let mut a_fixed64_size = 0;
    if let Some(ref val) = self.a_fixed64 {
      let l = ::pb_jelly::Message::compute_size(val);
      a_fixed64_size += ::pb_jelly::wire_format::serialized_length(6);
      a_fixed64_size += l;
    }
    size += a_fixed64_size;
    let mut a_fixed32_size = 0;
    if let Some(ref val) = self.a_fixed32 {
      let l = ::pb_jelly::Message::compute_size(val);
      a_fixed32_size += ::pb_jelly::wire_format::serialized_length(7);
      a_fixed32_size += l;
    }
    size += a_fixed32_size;
    let mut a_sfixed64_size = 0;
    if let Some(ref val) = self.a_sfixed64 {
      let l = ::pb_jelly::Message::compute_size(val);
      a_sfixed64_size += ::pb_jelly::wire_format::serialized_length(8);
      a_sfixed64_size += l;
    }
    size += a_sfixed64_size;
    let mut a_sfixed32_size = 0;
    if let Some(ref val) = self.a_sfixed32 {
      let l = ::pb_jelly::Message::compute_size(val);
      a_sfixed32_size += ::pb_jelly::wire_format::serialized_length(9);
      a_sfixed32_size += l;
    }
    size += a_sfixed32_size;
    let mut a_double_size = 0;
    if let Some(ref val) = self.a_double {
      let l = ::pb_jelly::Message::compute_size(val);
      a_double_size += ::pb_jelly::wire_format::serialized_length(10);
      a_double_size += l;
    }
    size += a_double_size;
    let mut a_bool_size = 0;
    if let Some(ref val) = self.a_bool {
      let l = ::pb_jelly::Message::compute_size(val);
      a_bool_size += ::pb_jelly::wire_format::serialized_length(11);
      a_bool_size += l;
    }
    size += a_bool_size;
    let mut a_string_size = 0;
    if let Some(ref val) = self.a_string {
      let l = ::pb_jelly::Message::compute_size(val);
      a_string_size += ::pb_jelly::wire_format::serialized_length(12);
      a_string_size += ::pb_jelly::varint::serialized_length(l as u64);
      a_string_size += l;
    }
    size += a_string_size;
    let mut a_bytes_size = 0;
    if let Some(ref val) = self.a_bytes {
      let l = ::pb_jelly::Message::compute_size(val);
      a_bytes_size += ::pb_jelly::wire_format::serialized_length(13);
      a_bytes_size += ::pb_jelly::varint::serialized_length(l as u64);
      a_bytes_size += l;
    }
    size += a_bytes_size;
    let mut a_float_size = 0;
    if let Some(ref val) = self.a_float {
      let l = ::pb_jelly::Message::compute_size(val);
      a_float_size += ::pb_jelly::wire_format::serialized_length(14);
      a_float_size += l;
    }
    size += a_float_size;
    let mut real_oneof_1_1_size = 0;
    if let Some(TestProto3Optional_RealOneof1::RealOneof11(ref val)) = self.real_oneof_1 {
      let l = ::pb_jelly::Message::compute_size(val);
      real_oneof_1_1_size += ::pb_jelly::wire_format::serialized_length(15);
      real_oneof_1_1_size += ::pb_jelly::varint::serialized_length(l as u64);
      real_oneof_1_1_size += l;
    }
    size += real_oneof_1_1_size;
    let mut real_oneof_1_2_size = 0;
    if let Some(TestProto3Optional_RealOneof1::RealOneof12(ref val)) = self.real_oneof_1 {
      let l = ::pb_jelly::Message::compute_size(val);
      real_oneof_1_2_size += ::pb_jelly::wire_format::serialized_length(16);
      real_oneof_1_2_size += ::pb_jelly::varint::serialized_length(l as u64);
      real_oneof_1_2_size += l;
    }
    size += real_oneof_1_2_size;
    let mut real_oneof_2_1_size = 0;
    if let TestProto3Optional_RealOneof2::RealOneof21(ref val) = self.real_oneof_2 {
      let l = ::pb_jelly::Message::compute_size(val);
      real_oneof_2_1_size += ::pb_jelly::wire_format::serialized_length(17);
      real_oneof_2_1_size += ::pb_jelly::varint::serialized_length(l as u64);
      real_oneof_2_1_size += l;
    }
    size += real_oneof_2_1_size;
    let mut real_oneof_2_2_size = 0;
    if let TestProto3Optional_RealOneof2::RealOneof22(ref val) = self.real_oneof_2 {
      let l = ::pb_jelly::Message::compute_size(val);
      real_oneof_2_2_size += ::pb_jelly::wire_format::serialized_length(18);
      real_oneof_2_2_size += ::pb_jelly::varint::serialized_length(l as u64);
      real_oneof_2_2_size += l;
    }
    size += real_oneof_2_2_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.a_message {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_int32 {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_int64 {
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_uint32 {
      ::pb_jelly::wire_format::write(4, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_uint64 {
      ::pb_jelly::wire_format::write(5, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_fixed64 {
      ::pb_jelly::wire_format::write(6, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_fixed32 {
      ::pb_jelly::wire_format::write(7, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_sfixed64 {
      ::pb_jelly::wire_format::write(8, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_sfixed32 {
      ::pb_jelly::wire_format::write(9, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_double {
      ::pb_jelly::wire_format::write(10, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_bool {
      ::pb_jelly::wire_format::write(11, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_string {
      ::pb_jelly::wire_format::write(12, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_bytes {
      ::pb_jelly::wire_format::write(13, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(ref val) = self.a_float {
      ::pb_jelly::wire_format::write(14, ::pb_jelly::wire_format::Type::Fixed32, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestProto3Optional_RealOneof1::RealOneof11(ref val)) = self.real_oneof_1 {
      ::pb_jelly::wire_format::write(15, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(TestProto3Optional_RealOneof1::RealOneof12(ref val)) = self.real_oneof_1 {
      ::pb_jelly::wire_format::write(16, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestProto3Optional_RealOneof2::RealOneof21(ref val) = self.real_oneof_2 {
      ::pb_jelly::wire_format::write(17, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let TestProto3Optional_RealOneof2::RealOneof22(ref val) = self.real_oneof_2 {
      ::pb_jelly::wire_format::write(18, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_real_oneof_2: ::std::option::Option<TestProto3Optional_RealOneof2> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "TestProto3Optional", 1)?;
          self.a_message = Some(val);
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestProto3Optional", 2)?;
          self.a_int32 = Some(val);
        }
        3 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestProto3Optional", 3)?;
          self.a_int64 = Some(val);
        }
        4 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u32>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestProto3Optional", 4)?;
          self.a_uint32 = Some(val);
        }
        5 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, u64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestProto3Optional", 5)?;
          self.a_uint64 = Some(val);
        }
        6 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Fixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestProto3Optional", 6)?;
          self.a_fixed64 = Some(val);
        }
        7 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Fixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestProto3Optional", 7)?;
          self.a_fixed32 = Some(val);
        }
        8 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Sfixed64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestProto3Optional", 8)?;
          self.a_sfixed64 = Some(val);
        }
        9 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, ::pb_jelly::Sfixed32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestProto3Optional", 9)?;
          self.a_sfixed32 = Some(val);
        }
        10 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "TestProto3Optional", 10)?;
          self.a_double = Some(val);
        }
        11 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, bool>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "TestProto3Optional", 11)?;
          self.a_bool = Some(val);
        }
        12 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestProto3Optional", 12)?;
          self.a_string = Some(val);
        }
        13 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::vec::Vec<u8>>(buf, typ, "TestProto3Optional", 13)?;
          self.a_bytes = Some(val);
        }
        14 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f32>(buf, typ, ::pb_jelly::wire_format::Type::Fixed32, "TestProto3Optional", 14)?;
          self.a_float = Some(val);
        }
        15 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestProto3Optional", 15)?;
          self.real_oneof_1 = Some(TestProto3Optional_RealOneof1::RealOneof11(val));
        }
        16 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestProto3Optional", 16)?;
          self.real_oneof_1 = Some(TestProto3Optional_RealOneof1::RealOneof12(val));
        }
        17 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestProto3Optional", 17)?;
          oneof_real_oneof_2 = Some(TestProto3Optional_RealOneof2::RealOneof21(val));
        }
        18 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "TestProto3Optional", 18)?;
          oneof_real_oneof_2 = Some(TestProto3Optional_RealOneof2::RealOneof22(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_real_oneof_2 {
      Some(v) => self.real_oneof_2 = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'real_oneof_2' while parsing message pbtest.TestProto3Optional")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestProto3Optional {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "real_oneof_1" => {
        if let Some(TestProto3Optional_RealOneof1::RealOneof11(ref val)) = self.real_oneof_1 {
          return Some("real_oneof_1_1");
        }
        if let Some(TestProto3Optional_RealOneof1::RealOneof12(ref val)) = self.real_oneof_1 {
          return Some("real_oneof_1_2");
        }
        None
      }
      "real_oneof_2" => {
        if let TestProto3Optional_RealOneof2::RealOneof21(ref val) = self.real_oneof_2 {
          return Some("real_oneof_2_1");
        }
        if let TestProto3Optional_RealOneof2::RealOneof22(ref val) = self.real_oneof_2 {
          return Some("real_oneof_2_2");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "a_message" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_message.get_or_insert_with(::std::default::Default::default))
      }
      "a_int32" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_int32.get_or_insert_with(::std::default::Default::default))
      }
      "a_int64" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_int64.get_or_insert_with(::std::default::Default::default))
      }
      "a_uint32" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_uint32.get_or_insert_with(::std::default::Default::default))
      }
      "a_uint64" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_uint64.get_or_insert_with(::std::default::Default::default))
      }
      "a_fixed64" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_fixed64.get_or_insert_with(::std::default::Default::default))
      }
      "a_fixed32" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_fixed32.get_or_insert_with(::std::default::Default::default))
      }
      "a_sfixed64" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_sfixed64.get_or_insert_with(::std::default::Default::default))
      }
      "a_sfixed32" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_sfixed32.get_or_insert_with(::std::default::Default::default))
      }
      "a_double" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_double.get_or_insert_with(::std::default::Default::default))
      }
      "a_bool" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_bool.get_or_insert_with(::std::default::Default::default))
      }
      "a_string" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_string.get_or_insert_with(::std::default::Default::default))
      }
      "a_bytes" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_bytes.get_or_insert_with(::std::default::Default::default))
      }
      "a_float" => {
        ::pb_jelly::reflection::FieldMut::Value(self.a_float.get_or_insert_with(::std::default::Default::default))
      }
      "real_oneof_1_1" => {
        match self.real_oneof_1 {
          Some(TestProto3Optional_RealOneof1::RealOneof11(_)) => (),
          _ => {
            self.real_oneof_1 = Some(TestProto3Optional_RealOneof1::RealOneof11(::std::default::Default::default()));
          },
        }
        if let Some(TestProto3Optional_RealOneof1::RealOneof11(ref mut val)) = self.real_oneof_1 {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "real_oneof_1_2" => {
        match self.real_oneof_1 {
          Some(TestProto3Optional_RealOneof1::RealOneof12(_)) => (),
          _ => {
            self.real_oneof_1 = Some(TestProto3Optional_RealOneof1::RealOneof12(::std::default::Default::default()));
          },
        }
        if let Some(TestProto3Optional_RealOneof1::RealOneof12(ref mut val)) = self.real_oneof_1 {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "real_oneof_2_1" => {
        match self.real_oneof_2 {
          TestProto3Optional_RealOneof2::RealOneof21(_) => (),
          _ => {
            self.real_oneof_2 = TestProto3Optional_RealOneof2::RealOneof21(::std::default::Default::default());
          },
        }
        if let TestProto3Optional_RealOneof2::RealOneof21(ref mut val) = self.real_oneof_2 {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "real_oneof_2_2" => {
        match self.real_oneof_2 {
          TestProto3Optional_RealOneof2::RealOneof22(_) => (),
          _ => {
            self.real_oneof_2 = TestProto3Optional_RealOneof2::RealOneof22(::std::default::Default::default());
          },
        }
        if let TestProto3Optional_RealOneof2::RealOneof22(ref mut val) = self.real_oneof_2 {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct TestProto3Zerocopy {
  pub data1: ::pb_jelly::Lazy<::bytes::Bytes>,
  pub data2: ::pb_jelly::Lazy<::bytes::Bytes>,
}
impl ::std::default::Default for TestProto3Zerocopy {
  fn default() -> Self {
    TestProto3Zerocopy {
      data1: ::std::default::Default::default(),
      data2: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestProto3Zerocopy_default: TestProto3Zerocopy = TestProto3Zerocopy::default();
}
impl ::pb_jelly::Message for TestProto3Zerocopy {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestProto3Zerocopy",
      full_name: "pbtest.TestProto3Zerocopy",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "data1",
          full_name: "pbtest.TestProto3Zerocopy.data1",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "data2",
          full_name: "pbtest.TestProto3Zerocopy.data2",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Lazy<::bytes::Bytes>>(&self.data1, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    size += ::pb_jelly::helpers::compute_size_scalar::<::pb_jelly::Lazy<::bytes::Bytes>>(&self.data2, 2, ::pb_jelly::wire_format::Type::LengthDelimited);
    size
  }
  fn compute_grpc_slices_size(&self) -> usize {
    let mut size = 0;
    if self.data1 != <::pb_jelly::Lazy<::bytes::Bytes> as ::std::default::Default>::default() {
      let val = &self.data1;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    if self.data2 != <::pb_jelly::Lazy<::bytes::Bytes> as ::std::default::Default>::default() {
      let val = &self.data2;
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Lazy<::bytes::Bytes>>(w, &self.data1, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    ::pb_jelly::helpers::serialize_scalar::<W, ::pb_jelly::Lazy<::bytes::Bytes>>(w, &self.data2, 2, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::pb_jelly::Lazy<::bytes::Bytes>>(buf, typ, "TestProto3Zerocopy", 1)?;
          self.data1 = val;
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::pb_jelly::Lazy<::bytes::Bytes>>(buf, typ, "TestProto3Zerocopy", 2)?;
          self.data2 = val;
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestProto3Zerocopy {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "data1" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.data1)
      }
      "data2" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.data2)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct TestProto3ContainsZerocopy {
  pub inner: ::std::option::Option<TestProto3Zerocopy>,
}
impl ::std::default::Default for TestProto3ContainsZerocopy {
  fn default() -> Self {
    TestProto3ContainsZerocopy {
      inner: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref TestProto3ContainsZerocopy_default: TestProto3ContainsZerocopy = TestProto3ContainsZerocopy::default();
}
impl ::pb_jelly::Message for TestProto3ContainsZerocopy {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "TestProto3ContainsZerocopy",
      full_name: "pbtest.TestProto3ContainsZerocopy",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "inner",
          full_name: "pbtest.TestProto3ContainsZerocopy.inner",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut inner_size = 0;
    if let Some(ref val) = self.inner {
      let l = ::pb_jelly::Message::compute_size(val);
      inner_size += ::pb_jelly::wire_format::serialized_length(1);
      inner_size += ::pb_jelly::varint::serialized_length(l as u64);
      inner_size += l;
    }
    size += inner_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize {
    let mut size = 0;
    if let Some(ref val) = self.inner {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.inner {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, TestProto3Zerocopy>(buf, typ, "TestProto3ContainsZerocopy", 1)?;
          self.inner = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for TestProto3ContainsZerocopy {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "inner" => {
        ::pb_jelly::reflection::FieldMut::Value(self.inner.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RecursiveOneof {
  /// This field should be boxed automatically.
  /// Boxing should override the empty-oneof-field special case.
  pub oneof_field: ::std::option::Option<RecursiveOneof_OneofField>,
}
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum RecursiveOneof_OneofField {
  Field(::std::boxed::Box<RecursiveOneof>),
  Empty,
  BoxedEmpty(::std::boxed::Box<::proto_google::protobuf::empty::Empty>),
  NotBoxed(ForeignMessage3),
  Boxed(::std::boxed::Box<ForeignMessage3>),
}
impl ::std::default::Default for RecursiveOneof {
  fn default() -> Self {
    RecursiveOneof {
      oneof_field: None,
    }
  }
}
lazy_static! {
  pub static ref RecursiveOneof_default: RecursiveOneof = RecursiveOneof::default();
}
impl ::pb_jelly::Message for RecursiveOneof {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "RecursiveOneof",
      full_name: "pbtest.RecursiveOneof",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "field",
          full_name: "pbtest.RecursiveOneof.field",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "empty",
          full_name: "pbtest.RecursiveOneof.empty",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "boxed_empty",
          full_name: "pbtest.RecursiveOneof.boxed_empty",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "not_boxed",
          full_name: "pbtest.RecursiveOneof.not_boxed",
          index: 3,
          number: 4,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
        ::pb_jelly::FieldDescriptor {
          name: "boxed",
          full_name: "pbtest.RecursiveOneof.boxed",
          index: 4,
          number: 5,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "oneof_field",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut field_size = 0;
    if let Some(RecursiveOneof_OneofField::Field(ref val)) = self.oneof_field {
      let val: &RecursiveOneof = &**val;
      let l = ::pb_jelly::Message::compute_size(val);
      field_size += ::pb_jelly::wire_format::serialized_length(1);
      field_size += ::pb_jelly::varint::serialized_length(l as u64);
      field_size += l;
    }
    size += field_size;
    let mut empty_size = 0;
    if let Some(RecursiveOneof_OneofField::Empty) = self.oneof_field {
      let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
      let l = ::pb_jelly::Message::compute_size(val);
      empty_size += ::pb_jelly::wire_format::serialized_length(2);
      empty_size += ::pb_jelly::varint::serialized_length(l as u64);
      empty_size += l;
    }
    size += empty_size;
    let mut boxed_empty_size = 0;
    if let Some(RecursiveOneof_OneofField::BoxedEmpty(ref val)) = self.oneof_field {
      let val: &::proto_google::protobuf::empty::Empty = &**val;
      let l = ::pb_jelly::Message::compute_size(val);
      boxed_empty_size += ::pb_jelly::wire_format::serialized_length(3);
      boxed_empty_size += ::pb_jelly::varint::serialized_length(l as u64);
      boxed_empty_size += l;
    }
    size += boxed_empty_size;
    let mut not_boxed_size = 0;
    if let Some(RecursiveOneof_OneofField::NotBoxed(ref val)) = self.oneof_field {
      let l = ::pb_jelly::Message::compute_size(val);
      not_boxed_size += ::pb_jelly::wire_format::serialized_length(4);
      not_boxed_size += ::pb_jelly::varint::serialized_length(l as u64);
      not_boxed_size += l;
    }
    size += not_boxed_size;
    let mut boxed_size = 0;
    if let Some(RecursiveOneof_OneofField::Boxed(ref val)) = self.oneof_field {
      let val: &ForeignMessage3 = &**val;
      let l = ::pb_jelly::Message::compute_size(val);
      boxed_size += ::pb_jelly::wire_format::serialized_length(5);
      boxed_size += ::pb_jelly::varint::serialized_length(l as u64);
      boxed_size += l;
    }
    size += boxed_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(RecursiveOneof_OneofField::Field(ref val)) = self.oneof_field {
      let val: &RecursiveOneof = &**val;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(RecursiveOneof_OneofField::Empty) = self.oneof_field {
      let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(RecursiveOneof_OneofField::BoxedEmpty(ref val)) = self.oneof_field {
      let val: &::proto_google::protobuf::empty::Empty = &**val;
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(RecursiveOneof_OneofField::NotBoxed(ref val)) = self.oneof_field {
      ::pb_jelly::wire_format::write(4, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    if let Some(RecursiveOneof_OneofField::Boxed(ref val)) = self.oneof_field {
      let val: &ForeignMessage3 = &**val;
      ::pb_jelly::wire_format::write(5, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, RecursiveOneof>(buf, typ, "RecursiveOneof", 1)?;
          self.oneof_field = Some(RecursiveOneof_OneofField::Field(Box::new(val)));
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::proto_google::protobuf::empty::Empty>(buf, typ, "RecursiveOneof", 2)?;
          self.oneof_field = Some(RecursiveOneof_OneofField::Empty);
        }
        3 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::proto_google::protobuf::empty::Empty>(buf, typ, "RecursiveOneof", 3)?;
          self.oneof_field = Some(RecursiveOneof_OneofField::BoxedEmpty(Box::new(val)));
        }
        4 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "RecursiveOneof", 4)?;
          self.oneof_field = Some(RecursiveOneof_OneofField::NotBoxed(val));
        }
        5 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ForeignMessage3>(buf, typ, "RecursiveOneof", 5)?;
          self.oneof_field = Some(RecursiveOneof_OneofField::Boxed(Box::new(val)));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for RecursiveOneof {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "oneof_field" => {
        if let Some(RecursiveOneof_OneofField::Field(ref val)) = self.oneof_field {
          let val: &RecursiveOneof = &**val;
          return Some("field");
        }
        if let Some(RecursiveOneof_OneofField::Empty) = self.oneof_field {
          let val: &::proto_google::protobuf::empty::Empty = &::std::default::Default::default();
          return Some("empty");
        }
        if let Some(RecursiveOneof_OneofField::BoxedEmpty(ref val)) = self.oneof_field {
          let val: &::proto_google::protobuf::empty::Empty = &**val;
          return Some("boxed_empty");
        }
        if let Some(RecursiveOneof_OneofField::NotBoxed(ref val)) = self.oneof_field {
          return Some("not_boxed");
        }
        if let Some(RecursiveOneof_OneofField::Boxed(ref val)) = self.oneof_field {
          let val: &ForeignMessage3 = &**val;
          return Some("boxed");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "field" => {
        match self.oneof_field {
          Some(RecursiveOneof_OneofField::Field(_)) => (),
          _ => {
            self.oneof_field = Some(RecursiveOneof_OneofField::Field(::std::default::Default::default()));
          },
        }
        if let Some(RecursiveOneof_OneofField::Field(ref mut val)) = self.oneof_field {
          let val = &mut **val;
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "empty" => {
        match self.oneof_field {
          Some(RecursiveOneof_OneofField::Empty) => (),
          _ => {
            self.oneof_field = Some(RecursiveOneof_OneofField::Empty);
          },
        }
        ::pb_jelly::reflection::FieldMut::Empty
      }
      "boxed_empty" => {
        match self.oneof_field {
          Some(RecursiveOneof_OneofField::BoxedEmpty(_)) => (),
          _ => {
            self.oneof_field = Some(RecursiveOneof_OneofField::BoxedEmpty(::std::default::Default::default()));
          },
        }
        if let Some(RecursiveOneof_OneofField::BoxedEmpty(ref mut val)) = self.oneof_field {
          let val = &mut **val;
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "not_boxed" => {
        match self.oneof_field {
          Some(RecursiveOneof_OneofField::NotBoxed(_)) => (),
          _ => {
            self.oneof_field = Some(RecursiveOneof_OneofField::NotBoxed(::std::default::Default::default()));
          },
        }
        if let Some(RecursiveOneof_OneofField::NotBoxed(ref mut val)) = self.oneof_field {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      "boxed" => {
        match self.oneof_field {
          Some(RecursiveOneof_OneofField::Boxed(_)) => (),
          _ => {
            self.oneof_field = Some(RecursiveOneof_OneofField::Boxed(::std::default::Default::default()));
          },
        }
        if let Some(RecursiveOneof_OneofField::Boxed(ref mut val)) = self.oneof_field {
          let val = &mut **val;
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MentionsKeywordPath {
  pub message: ::std::option::Option<super::r#mod::r#struct::Message>,
}
impl ::std::default::Default for MentionsKeywordPath {
  fn default() -> Self {
    MentionsKeywordPath {
      message: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref MentionsKeywordPath_default: MentionsKeywordPath = MentionsKeywordPath::default();
}
impl ::pb_jelly::Message for MentionsKeywordPath {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "MentionsKeywordPath",
      full_name: "pbtest.MentionsKeywordPath",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "message",
          full_name: "pbtest.MentionsKeywordPath.message",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut message_size = 0;
    if let Some(ref val) = self.message {
      let l = ::pb_jelly::Message::compute_size(val);
      message_size += ::pb_jelly::wire_format::serialized_length(1);
      message_size += ::pb_jelly::varint::serialized_length(l as u64);
      message_size += l;
    }
    size += message_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.message {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, super::r#mod::r#struct::Message>(buf, typ, "MentionsKeywordPath", 1)?;
          self.message = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for MentionsKeywordPath {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "message" => {
        ::pb_jelly::reflection::FieldMut::Value(self.message.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NonNullableOneofKeyword {
  pub r#async: NonNullableOneofKeyword_Async,
}
#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum NonNullableOneofKeyword_Async {
  A(i64),
}
impl ::std::default::Default for NonNullableOneofKeyword {
  fn default() -> Self {
    NonNullableOneofKeyword {
      r#async: NonNullableOneofKeyword_Async::A(::std::default::Default::default()),
    }
  }
}
lazy_static! {
  pub static ref NonNullableOneofKeyword_default: NonNullableOneofKeyword = NonNullableOneofKeyword::default();
}
impl ::pb_jelly::Message for NonNullableOneofKeyword {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "NonNullableOneofKeyword",
      full_name: "pbtest.NonNullableOneofKeyword",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "a",
          full_name: "pbtest.NonNullableOneofKeyword.a",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: Some(0),
        },
      ],
      oneofs: &[
        ::pb_jelly::OneofDescriptor {
          name: "async",
        },
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut a_size = 0;
    if let NonNullableOneofKeyword_Async::A(ref val) = self.r#async {
      let l = ::pb_jelly::Message::compute_size(val);
      a_size += ::pb_jelly::wire_format::serialized_length(1);
      a_size += l;
    }
    size += a_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let NonNullableOneofKeyword_Async::A(ref val) = self.r#async {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut oneof_async: ::std::option::Option<NonNullableOneofKeyword_Async> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, i64>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "NonNullableOneofKeyword", 1)?;
          oneof_async = Some(NonNullableOneofKeyword_Async::A(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match oneof_async {
      Some(v) => self.r#async = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "missing value for non-nullable oneof 'async' while parsing message pbtest.NonNullableOneofKeyword")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for NonNullableOneofKeyword {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      "async" => {
        if let NonNullableOneofKeyword_Async::A(ref val) = self.r#async {
          return Some("a");
        }
        None
      }
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "a" => {
        if let NonNullableOneofKeyword_Async::A(ref mut val) = self.r#async {
          return ::pb_jelly::reflection::FieldMut::Value(val);
        }
        unreachable!()
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NonNullableEnumKeyword {
  pub r#enum: TestMessage3_NestedMessage_NonNullableEnum,
}
impl ::std::default::Default for NonNullableEnumKeyword {
  fn default() -> Self {
    NonNullableEnumKeyword {
      r#enum: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref NonNullableEnumKeyword_default: NonNullableEnumKeyword = NonNullableEnumKeyword::default();
}
impl ::pb_jelly::Message for NonNullableEnumKeyword {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "NonNullableEnumKeyword",
      full_name: "pbtest.NonNullableEnumKeyword",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "enum",
          full_name: "pbtest.NonNullableEnumKeyword.enum",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::Varint,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut enum_size = 0;
    let val = &self.r#enum;
    let l = ::pb_jelly::Message::compute_size(val);
    enum_size += ::pb_jelly::wire_format::serialized_length(1);
    enum_size += l;
    size += enum_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    let val = &self.r#enum;
    ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::Varint, w)?;
    ::pb_jelly::Message::serialize(val, w)?;
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    let mut r#enum: ::std::option::Option<TestMessage3_NestedMessage_NonNullableEnum> = None;
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, TestMessage3_NestedMessage_NonNullableEnum>(buf, typ, ::pb_jelly::wire_format::Type::Varint, "NonNullableEnumKeyword", 1)?;
          r#enum = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    match r#enum {
      Some(v) => self.r#enum = v,
      None => return Err(::std::io::Error::new(::std::io::ErrorKind::InvalidInput, "err_if_default_or_unknown 'enum' had no value while parsing message pbtest.NonNullableEnumKeyword")),
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for NonNullableEnumKeyword {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "enum" => {
        ::pb_jelly::reflection::FieldMut::Value(&mut self.r#enum)
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MutuallyRecursiveA {
  pub inner: ::std::option::Option<::std::boxed::Box<MutuallyRecursiveB>>,
}
impl ::std::default::Default for MutuallyRecursiveA {
  fn default() -> Self {
    MutuallyRecursiveA {
      inner: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref MutuallyRecursiveA_default: MutuallyRecursiveA = MutuallyRecursiveA::default();
}
impl ::pb_jelly::Message for MutuallyRecursiveA {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "MutuallyRecursiveA",
      full_name: "pbtest.MutuallyRecursiveA",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "inner",
          full_name: "pbtest.MutuallyRecursiveA.inner",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut inner_size = 0;
    if let Some(ref val) = self.inner {
      let val = &**val;
      let l = ::pb_jelly::Message::compute_size(val);
      inner_size += ::pb_jelly::wire_format::serialized_length(1);
      inner_size += ::pb_jelly::varint::serialized_length(l as u64);
      inner_size += l;
    }
    size += inner_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.inner {
      let val = &**val;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, MutuallyRecursiveB>(buf, typ, "MutuallyRecursiveA", 1)?;
          self.inner = Some(Box::new(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for MutuallyRecursiveA {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "inner" => {
        ::pb_jelly::reflection::FieldMut::Value(self.inner.get_or_insert_with(::std::default::Default::default).as_mut())
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MutuallyRecursiveB {
  pub inner: ::std::option::Option<::std::boxed::Box<MutuallyRecursiveA>>,
}
impl ::std::default::Default for MutuallyRecursiveB {
  fn default() -> Self {
    MutuallyRecursiveB {
      inner: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref MutuallyRecursiveB_default: MutuallyRecursiveB = MutuallyRecursiveB::default();
}
impl ::pb_jelly::Message for MutuallyRecursiveB {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "MutuallyRecursiveB",
      full_name: "pbtest.MutuallyRecursiveB",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "inner",
          full_name: "pbtest.MutuallyRecursiveB.inner",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut inner_size = 0;
    if let Some(ref val) = self.inner {
      let val = &**val;
      let l = ::pb_jelly::Message::compute_size(val);
      inner_size += ::pb_jelly::wire_format::serialized_length(1);
      inner_size += ::pb_jelly::varint::serialized_length(l as u64);
      inner_size += l;
    }
    size += inner_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.inner {
      let val = &**val;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, MutuallyRecursiveA>(buf, typ, "MutuallyRecursiveB", 1)?;
          self.inner = Some(Box::new(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for MutuallyRecursiveB {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "inner" => {
        ::pb_jelly::reflection::FieldMut::Value(self.inner.get_or_insert_with(::std::default::Default::default).as_mut())
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MutuallyRecursiveWithRepeatedA {
  pub inner: ::std::vec::Vec<MutuallyRecursiveWithRepeatedB>,
}
impl ::std::default::Default for MutuallyRecursiveWithRepeatedA {
  fn default() -> Self {
    MutuallyRecursiveWithRepeatedA {
      inner: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref MutuallyRecursiveWithRepeatedA_default: MutuallyRecursiveWithRepeatedA = MutuallyRecursiveWithRepeatedA::default();
}
impl ::pb_jelly::Message for MutuallyRecursiveWithRepeatedA {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "MutuallyRecursiveWithRepeatedA",
      full_name: "pbtest.MutuallyRecursiveWithRepeatedA",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "inner",
          full_name: "pbtest.MutuallyRecursiveWithRepeatedA.inner",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut inner_size = 0;
    for val in &self.inner {
      let l = ::pb_jelly::Message::compute_size(val);
      inner_size += ::pb_jelly::wire_format::serialized_length(1);
      inner_size += ::pb_jelly::varint::serialized_length(l as u64);
      inner_size += l;
    }
    size += inner_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.inner {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, MutuallyRecursiveWithRepeatedB>(buf, typ, "MutuallyRecursiveWithRepeatedA", 1)?;
          self.inner.push(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for MutuallyRecursiveWithRepeatedA {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "inner" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MutuallyRecursiveWithRepeatedB {
  /// This field should *not* be boxed because `repeated` on the other message
  /// should suffice to break the cycle.
  pub inner: ::std::option::Option<MutuallyRecursiveWithRepeatedA>,
}
impl ::std::default::Default for MutuallyRecursiveWithRepeatedB {
  fn default() -> Self {
    MutuallyRecursiveWithRepeatedB {
      inner: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref MutuallyRecursiveWithRepeatedB_default: MutuallyRecursiveWithRepeatedB = MutuallyRecursiveWithRepeatedB::default();
}
impl ::pb_jelly::Message for MutuallyRecursiveWithRepeatedB {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "MutuallyRecursiveWithRepeatedB",
      full_name: "pbtest.MutuallyRecursiveWithRepeatedB",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "inner",
          full_name: "pbtest.MutuallyRecursiveWithRepeatedB.inner",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut inner_size = 0;
    if let Some(ref val) = self.inner {
      let l = ::pb_jelly::Message::compute_size(val);
      inner_size += ::pb_jelly::wire_format::serialized_length(1);
      inner_size += ::pb_jelly::varint::serialized_length(l as u64);
      inner_size += l;
    }
    size += inner_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.inner {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, MutuallyRecursiveWithRepeatedA>(buf, typ, "MutuallyRecursiveWithRepeatedB", 1)?;
          self.inner = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for MutuallyRecursiveWithRepeatedB {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "inner" => {
        ::pb_jelly::reflection::FieldMut::Value(self.inner.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MutuallyRecursiveWithBoxedA {
  pub inner: ::std::option::Option<::std::boxed::Box<MutuallyRecursiveWithBoxedB>>,
}
impl ::std::default::Default for MutuallyRecursiveWithBoxedA {
  fn default() -> Self {
    MutuallyRecursiveWithBoxedA {
      inner: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref MutuallyRecursiveWithBoxedA_default: MutuallyRecursiveWithBoxedA = MutuallyRecursiveWithBoxedA::default();
}
impl ::pb_jelly::Message for MutuallyRecursiveWithBoxedA {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "MutuallyRecursiveWithBoxedA",
      full_name: "pbtest.MutuallyRecursiveWithBoxedA",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "inner",
          full_name: "pbtest.MutuallyRecursiveWithBoxedA.inner",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut inner_size = 0;
    if let Some(ref val) = self.inner {
      let val = &**val;
      let l = ::pb_jelly::Message::compute_size(val);
      inner_size += ::pb_jelly::wire_format::serialized_length(1);
      inner_size += ::pb_jelly::varint::serialized_length(l as u64);
      inner_size += l;
    }
    size += inner_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.inner {
      let val = &**val;
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, MutuallyRecursiveWithBoxedB>(buf, typ, "MutuallyRecursiveWithBoxedA", 1)?;
          self.inner = Some(Box::new(val));
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for MutuallyRecursiveWithBoxedA {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "inner" => {
        ::pb_jelly::reflection::FieldMut::Value(self.inner.get_or_insert_with(::std::default::Default::default).as_mut())
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MutuallyRecursiveWithBoxedB {
  /// This field should not be boxed.
  pub inner: ::std::option::Option<MutuallyRecursiveWithBoxedA>,
}
impl ::std::default::Default for MutuallyRecursiveWithBoxedB {
  fn default() -> Self {
    MutuallyRecursiveWithBoxedB {
      inner: ::std::default::Default::default(),
    }
  }
}
lazy_static! {
  pub static ref MutuallyRecursiveWithBoxedB_default: MutuallyRecursiveWithBoxedB = MutuallyRecursiveWithBoxedB::default();
}
impl ::pb_jelly::Message for MutuallyRecursiveWithBoxedB {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "MutuallyRecursiveWithBoxedB",
      full_name: "pbtest.MutuallyRecursiveWithBoxedB",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "inner",
          full_name: "pbtest.MutuallyRecursiveWithBoxedB.inner",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut inner_size = 0;
    if let Some(ref val) = self.inner {
      let l = ::pb_jelly::Message::compute_size(val);
      inner_size += ::pb_jelly::wire_format::serialized_length(1);
      inner_size += ::pb_jelly::varint::serialized_length(l as u64);
      inner_size += l;
    }
    size += inner_size;
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.inner {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, MutuallyRecursiveWithBoxedA>(buf, typ, "MutuallyRecursiveWithBoxedB", 1)?;
          self.inner = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for MutuallyRecursiveWithBoxedB {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "inner" => {
        ::pb_jelly::reflection::FieldMut::Value(self.inner.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

