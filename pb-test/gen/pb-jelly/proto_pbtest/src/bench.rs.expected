// @generated, do not edit
#[derive(Clone, Debug, PartialEq)]
pub struct BytesData {
  /// Using the `zero_copy` option, the `bytes` type maps to `pb::Lazy<bytes::Bytes>`
  pub data: ::std::option::Option<::pb_jelly::Lazy<::bytes::Bytes>>,
}
impl BytesData {
  pub fn has_data(&self) -> bool {
    self.data.is_some()
  }
  pub fn set_data(&mut self, v: ::pb_jelly::Lazy<::bytes::Bytes>) {
    self.data = Some(v);
  }
  pub fn take_data(&mut self) -> ::pb_jelly::Lazy<::bytes::Bytes> {
    self.data.take().unwrap_or_default()
  }
}
impl ::std::default::Default for BytesData {
  fn default() -> Self {
    BytesData {
      data: ::std::default::Default::default(),
    }
  }
}
::lazy_static::lazy_static! {
  pub static ref BytesData_default: BytesData = BytesData::default();
}
impl ::pb_jelly::Message for BytesData {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "BytesData",
      full_name: "pbtest.BytesData",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "data",
          full_name: "pbtest.BytesData.data",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0usize;
    if let Some(ref val) = self.data {
      size += ::pb_jelly::helpers::compute_size_field::<::pb_jelly::Lazy<::bytes::Bytes>>(val, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    size
  }
  fn compute_grpc_slices_size(&self) -> usize {
    let mut size = 0usize;
    if let Some(ref val) = self.data {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.data {
      ::pb_jelly::helpers::serialize_field::<W, ::pb_jelly::Lazy<::bytes::Bytes>>(w, val, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::pb_jelly::Lazy<::bytes::Bytes>>(buf, typ, "BytesData", 1)?;
          self.data = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for BytesData {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "data" => {
        ::pb_jelly::reflection::FieldMut::Value(self.data.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct VecData {
  /// By default, the `bytes` type maps to Vec<u8>
  pub data: ::std::option::Option<::std::vec::Vec<u8>>,
}
impl VecData {
  pub fn has_data(&self) -> bool {
    self.data.is_some()
  }
  pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
    self.data = Some(v);
  }
  pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
    self.data.take().unwrap_or_default()
  }
  pub fn get_data(&self) -> &[u8] {
    self.data.as_deref().unwrap_or(&[])
  }
}
impl ::std::default::Default for VecData {
  fn default() -> Self {
    VecData {
      data: ::std::default::Default::default(),
    }
  }
}
::lazy_static::lazy_static! {
  pub static ref VecData_default: VecData = VecData::default();
}
impl ::pb_jelly::Message for VecData {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "VecData",
      full_name: "pbtest.VecData",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "data",
          full_name: "pbtest.VecData.data",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0usize;
    if let Some(ref val) = self.data {
      size += ::pb_jelly::helpers::compute_size_field::<::std::vec::Vec<u8>>(val, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.data {
      ::pb_jelly::helpers::serialize_field::<W, ::std::vec::Vec<u8>>(w, val, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::vec::Vec<u8>>(buf, typ, "VecData", 1)?;
          self.data = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for VecData {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "data" => {
        ::pb_jelly::reflection::FieldMut::Value(self.data.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StringMessage {
  pub data: ::std::option::Option<::std::string::String>,
}
impl StringMessage {
  pub fn has_data(&self) -> bool {
    self.data.is_some()
  }
  pub fn set_data(&mut self, v: ::std::string::String) {
    self.data = Some(v);
  }
  pub fn take_data(&mut self) -> ::std::string::String {
    self.data.take().unwrap_or_default()
  }
  pub fn get_data(&self) -> &str {
    self.data.as_deref().unwrap_or("")
  }
}
impl ::std::default::Default for StringMessage {
  fn default() -> Self {
    StringMessage {
      data: ::std::default::Default::default(),
    }
  }
}
::lazy_static::lazy_static! {
  pub static ref StringMessage_default: StringMessage = StringMessage::default();
}
impl ::pb_jelly::Message for StringMessage {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "StringMessage",
      full_name: "pbtest.StringMessage",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "data",
          full_name: "pbtest.StringMessage.data",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0usize;
    if let Some(ref val) = self.data {
      size += ::pb_jelly::helpers::compute_size_field::<::std::string::String>(val, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.data {
      ::pb_jelly::helpers::serialize_field::<W, ::std::string::String>(w, val, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "StringMessage", 1)?;
          self.data = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for StringMessage {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "data" => {
        ::pb_jelly::reflection::FieldMut::Value(self.data.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StringMessageSSO {
  pub data: ::std::option::Option<::compact_str::CompactString>,
}
impl StringMessageSSO {
  pub fn has_data(&self) -> bool {
    self.data.is_some()
  }
  pub fn set_data(&mut self, v: ::compact_str::CompactString) {
    self.data = Some(v);
  }
  pub fn take_data(&mut self) -> ::compact_str::CompactString {
    self.data.take().unwrap_or_default()
  }
  pub fn get_data(&self) -> &str {
    self.data.as_deref().unwrap_or("")
  }
}
impl ::std::default::Default for StringMessageSSO {
  fn default() -> Self {
    StringMessageSSO {
      data: ::std::default::Default::default(),
    }
  }
}
::lazy_static::lazy_static! {
  pub static ref StringMessageSSO_default: StringMessageSSO = StringMessageSSO::default();
}
impl ::pb_jelly::Message for StringMessageSSO {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "StringMessageSSO",
      full_name: "pbtest.StringMessageSSO",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "data",
          full_name: "pbtest.StringMessageSSO.data",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0usize;
    if let Some(ref val) = self.data {
      size += ::pb_jelly::helpers::compute_size_field::<::compact_str::CompactString>(val, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.data {
      ::pb_jelly::helpers::serialize_field::<W, ::compact_str::CompactString>(w, val, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::compact_str::CompactString>(buf, typ, "StringMessageSSO", 1)?;
          self.data = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for StringMessageSSO {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "data" => {
        ::pb_jelly::reflection::FieldMut::Value(self.data.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct Cities {
  pub cities: ::std::vec::Vec<City>,
}
impl Cities {
  pub fn set_cities(&mut self, v: ::std::vec::Vec<City>) {
    self.cities = v;
  }
  pub fn take_cities(&mut self) -> ::std::vec::Vec<City> {
    ::std::mem::take(&mut self.cities)
  }
  pub fn get_cities(&self) -> &[City] {
    &self.cities
  }
  pub fn mut_cities(&mut self) -> &mut ::std::vec::Vec<City> {
    &mut self.cities
  }
}
impl ::std::default::Default for Cities {
  fn default() -> Self {
    Cities {
      cities: ::std::default::Default::default(),
    }
  }
}
::lazy_static::lazy_static! {
  pub static ref Cities_default: Cities = Cities::default();
}
impl ::pb_jelly::Message for Cities {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Cities",
      full_name: "pbtest.Cities",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "cities",
          full_name: "pbtest.Cities.cities",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0usize;
    for val in &self.cities {
      size += ::pb_jelly::helpers::compute_size_field::<City>(val, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.cities {
      ::pb_jelly::helpers::serialize_field::<W, City>(w, val, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, City>(buf, typ, "Cities", 1)?;
          self.cities.push(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Cities {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "cities" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct City {
  pub city: ::std::option::Option<::std::string::String>,
  pub growth_from_2000_to_2013: ::std::option::Option<::std::string::String>,
  pub latitude: ::std::option::Option<f64>,
  pub longitude: ::std::option::Option<f64>,
  pub population: ::std::option::Option<::std::string::String>,
  pub rank: ::std::option::Option<::std::string::String>,
  pub state: ::std::option::Option<::std::string::String>,
}
impl City {
  pub fn has_city(&self) -> bool {
    self.city.is_some()
  }
  pub fn set_city(&mut self, v: ::std::string::String) {
    self.city = Some(v);
  }
  pub fn take_city(&mut self) -> ::std::string::String {
    self.city.take().unwrap_or_default()
  }
  pub fn get_city(&self) -> &str {
    self.city.as_deref().unwrap_or("")
  }
  pub fn has_growth_from_2000_to_2013(&self) -> bool {
    self.growth_from_2000_to_2013.is_some()
  }
  pub fn set_growth_from_2000_to_2013(&mut self, v: ::std::string::String) {
    self.growth_from_2000_to_2013 = Some(v);
  }
  pub fn take_growth_from_2000_to_2013(&mut self) -> ::std::string::String {
    self.growth_from_2000_to_2013.take().unwrap_or_default()
  }
  pub fn get_growth_from_2000_to_2013(&self) -> &str {
    self.growth_from_2000_to_2013.as_deref().unwrap_or("")
  }
  pub fn has_latitude(&self) -> bool {
    self.latitude.is_some()
  }
  pub fn set_latitude(&mut self, v: f64) {
    self.latitude = Some(v);
  }
  pub fn get_latitude(&self) -> f64 {
    self.latitude.unwrap_or(0f64)
  }
  pub fn has_longitude(&self) -> bool {
    self.longitude.is_some()
  }
  pub fn set_longitude(&mut self, v: f64) {
    self.longitude = Some(v);
  }
  pub fn get_longitude(&self) -> f64 {
    self.longitude.unwrap_or(0f64)
  }
  pub fn has_population(&self) -> bool {
    self.population.is_some()
  }
  pub fn set_population(&mut self, v: ::std::string::String) {
    self.population = Some(v);
  }
  pub fn take_population(&mut self) -> ::std::string::String {
    self.population.take().unwrap_or_default()
  }
  pub fn get_population(&self) -> &str {
    self.population.as_deref().unwrap_or("")
  }
  pub fn has_rank(&self) -> bool {
    self.rank.is_some()
  }
  pub fn set_rank(&mut self, v: ::std::string::String) {
    self.rank = Some(v);
  }
  pub fn take_rank(&mut self) -> ::std::string::String {
    self.rank.take().unwrap_or_default()
  }
  pub fn get_rank(&self) -> &str {
    self.rank.as_deref().unwrap_or("")
  }
  pub fn has_state(&self) -> bool {
    self.state.is_some()
  }
  pub fn set_state(&mut self, v: ::std::string::String) {
    self.state = Some(v);
  }
  pub fn take_state(&mut self) -> ::std::string::String {
    self.state.take().unwrap_or_default()
  }
  pub fn get_state(&self) -> &str {
    self.state.as_deref().unwrap_or("")
  }
}
impl ::std::default::Default for City {
  fn default() -> Self {
    City {
      city: ::std::default::Default::default(),
      growth_from_2000_to_2013: ::std::default::Default::default(),
      latitude: ::std::default::Default::default(),
      longitude: ::std::default::Default::default(),
      population: ::std::default::Default::default(),
      rank: ::std::default::Default::default(),
      state: ::std::default::Default::default(),
    }
  }
}
::lazy_static::lazy_static! {
  pub static ref City_default: City = City::default();
}
impl ::pb_jelly::Message for City {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "City",
      full_name: "pbtest.City",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "city",
          full_name: "pbtest.City.city",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "growth_from_2000_to_2013",
          full_name: "pbtest.City.growth_from_2000_to_2013",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "latitude",
          full_name: "pbtest.City.latitude",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "longitude",
          full_name: "pbtest.City.longitude",
          index: 3,
          number: 4,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "population",
          full_name: "pbtest.City.population",
          index: 4,
          number: 5,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "rank",
          full_name: "pbtest.City.rank",
          index: 5,
          number: 6,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "state",
          full_name: "pbtest.City.state",
          index: 6,
          number: 7,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0usize;
    if let Some(ref val) = self.city {
      size += ::pb_jelly::helpers::compute_size_field::<::std::string::String>(val, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    if let Some(ref val) = self.growth_from_2000_to_2013 {
      size += ::pb_jelly::helpers::compute_size_field::<::std::string::String>(val, 2, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    if let Some(ref val) = self.latitude {
      size += ::pb_jelly::helpers::compute_size_field::<f64>(val, 3, ::pb_jelly::wire_format::Type::Fixed64);
    }
    if let Some(ref val) = self.longitude {
      size += ::pb_jelly::helpers::compute_size_field::<f64>(val, 4, ::pb_jelly::wire_format::Type::Fixed64);
    }
    if let Some(ref val) = self.population {
      size += ::pb_jelly::helpers::compute_size_field::<::std::string::String>(val, 5, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    if let Some(ref val) = self.rank {
      size += ::pb_jelly::helpers::compute_size_field::<::std::string::String>(val, 6, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    if let Some(ref val) = self.state {
      size += ::pb_jelly::helpers::compute_size_field::<::std::string::String>(val, 7, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.city {
      ::pb_jelly::helpers::serialize_field::<W, ::std::string::String>(w, val, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    if let Some(ref val) = self.growth_from_2000_to_2013 {
      ::pb_jelly::helpers::serialize_field::<W, ::std::string::String>(w, val, 2, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    if let Some(ref val) = self.latitude {
      ::pb_jelly::helpers::serialize_field::<W, f64>(w, val, 3, ::pb_jelly::wire_format::Type::Fixed64)?;
    }
    if let Some(ref val) = self.longitude {
      ::pb_jelly::helpers::serialize_field::<W, f64>(w, val, 4, ::pb_jelly::wire_format::Type::Fixed64)?;
    }
    if let Some(ref val) = self.population {
      ::pb_jelly::helpers::serialize_field::<W, ::std::string::String>(w, val, 5, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    if let Some(ref val) = self.rank {
      ::pb_jelly::helpers::serialize_field::<W, ::std::string::String>(w, val, 6, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    if let Some(ref val) = self.state {
      ::pb_jelly::helpers::serialize_field::<W, ::std::string::String>(w, val, 7, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "City", 1)?;
          self.city = Some(val);
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "City", 2)?;
          self.growth_from_2000_to_2013 = Some(val);
        }
        3 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "City", 3)?;
          self.latitude = Some(val);
        }
        4 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "City", 4)?;
          self.longitude = Some(val);
        }
        5 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "City", 5)?;
          self.population = Some(val);
        }
        6 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "City", 6)?;
          self.rank = Some(val);
        }
        7 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::std::string::String>(buf, typ, "City", 7)?;
          self.state = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for City {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "city" => {
        ::pb_jelly::reflection::FieldMut::Value(self.city.get_or_insert_with(::std::default::Default::default))
      }
      "growth_from_2000_to_2013" => {
        ::pb_jelly::reflection::FieldMut::Value(self.growth_from_2000_to_2013.get_or_insert_with(::std::default::Default::default))
      }
      "latitude" => {
        ::pb_jelly::reflection::FieldMut::Value(self.latitude.get_or_insert_with(::std::default::Default::default))
      }
      "longitude" => {
        ::pb_jelly::reflection::FieldMut::Value(self.longitude.get_or_insert_with(::std::default::Default::default))
      }
      "population" => {
        ::pb_jelly::reflection::FieldMut::Value(self.population.get_or_insert_with(::std::default::Default::default))
      }
      "rank" => {
        ::pb_jelly::reflection::FieldMut::Value(self.rank.get_or_insert_with(::std::default::Default::default))
      }
      "state" => {
        ::pb_jelly::reflection::FieldMut::Value(self.state.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct CitiesSSO {
  pub cities: ::std::vec::Vec<CitySSO>,
}
impl CitiesSSO {
  pub fn set_cities(&mut self, v: ::std::vec::Vec<CitySSO>) {
    self.cities = v;
  }
  pub fn take_cities(&mut self) -> ::std::vec::Vec<CitySSO> {
    ::std::mem::take(&mut self.cities)
  }
  pub fn get_cities(&self) -> &[CitySSO] {
    &self.cities
  }
  pub fn mut_cities(&mut self) -> &mut ::std::vec::Vec<CitySSO> {
    &mut self.cities
  }
}
impl ::std::default::Default for CitiesSSO {
  fn default() -> Self {
    CitiesSSO {
      cities: ::std::default::Default::default(),
    }
  }
}
::lazy_static::lazy_static! {
  pub static ref CitiesSSO_default: CitiesSSO = CitiesSSO::default();
}
impl ::pb_jelly::Message for CitiesSSO {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "CitiesSSO",
      full_name: "pbtest.CitiesSSO",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "cities",
          full_name: "pbtest.CitiesSSO.cities",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0usize;
    for val in &self.cities {
      size += ::pb_jelly::helpers::compute_size_field::<CitySSO>(val, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.cities {
      ::pb_jelly::helpers::serialize_field::<W, CitySSO>(w, val, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, CitySSO>(buf, typ, "CitiesSSO", 1)?;
          self.cities.push(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for CitiesSSO {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "cities" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct CitySSO {
  pub city: ::std::option::Option<::compact_str::CompactString>,
  pub growth_from_2000_to_2013: ::std::option::Option<::compact_str::CompactString>,
  pub latitude: ::std::option::Option<f64>,
  pub longitude: ::std::option::Option<f64>,
  pub population: ::std::option::Option<::compact_str::CompactString>,
  pub rank: ::std::option::Option<::compact_str::CompactString>,
  pub state: ::std::option::Option<::compact_str::CompactString>,
}
impl CitySSO {
  pub fn has_city(&self) -> bool {
    self.city.is_some()
  }
  pub fn set_city(&mut self, v: ::compact_str::CompactString) {
    self.city = Some(v);
  }
  pub fn take_city(&mut self) -> ::compact_str::CompactString {
    self.city.take().unwrap_or_default()
  }
  pub fn get_city(&self) -> &str {
    self.city.as_deref().unwrap_or("")
  }
  pub fn has_growth_from_2000_to_2013(&self) -> bool {
    self.growth_from_2000_to_2013.is_some()
  }
  pub fn set_growth_from_2000_to_2013(&mut self, v: ::compact_str::CompactString) {
    self.growth_from_2000_to_2013 = Some(v);
  }
  pub fn take_growth_from_2000_to_2013(&mut self) -> ::compact_str::CompactString {
    self.growth_from_2000_to_2013.take().unwrap_or_default()
  }
  pub fn get_growth_from_2000_to_2013(&self) -> &str {
    self.growth_from_2000_to_2013.as_deref().unwrap_or("")
  }
  pub fn has_latitude(&self) -> bool {
    self.latitude.is_some()
  }
  pub fn set_latitude(&mut self, v: f64) {
    self.latitude = Some(v);
  }
  pub fn get_latitude(&self) -> f64 {
    self.latitude.unwrap_or(0f64)
  }
  pub fn has_longitude(&self) -> bool {
    self.longitude.is_some()
  }
  pub fn set_longitude(&mut self, v: f64) {
    self.longitude = Some(v);
  }
  pub fn get_longitude(&self) -> f64 {
    self.longitude.unwrap_or(0f64)
  }
  pub fn has_population(&self) -> bool {
    self.population.is_some()
  }
  pub fn set_population(&mut self, v: ::compact_str::CompactString) {
    self.population = Some(v);
  }
  pub fn take_population(&mut self) -> ::compact_str::CompactString {
    self.population.take().unwrap_or_default()
  }
  pub fn get_population(&self) -> &str {
    self.population.as_deref().unwrap_or("")
  }
  pub fn has_rank(&self) -> bool {
    self.rank.is_some()
  }
  pub fn set_rank(&mut self, v: ::compact_str::CompactString) {
    self.rank = Some(v);
  }
  pub fn take_rank(&mut self) -> ::compact_str::CompactString {
    self.rank.take().unwrap_or_default()
  }
  pub fn get_rank(&self) -> &str {
    self.rank.as_deref().unwrap_or("")
  }
  pub fn has_state(&self) -> bool {
    self.state.is_some()
  }
  pub fn set_state(&mut self, v: ::compact_str::CompactString) {
    self.state = Some(v);
  }
  pub fn take_state(&mut self) -> ::compact_str::CompactString {
    self.state.take().unwrap_or_default()
  }
  pub fn get_state(&self) -> &str {
    self.state.as_deref().unwrap_or("")
  }
}
impl ::std::default::Default for CitySSO {
  fn default() -> Self {
    CitySSO {
      city: ::std::default::Default::default(),
      growth_from_2000_to_2013: ::std::default::Default::default(),
      latitude: ::std::default::Default::default(),
      longitude: ::std::default::Default::default(),
      population: ::std::default::Default::default(),
      rank: ::std::default::Default::default(),
      state: ::std::default::Default::default(),
    }
  }
}
::lazy_static::lazy_static! {
  pub static ref CitySSO_default: CitySSO = CitySSO::default();
}
impl ::pb_jelly::Message for CitySSO {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "CitySSO",
      full_name: "pbtest.CitySSO",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "city",
          full_name: "pbtest.CitySSO.city",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "growth_from_2000_to_2013",
          full_name: "pbtest.CitySSO.growth_from_2000_to_2013",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "latitude",
          full_name: "pbtest.CitySSO.latitude",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "longitude",
          full_name: "pbtest.CitySSO.longitude",
          index: 3,
          number: 4,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "population",
          full_name: "pbtest.CitySSO.population",
          index: 4,
          number: 5,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "rank",
          full_name: "pbtest.CitySSO.rank",
          index: 5,
          number: 6,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "state",
          full_name: "pbtest.CitySSO.state",
          index: 6,
          number: 7,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0usize;
    if let Some(ref val) = self.city {
      size += ::pb_jelly::helpers::compute_size_field::<::compact_str::CompactString>(val, 1, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    if let Some(ref val) = self.growth_from_2000_to_2013 {
      size += ::pb_jelly::helpers::compute_size_field::<::compact_str::CompactString>(val, 2, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    if let Some(ref val) = self.latitude {
      size += ::pb_jelly::helpers::compute_size_field::<f64>(val, 3, ::pb_jelly::wire_format::Type::Fixed64);
    }
    if let Some(ref val) = self.longitude {
      size += ::pb_jelly::helpers::compute_size_field::<f64>(val, 4, ::pb_jelly::wire_format::Type::Fixed64);
    }
    if let Some(ref val) = self.population {
      size += ::pb_jelly::helpers::compute_size_field::<::compact_str::CompactString>(val, 5, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    if let Some(ref val) = self.rank {
      size += ::pb_jelly::helpers::compute_size_field::<::compact_str::CompactString>(val, 6, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    if let Some(ref val) = self.state {
      size += ::pb_jelly::helpers::compute_size_field::<::compact_str::CompactString>(val, 7, ::pb_jelly::wire_format::Type::LengthDelimited);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    if let Some(ref val) = self.city {
      ::pb_jelly::helpers::serialize_field::<W, ::compact_str::CompactString>(w, val, 1, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    if let Some(ref val) = self.growth_from_2000_to_2013 {
      ::pb_jelly::helpers::serialize_field::<W, ::compact_str::CompactString>(w, val, 2, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    if let Some(ref val) = self.latitude {
      ::pb_jelly::helpers::serialize_field::<W, f64>(w, val, 3, ::pb_jelly::wire_format::Type::Fixed64)?;
    }
    if let Some(ref val) = self.longitude {
      ::pb_jelly::helpers::serialize_field::<W, f64>(w, val, 4, ::pb_jelly::wire_format::Type::Fixed64)?;
    }
    if let Some(ref val) = self.population {
      ::pb_jelly::helpers::serialize_field::<W, ::compact_str::CompactString>(w, val, 5, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    if let Some(ref val) = self.rank {
      ::pb_jelly::helpers::serialize_field::<W, ::compact_str::CompactString>(w, val, 6, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    if let Some(ref val) = self.state {
      ::pb_jelly::helpers::serialize_field::<W, ::compact_str::CompactString>(w, val, 7, ::pb_jelly::wire_format::Type::LengthDelimited)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::compact_str::CompactString>(buf, typ, "CitySSO", 1)?;
          self.city = Some(val);
        }
        2 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::compact_str::CompactString>(buf, typ, "CitySSO", 2)?;
          self.growth_from_2000_to_2013 = Some(val);
        }
        3 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "CitySSO", 3)?;
          self.latitude = Some(val);
        }
        4 => {
          let val = ::pb_jelly::helpers::deserialize_known_length::<B, f64>(buf, typ, ::pb_jelly::wire_format::Type::Fixed64, "CitySSO", 4)?;
          self.longitude = Some(val);
        }
        5 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::compact_str::CompactString>(buf, typ, "CitySSO", 5)?;
          self.population = Some(val);
        }
        6 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::compact_str::CompactString>(buf, typ, "CitySSO", 6)?;
          self.rank = Some(val);
        }
        7 => {
          let val = ::pb_jelly::helpers::deserialize_length_delimited::<B, ::compact_str::CompactString>(buf, typ, "CitySSO", 7)?;
          self.state = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for CitySSO {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "city" => {
        ::pb_jelly::reflection::FieldMut::Value(self.city.get_or_insert_with(::std::default::Default::default))
      }
      "growth_from_2000_to_2013" => {
        ::pb_jelly::reflection::FieldMut::Value(self.growth_from_2000_to_2013.get_or_insert_with(::std::default::Default::default))
      }
      "latitude" => {
        ::pb_jelly::reflection::FieldMut::Value(self.latitude.get_or_insert_with(::std::default::Default::default))
      }
      "longitude" => {
        ::pb_jelly::reflection::FieldMut::Value(self.longitude.get_or_insert_with(::std::default::Default::default))
      }
      "population" => {
        ::pb_jelly::reflection::FieldMut::Value(self.population.get_or_insert_with(::std::default::Default::default))
      }
      "rank" => {
        ::pb_jelly::reflection::FieldMut::Value(self.rank.get_or_insert_with(::std::default::Default::default))
      }
      "state" => {
        ::pb_jelly::reflection::FieldMut::Value(self.state.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

