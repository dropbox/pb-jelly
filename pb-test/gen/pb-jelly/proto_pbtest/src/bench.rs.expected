// @generated, do not edit
#[derive(Clone, Debug, PartialEq)]
pub struct BytesData {
  /// Using the `zero_copy` option, the `bytes` type maps to `pb::Lazy<bytes::Bytes>`
  pub data: ::std::option::Option<::pb_jelly::Lazy<::bytes::Bytes>>,
}
impl BytesData {
  pub fn has_data(&self) -> bool {
    self.data.is_some()
  }
  pub fn set_data(&mut self, v: ::pb_jelly::Lazy<::bytes::Bytes>) {
    self.data = Some(v);
  }
  pub fn take_data(&mut self) -> ::pb_jelly::Lazy<::bytes::Bytes> {
    self.data.take().unwrap_or_default()
  }
}
impl ::std::default::Default for BytesData {
  fn default() -> Self {
    BytesData {
      data: ::std::default::Default::default(),
    }
  }
}
impl ::pb_jelly::Message for BytesData {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "BytesData",
      full_name: "pbtest.BytesData",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "data",
          full_name: "pbtest.BytesData.data",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut data_size = 0;
    for val in &self.data {
      let l = ::pb_jelly::Message::compute_size(val);
      data_size += ::pb_jelly::wire_format::serialized_length(1);
      data_size += ::pb_jelly::varint::serialized_length(l as u64);
      data_size += l;
    }
    size += data_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize {
    let mut size = 0;
    for val in &self.data {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.data {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "BytesData", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::pb_jelly::Lazy<::bytes::Bytes> = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.data = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for BytesData {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "data" => {
        ::pb_jelly::reflection::FieldMut::Value(self.data.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct VecData {
  /// By default, the `bytes` type maps to Vec<u8>
  pub data: ::std::option::Option<::std::vec::Vec<u8>>,
}
impl VecData {
  pub fn has_data(&self) -> bool {
    self.data.is_some()
  }
  pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
    self.data = Some(v);
  }
  pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
    self.data.take().unwrap_or_default()
  }
  pub fn get_data(&self) -> &[u8] {
    self.data.as_deref().unwrap_or(&[])
  }
}
impl ::std::default::Default for VecData {
  fn default() -> Self {
    VecData {
      data: ::std::default::Default::default(),
    }
  }
}
impl ::pb_jelly::Message for VecData {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "VecData",
      full_name: "pbtest.VecData",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "data",
          full_name: "pbtest.VecData.data",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut data_size = 0;
    for val in &self.data {
      let l = ::pb_jelly::Message::compute_size(val);
      data_size += ::pb_jelly::wire_format::serialized_length(1);
      data_size += ::pb_jelly::varint::serialized_length(l as u64);
      data_size += l;
    }
    size += data_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize {
    let mut size = 0;
    for val in &self.data {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.data {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "VecData", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::vec::Vec<u8> = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.data = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for VecData {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "data" => {
        ::pb_jelly::reflection::FieldMut::Value(self.data.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StringMessage {
  pub data: ::std::option::Option<::std::string::String>,
}
impl StringMessage {
  pub fn has_data(&self) -> bool {
    self.data.is_some()
  }
  pub fn set_data(&mut self, v: ::std::string::String) {
    self.data = Some(v);
  }
  pub fn take_data(&mut self) -> ::std::string::String {
    self.data.take().unwrap_or_default()
  }
  pub fn get_data(&self) -> &str {
    self.data.as_deref().unwrap_or("")
  }
}
impl ::std::default::Default for StringMessage {
  fn default() -> Self {
    StringMessage {
      data: ::std::default::Default::default(),
    }
  }
}
impl ::pb_jelly::Message for StringMessage {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "StringMessage",
      full_name: "pbtest.StringMessage",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "data",
          full_name: "pbtest.StringMessage.data",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut data_size = 0;
    for val in &self.data {
      let l = ::pb_jelly::Message::compute_size(val);
      data_size += ::pb_jelly::wire_format::serialized_length(1);
      data_size += ::pb_jelly::varint::serialized_length(l as u64);
      data_size += l;
    }
    size += data_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize {
    let mut size = 0;
    for val in &self.data {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.data {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "StringMessage", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.data = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for StringMessage {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "data" => {
        ::pb_jelly::reflection::FieldMut::Value(self.data.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StringMessageSSO {
  pub data: ::std::option::Option<::compact_str::CompactString>,
}
impl StringMessageSSO {
  pub fn has_data(&self) -> bool {
    self.data.is_some()
  }
  pub fn set_data(&mut self, v: ::compact_str::CompactString) {
    self.data = Some(v);
  }
  pub fn take_data(&mut self) -> ::compact_str::CompactString {
    self.data.take().unwrap_or_default()
  }
  pub fn get_data(&self) -> &str {
    self.data.as_deref().unwrap_or("")
  }
}
impl ::std::default::Default for StringMessageSSO {
  fn default() -> Self {
    StringMessageSSO {
      data: ::std::default::Default::default(),
    }
  }
}
impl ::pb_jelly::Message for StringMessageSSO {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "StringMessageSSO",
      full_name: "pbtest.StringMessageSSO",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "data",
          full_name: "pbtest.StringMessageSSO.data",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Optional,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut data_size = 0;
    for val in &self.data {
      let l = ::pb_jelly::Message::compute_size(val);
      data_size += ::pb_jelly::wire_format::serialized_length(1);
      data_size += ::pb_jelly::varint::serialized_length(l as u64);
      data_size += l;
    }
    size += data_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize {
    let mut size = 0;
    for val in &self.data {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.data {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "StringMessageSSO", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::compact_str::CompactString = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.data = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for StringMessageSSO {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "data" => {
        ::pb_jelly::reflection::FieldMut::Value(self.data.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct Cities {
  pub cities: ::std::vec::Vec<City>,
}
impl Cities {
  pub fn set_cities(&mut self, v: ::std::vec::Vec<City>) {
    self.cities = v;
  }
  pub fn take_cities(&mut self) -> ::std::vec::Vec<City> {
    ::std::mem::take(&mut self.cities)
  }
  pub fn get_cities(&self) -> &[City] {
    &self.cities
  }
  pub fn mut_cities(&mut self) -> &mut ::std::vec::Vec<City> {
    &mut self.cities
  }
}
impl ::std::default::Default for Cities {
  fn default() -> Self {
    Cities {
      cities: ::std::default::Default::default(),
    }
  }
}
impl ::pb_jelly::Message for Cities {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "Cities",
      full_name: "pbtest.Cities",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "cities",
          full_name: "pbtest.Cities.cities",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut cities_size = 0;
    for val in &self.cities {
      let l = ::pb_jelly::Message::compute_size(val);
      cities_size += ::pb_jelly::wire_format::serialized_length(1);
      cities_size += ::pb_jelly::varint::serialized_length(l as u64);
      cities_size += l;
    }
    size += cities_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize {
    let mut size = 0;
    for val in &self.cities {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.cities {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "Cities", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: City = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.cities.push(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for Cities {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "cities" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct City {
  pub city: ::std::option::Option<::std::string::String>,
  pub growth_from_2000_to_2013: ::std::option::Option<::std::string::String>,
  pub latitude: ::std::option::Option<f64>,
  pub longitude: ::std::option::Option<f64>,
  pub population: ::std::option::Option<::std::string::String>,
  pub rank: ::std::option::Option<::std::string::String>,
  pub state: ::std::option::Option<::std::string::String>,
}
impl City {
  pub fn has_city(&self) -> bool {
    self.city.is_some()
  }
  pub fn set_city(&mut self, v: ::std::string::String) {
    self.city = Some(v);
  }
  pub fn take_city(&mut self) -> ::std::string::String {
    self.city.take().unwrap_or_default()
  }
  pub fn get_city(&self) -> &str {
    self.city.as_deref().unwrap_or("")
  }
  pub fn has_growth_from_2000_to_2013(&self) -> bool {
    self.growth_from_2000_to_2013.is_some()
  }
  pub fn set_growth_from_2000_to_2013(&mut self, v: ::std::string::String) {
    self.growth_from_2000_to_2013 = Some(v);
  }
  pub fn take_growth_from_2000_to_2013(&mut self) -> ::std::string::String {
    self.growth_from_2000_to_2013.take().unwrap_or_default()
  }
  pub fn get_growth_from_2000_to_2013(&self) -> &str {
    self.growth_from_2000_to_2013.as_deref().unwrap_or("")
  }
  pub fn has_latitude(&self) -> bool {
    self.latitude.is_some()
  }
  pub fn set_latitude(&mut self, v: f64) {
    self.latitude = Some(v);
  }
  pub fn get_latitude(&self) -> f64 {
    self.latitude.unwrap_or(0.)
  }
  pub fn has_longitude(&self) -> bool {
    self.longitude.is_some()
  }
  pub fn set_longitude(&mut self, v: f64) {
    self.longitude = Some(v);
  }
  pub fn get_longitude(&self) -> f64 {
    self.longitude.unwrap_or(0.)
  }
  pub fn has_population(&self) -> bool {
    self.population.is_some()
  }
  pub fn set_population(&mut self, v: ::std::string::String) {
    self.population = Some(v);
  }
  pub fn take_population(&mut self) -> ::std::string::String {
    self.population.take().unwrap_or_default()
  }
  pub fn get_population(&self) -> &str {
    self.population.as_deref().unwrap_or("")
  }
  pub fn has_rank(&self) -> bool {
    self.rank.is_some()
  }
  pub fn set_rank(&mut self, v: ::std::string::String) {
    self.rank = Some(v);
  }
  pub fn take_rank(&mut self) -> ::std::string::String {
    self.rank.take().unwrap_or_default()
  }
  pub fn get_rank(&self) -> &str {
    self.rank.as_deref().unwrap_or("")
  }
  pub fn has_state(&self) -> bool {
    self.state.is_some()
  }
  pub fn set_state(&mut self, v: ::std::string::String) {
    self.state = Some(v);
  }
  pub fn take_state(&mut self) -> ::std::string::String {
    self.state.take().unwrap_or_default()
  }
  pub fn get_state(&self) -> &str {
    self.state.as_deref().unwrap_or("")
  }
}
impl ::std::default::Default for City {
  fn default() -> Self {
    City {
      city: ::std::default::Default::default(),
      growth_from_2000_to_2013: ::std::default::Default::default(),
      latitude: ::std::default::Default::default(),
      longitude: ::std::default::Default::default(),
      population: ::std::default::Default::default(),
      rank: ::std::default::Default::default(),
      state: ::std::default::Default::default(),
    }
  }
}
impl ::pb_jelly::Message for City {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "City",
      full_name: "pbtest.City",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "city",
          full_name: "pbtest.City.city",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "growth_from_2000_to_2013",
          full_name: "pbtest.City.growth_from_2000_to_2013",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "latitude",
          full_name: "pbtest.City.latitude",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "longitude",
          full_name: "pbtest.City.longitude",
          index: 3,
          number: 4,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "population",
          full_name: "pbtest.City.population",
          index: 4,
          number: 5,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "rank",
          full_name: "pbtest.City.rank",
          index: 5,
          number: 6,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "state",
          full_name: "pbtest.City.state",
          index: 6,
          number: 7,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut city_size = 0;
    for val in &self.city {
      let l = ::pb_jelly::Message::compute_size(val);
      city_size += ::pb_jelly::wire_format::serialized_length(1);
      city_size += ::pb_jelly::varint::serialized_length(l as u64);
      city_size += l;
    }
    size += city_size;
    let mut growth_from_2000_to_2013_size = 0;
    for val in &self.growth_from_2000_to_2013 {
      let l = ::pb_jelly::Message::compute_size(val);
      growth_from_2000_to_2013_size += ::pb_jelly::wire_format::serialized_length(2);
      growth_from_2000_to_2013_size += ::pb_jelly::varint::serialized_length(l as u64);
      growth_from_2000_to_2013_size += l;
    }
    size += growth_from_2000_to_2013_size;
    let mut latitude_size = 0;
    for val in &self.latitude {
      let l = ::pb_jelly::Message::compute_size(val);
      latitude_size += ::pb_jelly::wire_format::serialized_length(3);
      latitude_size += l;
    }
    size += latitude_size;
    let mut longitude_size = 0;
    for val in &self.longitude {
      let l = ::pb_jelly::Message::compute_size(val);
      longitude_size += ::pb_jelly::wire_format::serialized_length(4);
      longitude_size += l;
    }
    size += longitude_size;
    let mut population_size = 0;
    for val in &self.population {
      let l = ::pb_jelly::Message::compute_size(val);
      population_size += ::pb_jelly::wire_format::serialized_length(5);
      population_size += ::pb_jelly::varint::serialized_length(l as u64);
      population_size += l;
    }
    size += population_size;
    let mut rank_size = 0;
    for val in &self.rank {
      let l = ::pb_jelly::Message::compute_size(val);
      rank_size += ::pb_jelly::wire_format::serialized_length(6);
      rank_size += ::pb_jelly::varint::serialized_length(l as u64);
      rank_size += l;
    }
    size += rank_size;
    let mut state_size = 0;
    for val in &self.state {
      let l = ::pb_jelly::Message::compute_size(val);
      state_size += ::pb_jelly::wire_format::serialized_length(7);
      state_size += ::pb_jelly::varint::serialized_length(l as u64);
      state_size += l;
    }
    size += state_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize {
    let mut size = 0;
    for val in &self.city {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.growth_from_2000_to_2013 {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.latitude {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.longitude {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.population {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.rank {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.state {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.city {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.growth_from_2000_to_2013 {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.latitude {
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.longitude {
      ::pb_jelly::wire_format::write(4, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.population {
      ::pb_jelly::wire_format::write(5, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.rank {
      ::pb_jelly::wire_format::write(6, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.state {
      ::pb_jelly::wire_format::write(7, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "City", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.city = Some(val);
        }
        2 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "City", 2)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.growth_from_2000_to_2013 = Some(val);
        }
        3 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "City", 3)?;
          let mut val: f64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.latitude = Some(val);
        }
        4 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "City", 4)?;
          let mut val: f64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.longitude = Some(val);
        }
        5 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "City", 5)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.population = Some(val);
        }
        6 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "City", 6)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.rank = Some(val);
        }
        7 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "City", 7)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::std::string::String = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.state = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for City {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "city" => {
        ::pb_jelly::reflection::FieldMut::Value(self.city.get_or_insert_with(::std::default::Default::default))
      }
      "growth_from_2000_to_2013" => {
        ::pb_jelly::reflection::FieldMut::Value(self.growth_from_2000_to_2013.get_or_insert_with(::std::default::Default::default))
      }
      "latitude" => {
        ::pb_jelly::reflection::FieldMut::Value(self.latitude.get_or_insert_with(::std::default::Default::default))
      }
      "longitude" => {
        ::pb_jelly::reflection::FieldMut::Value(self.longitude.get_or_insert_with(::std::default::Default::default))
      }
      "population" => {
        ::pb_jelly::reflection::FieldMut::Value(self.population.get_or_insert_with(::std::default::Default::default))
      }
      "rank" => {
        ::pb_jelly::reflection::FieldMut::Value(self.rank.get_or_insert_with(::std::default::Default::default))
      }
      "state" => {
        ::pb_jelly::reflection::FieldMut::Value(self.state.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct CitiesSSO {
  pub cities: ::std::vec::Vec<CitySSO>,
}
impl CitiesSSO {
  pub fn set_cities(&mut self, v: ::std::vec::Vec<CitySSO>) {
    self.cities = v;
  }
  pub fn take_cities(&mut self) -> ::std::vec::Vec<CitySSO> {
    ::std::mem::take(&mut self.cities)
  }
  pub fn get_cities(&self) -> &[CitySSO] {
    &self.cities
  }
  pub fn mut_cities(&mut self) -> &mut ::std::vec::Vec<CitySSO> {
    &mut self.cities
  }
}
impl ::std::default::Default for CitiesSSO {
  fn default() -> Self {
    CitiesSSO {
      cities: ::std::default::Default::default(),
    }
  }
}
impl ::pb_jelly::Message for CitiesSSO {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "CitiesSSO",
      full_name: "pbtest.CitiesSSO",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "cities",
          full_name: "pbtest.CitiesSSO.cities",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Repeated,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut cities_size = 0;
    for val in &self.cities {
      let l = ::pb_jelly::Message::compute_size(val);
      cities_size += ::pb_jelly::wire_format::serialized_length(1);
      cities_size += ::pb_jelly::varint::serialized_length(l as u64);
      cities_size += l;
    }
    size += cities_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize {
    let mut size = 0;
    for val in &self.cities {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.cities {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "CitiesSSO", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: CitySSO = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.cities.push(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for CitiesSSO {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "cities" => {
        unimplemented!("Repeated fields are not currently supported.")
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub struct CitySSO {
  pub city: ::std::option::Option<::compact_str::CompactString>,
  pub growth_from_2000_to_2013: ::std::option::Option<::compact_str::CompactString>,
  pub latitude: ::std::option::Option<f64>,
  pub longitude: ::std::option::Option<f64>,
  pub population: ::std::option::Option<::compact_str::CompactString>,
  pub rank: ::std::option::Option<::compact_str::CompactString>,
  pub state: ::std::option::Option<::compact_str::CompactString>,
}
impl CitySSO {
  pub fn has_city(&self) -> bool {
    self.city.is_some()
  }
  pub fn set_city(&mut self, v: ::compact_str::CompactString) {
    self.city = Some(v);
  }
  pub fn take_city(&mut self) -> ::compact_str::CompactString {
    self.city.take().unwrap_or_default()
  }
  pub fn get_city(&self) -> &str {
    self.city.as_deref().unwrap_or("")
  }
  pub fn has_growth_from_2000_to_2013(&self) -> bool {
    self.growth_from_2000_to_2013.is_some()
  }
  pub fn set_growth_from_2000_to_2013(&mut self, v: ::compact_str::CompactString) {
    self.growth_from_2000_to_2013 = Some(v);
  }
  pub fn take_growth_from_2000_to_2013(&mut self) -> ::compact_str::CompactString {
    self.growth_from_2000_to_2013.take().unwrap_or_default()
  }
  pub fn get_growth_from_2000_to_2013(&self) -> &str {
    self.growth_from_2000_to_2013.as_deref().unwrap_or("")
  }
  pub fn has_latitude(&self) -> bool {
    self.latitude.is_some()
  }
  pub fn set_latitude(&mut self, v: f64) {
    self.latitude = Some(v);
  }
  pub fn get_latitude(&self) -> f64 {
    self.latitude.unwrap_or(0.)
  }
  pub fn has_longitude(&self) -> bool {
    self.longitude.is_some()
  }
  pub fn set_longitude(&mut self, v: f64) {
    self.longitude = Some(v);
  }
  pub fn get_longitude(&self) -> f64 {
    self.longitude.unwrap_or(0.)
  }
  pub fn has_population(&self) -> bool {
    self.population.is_some()
  }
  pub fn set_population(&mut self, v: ::compact_str::CompactString) {
    self.population = Some(v);
  }
  pub fn take_population(&mut self) -> ::compact_str::CompactString {
    self.population.take().unwrap_or_default()
  }
  pub fn get_population(&self) -> &str {
    self.population.as_deref().unwrap_or("")
  }
  pub fn has_rank(&self) -> bool {
    self.rank.is_some()
  }
  pub fn set_rank(&mut self, v: ::compact_str::CompactString) {
    self.rank = Some(v);
  }
  pub fn take_rank(&mut self) -> ::compact_str::CompactString {
    self.rank.take().unwrap_or_default()
  }
  pub fn get_rank(&self) -> &str {
    self.rank.as_deref().unwrap_or("")
  }
  pub fn has_state(&self) -> bool {
    self.state.is_some()
  }
  pub fn set_state(&mut self, v: ::compact_str::CompactString) {
    self.state = Some(v);
  }
  pub fn take_state(&mut self) -> ::compact_str::CompactString {
    self.state.take().unwrap_or_default()
  }
  pub fn get_state(&self) -> &str {
    self.state.as_deref().unwrap_or("")
  }
}
impl ::std::default::Default for CitySSO {
  fn default() -> Self {
    CitySSO {
      city: ::std::default::Default::default(),
      growth_from_2000_to_2013: ::std::default::Default::default(),
      latitude: ::std::default::Default::default(),
      longitude: ::std::default::Default::default(),
      population: ::std::default::Default::default(),
      rank: ::std::default::Default::default(),
      state: ::std::default::Default::default(),
    }
  }
}
impl ::pb_jelly::Message for CitySSO {
  fn descriptor(&self) -> ::std::option::Option<::pb_jelly::MessageDescriptor> {
    Some(::pb_jelly::MessageDescriptor {
      name: "CitySSO",
      full_name: "pbtest.CitySSO",
      fields: &[
        ::pb_jelly::FieldDescriptor {
          name: "city",
          full_name: "pbtest.CitySSO.city",
          index: 0,
          number: 1,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "growth_from_2000_to_2013",
          full_name: "pbtest.CitySSO.growth_from_2000_to_2013",
          index: 1,
          number: 2,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "latitude",
          full_name: "pbtest.CitySSO.latitude",
          index: 2,
          number: 3,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "longitude",
          full_name: "pbtest.CitySSO.longitude",
          index: 3,
          number: 4,
          typ: ::pb_jelly::wire_format::Type::Fixed64,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "population",
          full_name: "pbtest.CitySSO.population",
          index: 4,
          number: 5,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "rank",
          full_name: "pbtest.CitySSO.rank",
          index: 5,
          number: 6,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
        ::pb_jelly::FieldDescriptor {
          name: "state",
          full_name: "pbtest.CitySSO.state",
          index: 6,
          number: 7,
          typ: ::pb_jelly::wire_format::Type::LengthDelimited,
          label: ::pb_jelly::Label::Required,
          oneof_index: None,
        },
      ],
      oneofs: &[
      ],
    })
  }
  fn compute_size(&self) -> usize {
    let mut size = 0;
    let mut city_size = 0;
    for val in &self.city {
      let l = ::pb_jelly::Message::compute_size(val);
      city_size += ::pb_jelly::wire_format::serialized_length(1);
      city_size += ::pb_jelly::varint::serialized_length(l as u64);
      city_size += l;
    }
    size += city_size;
    let mut growth_from_2000_to_2013_size = 0;
    for val in &self.growth_from_2000_to_2013 {
      let l = ::pb_jelly::Message::compute_size(val);
      growth_from_2000_to_2013_size += ::pb_jelly::wire_format::serialized_length(2);
      growth_from_2000_to_2013_size += ::pb_jelly::varint::serialized_length(l as u64);
      growth_from_2000_to_2013_size += l;
    }
    size += growth_from_2000_to_2013_size;
    let mut latitude_size = 0;
    for val in &self.latitude {
      let l = ::pb_jelly::Message::compute_size(val);
      latitude_size += ::pb_jelly::wire_format::serialized_length(3);
      latitude_size += l;
    }
    size += latitude_size;
    let mut longitude_size = 0;
    for val in &self.longitude {
      let l = ::pb_jelly::Message::compute_size(val);
      longitude_size += ::pb_jelly::wire_format::serialized_length(4);
      longitude_size += l;
    }
    size += longitude_size;
    let mut population_size = 0;
    for val in &self.population {
      let l = ::pb_jelly::Message::compute_size(val);
      population_size += ::pb_jelly::wire_format::serialized_length(5);
      population_size += ::pb_jelly::varint::serialized_length(l as u64);
      population_size += l;
    }
    size += population_size;
    let mut rank_size = 0;
    for val in &self.rank {
      let l = ::pb_jelly::Message::compute_size(val);
      rank_size += ::pb_jelly::wire_format::serialized_length(6);
      rank_size += ::pb_jelly::varint::serialized_length(l as u64);
      rank_size += l;
    }
    size += rank_size;
    let mut state_size = 0;
    for val in &self.state {
      let l = ::pb_jelly::Message::compute_size(val);
      state_size += ::pb_jelly::wire_format::serialized_length(7);
      state_size += ::pb_jelly::varint::serialized_length(l as u64);
      state_size += l;
    }
    size += state_size;
    size
  }
  fn compute_grpc_slices_size(&self) -> usize {
    let mut size = 0;
    for val in &self.city {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.growth_from_2000_to_2013 {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.latitude {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.longitude {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.population {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.rank {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    for val in &self.state {
      size += ::pb_jelly::Message::compute_grpc_slices_size(val);
    }
    size
  }
  fn serialize<W: ::pb_jelly::PbBufferWriter>(&self, w: &mut W) -> ::std::io::Result<()> {
    for val in &self.city {
      ::pb_jelly::wire_format::write(1, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.growth_from_2000_to_2013 {
      ::pb_jelly::wire_format::write(2, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.latitude {
      ::pb_jelly::wire_format::write(3, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.longitude {
      ::pb_jelly::wire_format::write(4, ::pb_jelly::wire_format::Type::Fixed64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.population {
      ::pb_jelly::wire_format::write(5, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.rank {
      ::pb_jelly::wire_format::write(6, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    for val in &self.state {
      ::pb_jelly::wire_format::write(7, ::pb_jelly::wire_format::Type::LengthDelimited, w)?;
      let l = ::pb_jelly::Message::compute_size(val);
      ::pb_jelly::varint::write(l as u64, w)?;
      ::pb_jelly::Message::serialize(val, w)?;
    }
    Ok(())
  }
  fn deserialize<B: ::pb_jelly::PbBufferReader>(&mut self, mut buf: &mut B) -> ::std::io::Result<()> {
    while let Some((field_number, typ)) = ::pb_jelly::wire_format::read(&mut buf)? {
      match field_number {
        1 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "CitySSO", 1)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::compact_str::CompactString = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.city = Some(val);
        }
        2 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "CitySSO", 2)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::compact_str::CompactString = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.growth_from_2000_to_2013 = Some(val);
        }
        3 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "CitySSO", 3)?;
          let mut val: f64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.latitude = Some(val);
        }
        4 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::Fixed64, "CitySSO", 4)?;
          let mut val: f64 = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, buf)?;
          self.longitude = Some(val);
        }
        5 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "CitySSO", 5)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::compact_str::CompactString = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.population = Some(val);
        }
        6 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "CitySSO", 6)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::compact_str::CompactString = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.rank = Some(val);
        }
        7 => {
          ::pb_jelly::ensure_wire_format(typ, ::pb_jelly::wire_format::Type::LengthDelimited, "CitySSO", 7)?;
          let len = ::pb_jelly::varint::ensure_read(&mut buf)?;
          let mut next = ::pb_jelly::ensure_split(buf, len as usize)?;
          let mut val: ::compact_str::CompactString = ::std::default::Default::default();
          ::pb_jelly::Message::deserialize(&mut val, &mut next)?;
          self.state = Some(val);
        }
        _ => {
          ::pb_jelly::skip(typ, &mut buf)?;
        }
      }
    }
    Ok(())
  }
}
impl ::pb_jelly::Reflection for CitySSO {
  fn which_one_of(&self, oneof_name: &str) -> ::std::option::Option<&'static str> {
    match oneof_name {
      _ => {
        panic!("unknown oneof name given");
      }
    }
  }
  fn get_field_mut(&mut self, field_name: &str) -> ::pb_jelly::reflection::FieldMut<'_> {
    match field_name {
      "city" => {
        ::pb_jelly::reflection::FieldMut::Value(self.city.get_or_insert_with(::std::default::Default::default))
      }
      "growth_from_2000_to_2013" => {
        ::pb_jelly::reflection::FieldMut::Value(self.growth_from_2000_to_2013.get_or_insert_with(::std::default::Default::default))
      }
      "latitude" => {
        ::pb_jelly::reflection::FieldMut::Value(self.latitude.get_or_insert_with(::std::default::Default::default))
      }
      "longitude" => {
        ::pb_jelly::reflection::FieldMut::Value(self.longitude.get_or_insert_with(::std::default::Default::default))
      }
      "population" => {
        ::pb_jelly::reflection::FieldMut::Value(self.population.get_or_insert_with(::std::default::Default::default))
      }
      "rank" => {
        ::pb_jelly::reflection::FieldMut::Value(self.rank.get_or_insert_with(::std::default::Default::default))
      }
      "state" => {
        ::pb_jelly::reflection::FieldMut::Value(self.state.get_or_insert_with(::std::default::Default::default))
      }
      _ => {
        panic!("unknown field name given")
      }
    }
  }
}

